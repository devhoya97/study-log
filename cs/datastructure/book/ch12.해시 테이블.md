### 개요
- 해시 테이블은 자료를 검색, 삽입, 삭제하는데 평균 O(1) 시간이 가능하게 하여 극한적 효율에 다다른 자료구조
- 검색 트리는 검색 또는 저장하려는 키와 검색트리에 있는 키 간 비교를 기본 연산으로 한다.
  - 이와 같이 키 비교를 기본으로 하는 한 평균 logn 시간은 피할 수 없다.
- 해시 테이블은 키 자신의 값에 따라 자리가 결정되므로 위와 같은 한계를 돌파할 수 있다.

### 해시 테이블
- 임의의 키를 해시 테이블에 저장하려면 먼저 해당 키의 해싯값을 해시 함수로 계산해야 한다.
  - 해시 테이블이 총 m개의 키를 저장할 수 있다면, 테이블의 각 자리는 0부터 m-1의 주솟값을 갖는다.
  - 해시 함수는 임의의 킷값을 입력으로 받아 주소 0,1,2, ... , m-1 중 한 값을 리턴한다.
  - 이 리턴 값이 바로 해당 키를 저장하는 자리가 된다.
  - 가장 간단한 방법은 킷값이 x라면 x를 m으로 나눈 나머지를 해싯값으로 삼는 것이다.
- 해시 테이블에 원소가 차 있는 비율(적재율)은 해시 테이블의 성능에 매우 중요한 영향을 미친다.
  - 적재율이 높을수록 충돌 확률은 높아져 해시 테이블의 성능이 나빠진다.

# 해시 함수
### 해시 함수
- 해시 함수는 킷값을 입력으로 받아 해시 테이블상의 주소를 리턴한다.
- 해시 함수는 입력 키를 해시 테이블 전체에 고루 분산시켜 저장해야 한다.
  - 두 키가 상대적으로 비슷하다고 해서 다른 키들보다 상대적으로 해싯값이 더 비슷하지 않아야 한다.
  - 해싯값은 입력 키의 모든 비트를 이용하는 것이 확률적으로 좋은 분포를 갖도록 하는 데 유리하다.

### 나누기 방법
- 해시 테이블 크기보다 큰 수를 해시 테이블 크기 범위에 들어오도록 수축시킨다.
- 해시 테이블의 크기기 m은 2의 멱수에 가깝지 않은 소수를 택하는 것이 좋다.
  - 만일 m = 2^p 라면, 입력 키의 하위 p비트에 의해 해싯값이 결정되므로 해싯값을 분산시키기에 그리 이상적이지 않다.
  - 나누기 2는 right shift이므로 하위 p비트가 곧바로 해싯값이 되어버리는구나

### 곱하기 방법
- 먼저 입력 값을 0과 1 사이의 소수로 대응시킨 다음 해시 테이블 크기 m을 곱하여 0부터 m-1 사이로 팽창시킨다.
  - 임의의 키 x에 대해 0<A<1 범위의 상수 A를 곱한 다음 소수부만 취한다.
  - 방금 취한 소수부에 m을 곱하여 그 정수부를 취한다.
- 곱하기 방법은 나누기 방법과 달리 해시 테이블의 크기 m을 아무렇게나 잡아도 상관 없다.
  - 따라서 컴퓨터의 이진수 환경에 맞게 m = 2^p으로 잡는 것이 자연스럽다.
- 상수 A를 어떻게 잡느냐에 따라 해싯값 분포가 영향을 받는데, 크누스가 제안한 0.6170339887... 이 많이 사용되는 듯

# 충돌 해결
### 체이닝
- 충돌을 일으킨 키들을 연결 리스트로 관리하는 방법
- 해시 테이블의 각 주소가 리스트의 헤더 역할을 하고, 여기에 해당 주소로 들어오는 키들이 연결 리스트에 매달린다.
- 키를 검색할 때는 해당 연결 리스트의 키들을 차례로 지나가면서 찾는다.

### 개방 주소 방법
- 체이닝처럼 추가 공간을 사용하지 않고 어떻게든 해시 테이블 안에서 충돌을 해결하는 방법
  - 충돌이 일어나면 키가 원래 들어갈 자리가 아니더라도 테이블의 다른 자리를 찾아 들어간다.
  - 따라서 모든 키가 반드시 자신의 해싯값과 일치하는 주소에 저장된다는 보장은 없다.
- 테이블에 주어진 공간만 사용할 수 있으므로 적재율이 1을 넘을 수 없다.
  - 적재율이 어느 정도 이상 높아지면 효율이 급격히 떨어지므로 적당한 임계쩜을 설정한 후 그 임계점을 넘으면 해시 테이블의 크기를 2배로 키우는 것이 일반적
  - 테이블 크기가 바뀌면 해시 함수가 바뀌므로 모든 키를 다시 해싱한다.
- 키를 삭제할 경우 빈 자리로 두는 게 아니라 DELETED라는 상숫값을 저장하여 삭제된 자리임을 표시해줘야 한다.
  - 그렇지 않으면 특정 키가 저장되어 있음에도 불구하고, 저장되어 있지 않다고 오인할 수 있다. (자세한 예시는 책 참고)

### 개방 주소 방법의 충돌 해결 방법
- 선형 탐색
  - 충돌이 일어난 바로 뒷자리를 보는 것
  - 특정 영역에 키가 몰릴 때 치명적으로 성능이 떨어진다.
  - 이런 현상을 1차 군집(Primary Clustering)이라 한다.
- 이차원 탐색
  - 충돌이 일어난 바로 뒷자리를 보는 대신 보폭을 이차 함수에 의해 넓혀가면서 본다.
  - 이차 함수를 쓰면 1차 군집이 생겨 특정 영역에 키가 몰려도 그 영역을 빨리 벗어날 수 있다.
  - 여러 개의 키가 동일한 초기 해시 함숫값을 가지면 모두 같은 순서로 탐색하게 되므로 비효율을 피할 수 없어 2차 군집(Secondary Clustering)이 발생한다.
  - 즉 보폭은 점점 넓어지지만 최초의 해싯값이 같은 키들은 이차원 탐색으로 인해 이득을 보지 못한다.
- 더블 해싱
  - 두 개의 함수를 사용하며, 충돌이 생겨 다음에 볼 주소를 계산할 때 두 번째 해시 함숫값만큼씩 점프한다.
  - 두 키의 첫 번째 해싯값이 같더라도 두 번째 함숫값이 같을 확률은 매우 작으므로 서로 다른 보폭으로 점프하게 되어 2차 군집 문제가 발생하지 않는다.
  - 두 번째 해시 함숫값 f(x)와 해시 테이블의 크기 m이 1보다 큰 최소공약수 d를 가지면 x의 자리를 찾기 위해 해시 테이블 전체 중에 기껏해야 1/d 밖에 보지 못하게 된다?

### 체이닝 vs 개방 주소 방법
- 이론적으로는 체이닝이 개방 주소 방식보다 좋다.
  - 개방 주소 방식의 경우 자신과 최초 해싯값이 같지 않은 키라도 검색 과정에서 방해를 할 수 있기 때문이다.
  - 하지만 체이닝은 연결 리스트마다 헤드를 하나씩 두어야 하고, 연결 리스트를 만들기 위해 각 키마다 연결을 위한 공간이 필요하다.
  - 따라서 적재율이 그리 높지 않을 때는 개방 주소 방법도 매력적인 선택지가 된다.
- 개방 주소 방법은 적재율이 절대로 1을 넘지는 못하는 반면, 체이닝은 제한이 없다.
  - 그렇지만 어떤 경우든 적재율이 높으면 해싱의 효율이 떨어지기 때문에 적절하게 낮은 적재율을 유지할 필요가 있다.
