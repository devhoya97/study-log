### 컴퓨터 시스템의 구조
- 내부 장치
  - CPU, 메모리
- 외부 장치(입출력 장치)
  - 디스크, 키보드, 모니터, 네트워크 장치
- 컴퓨터는 외부장치에서 내부장치로 데이터를 읽어와 연산을 수행한 후, 그 결과를 외부장치로 다시 내보내는 방식으로 업무를 처리
- 메모리 및 입출력 장치는 각자 컨트롤러를 가진다.
  - 컨트롤러는 장치로부터 들어오고 나가는 데이터를 임시로 저장하기 위한 작은 메모리(로컬버퍼)를 가진다.
  - 디스크에서 데이터를 읽어오는 경우, 우선 로컬버퍼에 데이터가 임시로 저장된 후 메모리에 전달된다.

### CPU 연산과 IO 연산
- 입출력 장치들의 IO 연산은 입출력 컨트롤러가 담당하고, 컴퓨터 내에서 수행되는 연산은 메인 CPU가 담당한다.
  - 입출력 장치의 연산과 메인 CPU의 연산은 서로 다른 곳에서 발생하므로 동시 수행이 가능하다.
- 장치에서 로컬버퍼로 데이터를 읽어오는 일은 컨트롤러가 담당한다.
  - ex. 디스크 컨트롤러가 디스크에서 로컬버퍼로 데이터를 읽어온 후, 인터럽트를 발생시켜 CPU에 보고한다.
- CPU는 매시점 메모리에서 명령을 하나씩 읽어와서 수행하는데, CPU 옆에는 인터럽트 라인이 있다.
  - CPU는 명령 하나를 수행할 때마다 인터럽트가 발생했는지 확인한다. 
  - 인터럽트 라인에 신호가 들어오면 CPU는 하던 일을 멈추고 인터럽트를 먼저 처리한다.

### 인터럽트의 일반적 기능
- 운영체제는 각종 하드웨어 및 소프트웨어 자원 관리뿐 아니라 사용자 프로그램에 필요한 서비스도 제공한다.
  - 운영체제가 해야 할 일들은 운영체제 개발자가 미리 프로그래밍해서 커널 내에 포함시켜뒀다.
  - 그 중 하나가 인터럽트 처리 루틴이다.
  - CPU의 인터럽트 라인은 번호에 맞게 여러개 존재하는데, 인터럽트가 발생하면 인터럽트 벡터와 번호에 따라 인터럽트 처리 루틴을 찾아간다.
- 하드웨어 인터럽트
  - 일반적으로 인터럽트라고 하면 하드웨어 인터럽트를 의미한다. 
  - 컨트롤러 등 하드웨어 장치가 CPU의 인터럽트 라인을 세팅한다.
- 소프트웨어 인터럽트(Trap)
  - 프로세스가 CPU의 인터럽트 라인을 세팅한다.

### 소프트웨어 인터럽트(Trap)
- exception
  - 아래와 같은 경우를 처리하기 위해 발생시키는 인터럽트
    - 비정상적인 작업 시도(ex.0으로 나누기)
    - 권한이 없는 작업 시도(ex. 자신의 메모리 영역 바깥에 접근)
  - exception은 사용자 프로그램이 발생시키는 것이 아니라, CPU가 예외 상황을 감지하여 자동으로 발생?
- system call
  - 사용자 프로그램이 운영체제 내부에 정의된 코드를 실행하고 싶을 때 운영체제에 서비스를 요청하는 방법
  - 사용자 프로그램 자신의 코드는 직접 CPU를 가지고 실행하지만, 커널에 있는 코드를 사용자 프로그램이 실행하고자 할 때에는 CPU 제어권을 운영체제로 넘겨 실행

### 인터럽트 핸들링
- 인터럽트가 발생한 경우에 처리해야 할 일의 절차
- 프로그램 A가 실행되고 있을 때 인터럽트가 발생하면 A의 현재 상태를 PCB에 저장한 뒤 CPU의 제어권이 인터럽트 처리 루틴으로 넘어감
  - PCB는 각각의 프로그램마다 하나씩 존재
  - CPU에서 실행 중인 명령의 메모리 주소 저장
  - CPU 내부에 있는 임시 기억장치인 레지스터 값 저장
  - 하드웨어 상태 저장
- 인터럽트 처리가 끝나면 저장된 상태를 PCB로부터 CPU상에 복원해 인터럽트 당하기 직전의 위치부터 실행
- 오늘날의 컴퓨터에서 운영체제는 인터럽트가 발생할 때에만 실행된다.
  - 그 외에는 CPU가 항상 사용자 프로그램에 의해 사용된다.
  - 운영체제가 직접 CPU를 점유하는 경우는 인터럽트에 의하지 않고는 발생하지 않는다.

### 입출력 구조
- 입출력이란 컴퓨터 시스템이 컴퓨터 외부의 입출력 장치들과 데이터를 주고 받는 것을 말한다.
- 동기식 입출력
  - 프로그램A가 입출력 요청을 했을 때, 입출력 작업이 완료된 후에야 후속 작업을 수행할 수 있는 방식
    - 프로그램이 입출력을 수행 중인데도 CPU를 다른 프로그램에게 이양하지 않는 경우
    - 매 시점 시스템 내에서는 하나의 입출력 연산만 수행된다.
    - 동기화가 자동적으로 이루어질 수 있다는 장점이 있긴 하다.
    - 입출력 연산이 끝날 때까지 CPU는 인터럽트를 기다리며 자원을 낭비하게 된다.
  - 이러한 비효율을 방지하기 위해 일반적으로 프로그램이 입출력을 수행 중인 경우 CPU를 다른 프로그램에게 이양한다. (또는 같은 프로세스의 다른 스레드에게 이양할 수도 있을 듯?)
    - 이 때, 프로그램A는 blocked state로 전환된다. 
    - blocked state의 프로그램에게는 CPU를 할당해봤자 명령을 수행하지 못하므로, CPU 할당 후보에서 제외된다.
    - 다수의 입출력 연산이 동시에 요청되거나 처리될 수 있다.
      - 입출력 요청의 동기화를 위해 장치별로 큐를 두어 순서대로 요청을 처리함으로써 동기화 문제를 해결
      - 큐에 있는 순서대로 처리하는 대신 요청을 모으고 처리 순서를 바꾸어 입출력의 효율성을 높일 수도 있는데, 이 경우 동기화를 보장하기 위한 별도의 방안이 필요
    - 프로그램A가 요청한 입출력 연산이 완료되면 장치 컨트롤러는 CPU에게 인터럽트를 보내고, 운영체제 커널은 인터럽트 처리루틴으로 가서 프로그램A의 상태를 blocked에서 해제
- 비동기식 입출력
  - 프로그램A가 입출력 연산을 요청한 후, CPU 제어권을 다시 할당받아 입출력 연산의 결과가 필요 없는 후속 작업을 이어서 수행
  - 예를 들어 디스크에 쓰는 요청
  - 디스크에 읽는 요청이라도 읽어오는 데이터와 관련없는 작업을 후속 작업으로 수행함으로써 비동기식 입출력이 가능하기도 함

### DMA
- 원칙적으로 메모리는 CPU에 의해서만 접근할 수 있는 장치
  - 따라서 CPU 외의 장치가 메모리의 데이터에 접근하기 위해서는 CPU에게 인터럽트를 발생시켜 CPU가 이를 대행하는 식으로만 가능
  - 입출력 장치가 메모리 접근을 원할 때마다 인터럽트에 의해 CPU의 업무가 방해를 받게 되어 CPU 사용의 효율성이 떨어지는 문제점 발생
  - CPU 이외에 메모리 접근이 가능한 장치(DMA)를 하나 더 둠으로써 문제 해결
- DMA는 일종의 컨트롤러
  - CPU가 입출력 장치들의 메모리 접근 요청에 의해 자주 인터럽트 당하는 것을 막아주는 역할
  - 로컬버퍼에서 메모리로 데이터를 읽어오는 작업을 CPU 대신 수행
  - 바이트 단위가 아니라 블록이라는 큰 단위로 정보를 메모리로 읽어온 후에 CPU에게 인터럽트를 발생시켜서 해당 작업의 완료를 알림
  - 결과적으로 CPU에게 발생하는 인터럽트의 빈도가 줄어듦

### 스왑 영역
- 운영체제는 프로그램 수행에 당장 필요한 부분만 메모리에 올려놓고 그렇지 않은 부분은 디스크의 스왑 영역에 내려놓는다.
  - 디스크에 내려 놓는 일을 스왑 아웃시킨다고 말한다.
  - 스왑 아웃된 부분은 필요할 때 다시 메모리 영역으로 올라간다.
- 스왑 영역으로는 하드디스크가 가장 널리 사용된다.
- 스왑 영역은 프로그램이 실행될 때 내용을 저장했다가 프로그램이 종료될 때 삭제하는 메모리의 연장 공간으로서의 역할을 담당한다.
  - 즉 파일 시스템처럼 비휘발성 용도로 사용되는 것과는 역할이 구분된다.

### 하드디스크
- 여러 개의 마그네틱 원판들이 있고, 암(arm)이 이동하며 원판에 저장된 데이터를 읽고 쓰는 방식으로 동작
- 드스크 원판의 표면은 트랙으로 나뉘고, 각 트랙은 섹터로 나뉜다.
- 섹터에 최소한의 단위 정보가 저장된다.

### 캐싱
- 캐싱 기법이 적은 용량으로도 효과를 거둘 수 있는 것은 컴퓨터 내의 데이터나 프로그램을 구성하는 모든 부분이 균일하게 사용되는 것이 아니라 일부분만이 집중적으로 사용되고 특정 부분은 거의 사용되지 않기 때문
- 예를 들어 프로그램의 코드 중 많은 횟수 동안 반복되는 코드와, 한 번 수행되고 끝나는 부분이 있을 수 있다.
  - 반복되는 코드를 빠른 저장장치에 올려놓으면 적은 저장공간만으로도 전체 시스템의 평균적인 성능을 향상시킬 수 있다.

### 하드웨어의 보안(디스크)
- 다중 프로그래밍 환경에서는 각 프로그램이 다른 프로그램의 실행을 방해하거나 프로그램 간에 충돌을 일으키는 문제를 막기 위해 하드웨어에 대한 각종 보안 기법이 필요
- 운영체제는 기본적으로 커널모드와 사용자모드를 분리함으로써 하드웨어적인 보안을 유지
  - 중요한 정보에 접근해 위험한 상황을 초래할 수 있는 연산은 커널모드에서만 실행 가능
  - 사용자모드에서는 일반적인 연산만 가능
- 사용자 프로그램이 CPU를 가지고 있는 동안에는 운영체제가 자신의 코드를 실행하지 못하는데, 사용자 프로그램이 위험한 연산을 하는지 어떻게 감시할 수 있을까?
  - 하드웨어적인 지원이 필요하다.
  - 즉 CPU 내부에 모드 비트를 두어 사용자 프로그램을 감시한다.
  - 모드비트가 1로 세팅되어 있으면 사용자모드로서 제한된 명령만을 수행할 수 있다.
  - CPU는 보안과 관련된 명령을 수행하기 전에는 항상 모드비트를 조사해 그 값이 0으로 세팅된 경우에만 그 명령을 수행한다.
- 모든 입출력 명령은 특권명령으로 규정해서 사용자 프로그램은 직접 입출력이 불가능하다.
  - 운영체제만 입출력 명령을 수행할 수 있으므로 사용자 프로그램은 입출력 명령이 필요한 경우 시스템 콜을 이용해야 한다.
  - 운영체제는 입출력 요청이 올바른 요청인지 확인한 후, 인터럽트 처리루틴에 따라 입출력을 실행하기 때문에 파일에 대한 보안을 유지할 수 있다.

### 메모리 보안
- 메모리 접근 연산은 사용자 프로그램이 CPU를 가지고 있는 동안 수행할 수 있는 연산이므로 특권명령은 아니다.
  - 다만 사용자 프로그램이 메모리에 접근하기 전, 하드웨어적으로 그 접근이 합법적인지 체크하여 메모리를 보호한다.
  - 이것이 운영체제만이 수행할 수 있는 입출력 연산과 메모리 접근 연산의 차이점이다.
- 여러 프로그램이 메모리에 동시에 올라가서 실행되기 때문에 하나의 사용자 프로그램이 다른 사용자 프로그램이나 운영체제가 위치한 메모리 영역을 침범할 수 있다.
  - 사용자 프로그램이 인터럽트 처리루틴을 접근하거나 변경할 수 있는 경우, 특권명령을 보안성이 침해되는 이상한 명령으로 변형할 수 있게 된다.
  - 2개의 레지스터(base register, limit register)를 사용해서 프로그램이 접근하려는 메모리 부분이 합법적인지 체크함으로써 메모리를 보호한다.
  - (base register 값 <= 사용자 프로그램이 접근하려는 주소 < base register 값 + limit register 값)을 만족해야 한다.
  - 위 조건을 만족하지 못하면 소프트웨어 인터럽트인 exception이 발생한다.
  - exception이 발생하면 운영체제에 소프트웨어 인터럽트를 발생시키고 CPU의 제어권이 운영체제로 이양되며 해당 사용자 프로그램은 강제종료된다.
  - 단 2개의 레지스터를 활용하는 메모리 보호 기법은 하나의 프로그램이 메모리의 한 영역에 연속적으로 위치해야 한다는 조건이 필요하다.
  - 하나의 프로그램이 메모리의 여러 영역에 나뉘어 위치하는 페이징 기법이 활용되면, 좀 더 현실적인 메모리 관리 보호기법이 필요하다.

### CPU 독점을 막는 타이머
- 타이머는 정해진 시간이 지나면 인터럽트를 발생시켜 운영체제가 CPU의 제어권을 획득할 수 있도록 한다.
- 타이머의 값을 세팅하는 명령을 로드 타이머라고 하며, 이는 특권명령에 속한다.
