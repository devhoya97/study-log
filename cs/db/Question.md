# 데이터베이스
### RDB란 무엇인가요?
관계형 데이터베이스는 관계형 데이터 모델에 기초를 둔 데이터베이스로, 모든 데이터를 2차원 테이블 형태로 표현합니다.
테이블은 이름을 갖고, row와 column, 그리고 그에 대응하는 값을 가집니다.
RDB에서는 테이블 간 관계를 나타내기 위해 FK를 사용하며 정규화를 통해 데이터를 중복없이 저장해 이상현상을 방지할 수 있습니다.
일반적으로 트랜잭션을 지원해 ACID 특성을 지킬 수 있으며 SQL을 통해 데이터에 CRUD 연산이 가능합니다.

### 키 종류
### JOIN에 대해서 설명해 주세요.
### 내부 조인, 외부 조인, 셀프 조인
### SQL Injection이란
### 파티셔닝과 샤딩에 대해서 설명해 주세요.
### ORM이란 무엇인가요?
### NoSQL이란 무엇인가요?
Not Only SQL로 RDB와 다르게 관계형 데이터 모델을 지양하며 대량의 분산된 비정형 데이터를 저장하고 조회하는데 특화된 데이터베이스입니다.
NoSQL은 고정되어 있지 않은 스키마를 가지므로, 스키마 변경에 유연하
NoSQL은 분산형 구조에 유리하게 설계되어 있어 여러 곳의 서버에 데이터를 분산저장하여 scale out에 용이합니다.
NoSQL은 데이터를 분산저장하기 때문에 한 영역에 update가 생길 시 실시간으로 다른 영역에 반영하는 것이 쉽지 않아
항상 데이터의 일관성을 보장하기보다, 최종적 일관성을 보장하는 것을 지향합니다.


### 스키마란 무엇인가요?
### View란 무엇인가요?

# 정규화
### 이상 현상에 대해서 설명해 주세요.
이상현상이란 관련이 없는 속성들이 하나의 릴레이션에 모여있어 불필요한 데이터 중복으로 인해 삽입, 수정, 삭제 연산을 수행할 때 부작용이 발생하는 현상을 말합니다.
삽입이상이란 테이블에 row를 추가할 때, 의도하지 않은 데이터까지 삽입해야만 하는 현상입니다. 
갱신이상이란 중복된 데이터 중 일부만 수정되어 데이터 모순이 일어나는 현상입니다.
삭제 이상이란 어떤 정보를 삭제했을 때 의도치 않은 다른 정보까지 삭제되는 현상입니다.
이상 현상을 방지하기 위해선 테이블 정규화를 수행해야 합니다.

### 정규화에 대해서 설명해 주세요.
정규화란 함수 종속성을 이용하여 릴레이션을 연관성이 있는 속성들로만 구성되도록 분해해서, 이상 현상이 발생하지 않는 릴레이션으로 만들어나가는 과정입니다.

### 반정규화란?
### 정규화의 종류에 대해서 말해보세요.
정규화는 일반적으로 1~3 정규화 과정을 거치게 되는데요. 단계가 높아질수록 조건이 추가됩니다.
제1 정규화란 테이블의 컬럼이 원자값을 갖도록 테이블을 분해하는 것입니다.
제2 정규화란 제1 정규화를 만족한 테이블에 대해 기본키가 아닌 모든 속성이 기본키에 완전 함수 종속되도록 테이블을 분해하는 것입니다.
여기서 완전 함수 종속이란 기본 키의 부분집합이 결정자가 되어서는 안 된다는 것을 의미합니다.
제3 정규화란 제2 정규화를 만족한 테이블에 대해 기본키가 아닌 모든 속성이 기본 키에 이행적 함수 종속되지 않도록 테이블을 분해하는 것입니다.
여기서 이행적 함수 종속은 A가 B를 결정할 때, B가 C를 결정하는 현상입니다.

### 함수적 종속성이란 무엇인가요?
정규화 과정에서 고려해야 하는 속성들 간의 관련성으로, 릴레이션 내의 모든 튜플에서 X값에 대한 Y값이 항상 하나면 Y가 X에 함수적으로 종속되어 있다고 말합니다.
함수 종속은 완전 함수 종속과 부분 함수 종속으로 나뉘는데,
완전 함수 종속이란 X가 Y를 결정하되, X의 부분 집합이 Y를 결정할 수 없는 경우를 의미하고,
부분 함수 종속이란 X의 부분 집합이 Y를 결정할 수 있는 경우를 의미합니다.

# 인덱스
### 인덱스란 무엇인가요? 어떻게 동작 하나요?
인덱스는 데이터베이스에서 검색 속도를 향상시키기 위해 사용되는 자료구조 입니다.
값이 정렬되어 있지 않으면 특정 값을 찾기 위해 완전탐색이 필요한데, 값이 정렬되어 있으면 이분탐색이 가능한 것처럼 
DB 컬럼에 인덱스가 걸려있으면 정렬된 정보를 바탕으로 원하는 값을 빠르게 찾을 수 있습니다.
B Tree 클러스터형 인덱스 기준으로 만약 데이터 페이지가 10개 있다면, 각 데이터 페이지는 PK 기준으로 정렬되어 있고,
루트 페이지에는 각 데이터 페이지의 첫 번째 PK 값과 데이터 페이지의 주소 값이 저장됩니다.
만약 루트 페이지의 엔트리 갯수보다 데이터 페이지의 갯수가 많다면, 중간 테이블이 생기게 되고,
PK를 기준으로 데이터 검색이 필요하면 루트페이지부터 시작해 중간 페이지를 거쳐 데이터 페이지까지 도달하는 과정을 통해 데이터 검색이 가능합니다.

### 인덱스의 알고리즘에는 어떤 것들이 있나요?
MySQL의 InnoDB와 같이 B Tree를 활용한 인덱스 알고리즘은 루트 페이지부터 리프페이지까지 따라가면서 데이터를 검색합니다.
반면 Redis는 Hash Index를 사용해서 키를 해시함수로 변환해 데이터를 곧바로 검색합니다.
B Tree의 경우 특히 클러스터형 인덱스일 때 범위 검색에 큰 강점이 있고, Hash Index의 경우엔 범위 검색이 불가능하다는 단점이 있습니다.

### Table Full Scan과 Index Range Scan 을 설명해주세요.
Index가 걸린 컬럼의 값을 기준으로 범위 검색을 하면 Index Range Scan이 발동되며 조건을 만족하는 행들이 포함된
데이터 페이지에만 접근하므로 Table Full Scan보다 일반적으로 속도가 빠릅니다.
하지만 범위의 대상이 전체 데이터의 일정비율 이상 넘어가면, 오히려 모든 데이터 페이지를 검색하는 것이 빠를 수 있습니다.
따라서 DBMS는 경우에 따라 인덱스를 사용 가능하더라도 Table Full Scan을 선택하기도 합니다.

### 클러스터드 인덱스와 비클러스터드 인덱스란 무엇인가?
클러스터드 인덱스는 리프 페이지가 곧 데이터 페이지 입니다. 따라서 실제 데이터가 클러스터형 인덱스를 기준으로 정렬되어 있습니다.
반면 비클러스터드 인덱스는 실제 데이터에 전혀 영향을 끼치지 않고, 데이터 페이지를 찾아가기 위한 별도의 저장공간을 활용합니다.
특히 클러스터드 인덱스와 비클러스터드 인덱스가 함께 사용될 경우, 비클러스터드 인덱스의 리프페이지에는 클러스터드 인덱스 값이 저장되며
따라서 비클러스터드 인덱스를 사용해 데이터를 검색하려면, 결국 클러스터드 인덱스를 활용해야 최종 데이터를 찾아갈 수 있다는 특징이 있습니다.

### 꼬리질문: 클러스터드 인덱스와 비클러스터드 인덱스가 함께 쓰일 때, 비클러스터드 인덱스로 검색해도 클러스터드 인덱스를 사용해야 하는 이유?
비클러스터드 인덱스의 리프페이지에 데이터의 주소가 아닌 클러스터드 인덱스의 값이 저장되기 때문입니다.
그 이유는, 비클러스터드 인덱스의 리프페이지가 데이터의 주소를 가리키고 있다면, 데이터 페이지에서 페이지 분할이 발생했을 때
비클러스터드 인덱스의 리프페이지 값에 너무나 많은 수정이 필요해지기 때문입니다.

### 인덱스를 추가했을 때 오버헤드는 무엇인가?
인덱스도 결국 하나의 자료구조이기 때문에 데이터와 별개로 저장공간이 할당되어야 합니다.
또한 데이터 삽입, 수정, 삭제시 인덱스도 함께 고려해줘야 하므로, 테이블에 인덱스가 너무 많이 설정되어 있으면 성능이 크게 나빠질 수 있습니다.
특히 데이터 삽입 시 페이지 분할이 일어나는 경우, 일반적인 데이터 삽입에 비해 성능이 크게 나빠집니다.


# 트랜잭션
### 트랜잭션이란 무엇인가요? 4가지 원칙을 포함해서 설명해 주세요.
(트랜잭션이 존재하는 이유는 데이터의 정합성을 보장하기 위함이다.)
DB의 논리적인 작업 단위로, 트랜잭션이라면 보장해야 하는 ACID라는 4가지 원칙을 가지고 있습니다. 
원자성은 트랜잭션 내의 모든 작업은 원자적으로 커밋되거나 롤백되어야 함을 의미합니다.
일관성은 트랜잭션을 수행하기 전에 DB의 상태가 유효했다면, 트랜잭션을 수행한 후에도 DB의 상태는 이전과 같이 유효해야 합니다.
격리성은 실행 중인 트랜잭션의 중간 결과를 다른 트랜잭션이 접근할 수 없어야 합니다. 격리수준은 사용자가 선택할 수 있습니다.
지속성은 성공적으로 수행된 트랜잭션의 경우 DB가 시스템적으로 장애가 발생하더라도 데이터가 영구히 보존되어야 합니다. (언두로그 리두로그 활용?)

### 트랜잭션의 격리 수준과 각 수준에서 발생할 수 있는 문제들에 대해 말해보세요.
read uncommitted는 아직 커밋되지 않은 트랜잭션이 변경한 데이터 변경사항을 다른 트랜잭션이 읽을 수 있는 dirty read 문제가 발생할 수 있습니다.
read committed는 repeatable read가 불가능합니다. 즉 하나의 트랜잭션에서 같은 데이터를 여러 번 읽었을 때, 중간에 다른 트랜잭션이 커밋되면 다른 결과가 나올 수 있습니다.
repeatable read는 한 트랜잭션 내에서 동일한 조회 결과를 보장하지만, 새로운 레코드가 추가되는 경우에 부정합이 생길 수 있습니다. 이를 팬텀리드 현상이라고 부릅니다.
serializable은 여러 트랜잭션이 동일한 레코드에 동시 접근하지 못하게 만들어 어떠한 데이터 부정합 문제도 발생하지 않지만, 동시 처리 성능이 매우 떨어집니다.
(serializable은 X-Lock을 사용하는건가?)

### 꼬리질문1. MVCC에 대해 설명해주세요.
락 없이 동시성 문제를 해결하기 위한 방법으로 변경 전 데이터의 스냅샷을 언두 로그로, 변경 후 데이터를 버퍼풀과 디스크로 함께 관리하는 방법입니다.
이를 통해 락 없이 REPEATABLE READ 격리 수준을 제공할 수 있고, 롤백 시에는 언두 로그를 활용하게 됩니다.
MySQL의 InnoDB의 경우 , 언두 로그에는 데이터가 계속 쌓일 수 있으므로, 
언두 로그와 연관된 트랜잭션이 모두 종료된 경우, 언두 로그도 제거되도록 구현되어 있습니다. 

### 꼬리질문2. 팬텀리드가 발생하는 상황에 대해 설명해주세요.
잠금이 사용되는 경우(select for update, share 마찬가지). 잠금있는 읽기는 데이터 조회가 언두 로그가 아닌 테이블에서 수행되기 때문에 MVCC로 막을 수 없다.
언두 로그는 append only 형태이므로 잠금 장치가 없기 때문에 잠글 수가 없다.
select for update, share로 레코드를 조회하는 경우에는 언두 영역의 데이터가 아니라 테이블의 레코드를 가져오게 되므로 팬텀리드가 발생한다.
하지만 mysql에는 갭락이 존재하기 때문에 위 상황에서 문제가 발생하지 않는다?
select where id >= 50 for update를 수행하면 mysql은 id가 50인 레코드에는 레코드 락, id가 50보다 큰 범위에는 갭 락으로 넥스트 키 락을 건다.
따라서 다른 트랜잭션이 id가 51인 insert 를 시도한다면 기다려야 한다.
mysql에서 팬텀리드가 발생하는 거의 유일한 케이스 -> tx1에서 잠금없는 selec생 문으로 조회 -> tx2에서 insert -> tx1에서 select for update로 조회하면
언두 로그가 아닌 테이블로부터 레코드를 조회하므로 팬텀리드가 발생. 하지만 이런 케이스는 거의 존재하지 않는다.

### MySQL InnoDB에서 사용하는 버퍼 풀에 대해 설명해주세요.
디스크에 저장된 테이블과 인덱스 정보를 캐시해두는 공간입니다.
이를 통해 읽기 성능을 향상시키거나 쓰기 지연을 통해 쓰기 성능을 향상시킬 수 있습니다.
쓰기 지연을 지원하지 않으면, 매번 디스크에 랜덤 IO 작업이 필요하지만, 쓰기 지연을 사용하면 쓰기 작업을 일괄적으로 수행함으로써 디스크 IO 부담을 줄일 수 있습니다.

### 트랜잭션 범위를 설정할 때 주의해야 할 점은 무엇이 있을까요?
트랜잭션 범위를 최소한으로 설정하도록 노력해야 하고, 특히 네트워크 통신 작업의 경우 DB 트랜잭션과 분리하기 위해 최대한 노력해야 합니다.
DB 커넥션 자원은 한정되어 있는데, 한 트랜잭션 작업이 오래 걸릴수록 병목이 발생할 수 있고, 
특히 네트워크 통신이 트랜잭션에 포함되면 해당 요청에 문제가 생겼을 때 DB 커넥션도 계속하여 반납되지 못해 DB까지 장애가 전파될 수 있으므로 주의해야 합니다.
(여기서 네트워크 호출은 메시지 큐를 사용하여 트랜잭션과 비동기 처리해야 한다는 내용이 나올 수 있겠다.)

### 트랜잭션 범위 안의 읽기와 범위 밖의 읽기의 차이는 무엇일까요?
REPETABLE READ 격리 수준 이상의 경우, 트랜잭션 범위 안의 읽기는 다른 트랜잭션에서 데이터를 변경하고 커밋해도, 이를 알아차리지 못한다는 차이가 있습니다.

### 리두 로그는 언제 사용할까요?
MySQL InnoDB 기준으로 설명드리겠습니다.
리두 로그는 DBMS가 비정상적으로 종료된 경우 데이터 정합성을 맞추기 위해 사용됩니다.
커밋됐는데 디스크에 반영되지 않은 변경사항의 경우 리두 로그로 정합성을 맞출 수 있고,
롤백됐는데 디스크에 반영되지 않은 경우, 리두 로그로 해당 사실을 확인하고, 언두 로그로 정합성을 맞출 수 있습니다.

### 낙관적 락과 비관적 락에 대해 설명해주세요.
낙관적 락의 경우 동시성 문제가 자주 발생하지 않을 것이라 가정합니다. 따라서 락을 사용기보단 버저닝을 통해 동시성 문제 발생 여부를 확인합니다. (플로우 추가 공부 필요)
비관적 락의 경우 동시성 문제가 자주 발생할 것이라 가정합니다. 따라서 S-Lock 또는 X-Lock을 사용해 동시성 문제를 원천 차단합니다.

### 공유 락과 배타 락의 차이는 무엇인가요?
S-Lock의 경우 어떤 트랜잭션이 레코드에 S-Lock을 획득했다면, 다른 트랜잭션에서는 같은 레코드를 읽기는 가능하지만 쓰기는 불가능합니다.
X-Lock의 경우 어떤 트랜잭션이 레코드에 X-Lock을 획득했다면, 다른 트랜잭션에서는 같은 레코드에 대해 읽기와 쓰기가 모두 불가능합니다.

### MySQL에서 갭 락에 대해 설명해주세요.
갭 락은 MySQL InnoDB 스토리지 엔진에서 사용하는 잠금 방식으로, 인덱스의 특정 범위에 대한 insert를 차단하기 위해 적용되는 락입니다.
MySQL에서는 락을 필요로 하는 SQL문을 실행할 때 스캔되는 모든 인덱스 레코드에 락을 겁니다.
하지만 SQL문 실행 시 인덱스의 레코드를 단 하나도 스캔하지 못한다면, MySQL은 팬텀리드를 방지하기 위해 갭 락을 걸게 됩니다.
갭 락은 인덱스를 기준으로 발생하므로, 해당 컬럼이 인덱스가 없는 경우 갭 락이 적용되지 않습니다.
(갭 락으로 S락도 가능하고 X락도 가능한 듯? S락을 걸어도 삽입이 불가능하니)
(갭 락을 획득하기 위한 쿼리가 정확히 뭐지? -> SELECT ... FOR UPDATE 또는 SELECT ... FOR SHARE)

### 꼬리질문1. 인덱스가 없는 경우 갭 락이 걸리지 않으면, 락이 어떤 식으로 걸리나요?
인덱스가 없으면 PK를 기준으로 전체 테이블 스캔이 발생하므로, 해당 테이블의 모든 레코드에 대한 레코드 락이 걸립니다.
따라서 다른 트랜잭션은 이미 존재하는 레코드에 대해 수정하려면 대기해야 하지만, 새로운 레코드 삽입은 가능합니다(?) -> 새로운 레코드 삽입 불가능한거 아닌가?

### 꼬리질문2. X락을 갭 락으로 획득했을 때 특징에 대해 알고 계신가요?
일반적으로 한 트랜잭션이 X락을 획득하면, 다른 트랜잭션은 X락을 획득할 수 없습니다.
하지만 X락임에도 불구하고 갭 락이라면, 여러 트랜잭션에서 이를 동시에 획득할 수 있습니다.
갭 락의 주목적은 데이터를 삽입하는 것을 방지하는 것이기 때문에, 갭 락은 insert가 되는 것만 막지, 같은 갭 락을 획득하는 것은 막지 않기 때문입니다.

### MySQL에서 supremum pseudo-record 락에 대해 설명해주세요.
InnoDB 인덱스에서 가장 큰 렉코드보다 큰 값이 삽입되지 않도록 막는 락입니다.
갭 락의 경우, 특정 레코드의 왼쪽 구간에 락을 거는데, 따라서 맨 마지막 구간에는 대응되는 오른쪽 레코드가 없기 때문에 supremum pseudo-record락을 사용합니다. 
테이블이 비어있는 상황에서 데드락 발생 원인! 갭락은 X락임에도 불구하고 여러 트랜잭션이 동시에 획득할 수 있다.

### MySQL에서 넥스트 키 락에 대해 설명해주세요.


### 데드락이란 무엇이며, 어떻게 발생할까요?
### Commit과 Rollback이란 무엇인가요?
### 데이터베이스 회복 기법에 대해 설명해주세요.

### 로그회복기법에 대해 설명해주세요.
### 검사시점회복기법에 대해 설명해주세요.
