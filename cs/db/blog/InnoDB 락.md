insert 작업에 대해 Unique 제약 조건 없이 락으로 해결할 수 있는지 학습해보자.

### MySQL 엔진
- SQL을 파싱하고 실행하는 역할
- 쿼리 최적화, 트랜잭션 관리, 캐싱, 사용자 인증 등을 수행
- 다양한 스토리지 엔진을 지원하며, 각 테이블에 사용할 스토리지 엔진을 선택 가능
- MySQL 엔진 레벨 락
  - MySQL 서버 자체에서 관리하는 락으로, 스토리지 엔진과 관계없이 MySQL이 제공
  - 글로벌 락
    - 전체 데이터베이스에 대한 읽기 잠금 설정 가능
    - 모든 테이블을 읽기 전용으로 만들고, 다른 쓰기 작업을 차단
    - 주로 백업을 수행할 때 사용
  - 테이블락
    - 특정 테이블을 읽기 또는 쓰기 전용으로 잠금 가능
    - MyISAM 같은 일부 스토리지 엔진에서는 트랜잭션을 지원하지 않기 때문에 테이블 단위 락을 기본적으로 사용
  - 네이밍 락
    - 사용자 정의 락을 설정 가능?

### 스토리지 엔진
- 데이터를 실제로 디스크나 메모리에 저장하고 관리하는 역할
- MySQL은 여러 가지 스토리지 엔진을 지원하며, 대표적으로 InnoDB, MyISAM, MEMORY 등이 있음
- 각 스토리지 엔진은 서로 다른 락 메커니즘과 트랜잭션 지원 여부를 가짐
- 스토리지 엔진 레벨 락
  - 레코드 락, 갭 락, 넥스트 키 락, 자동 증가 락

### 레코드 락
- 일반적으로 레코드 락은 테이블 레코드 자체를 잠그는 락
- MySQL에서의 레코드 락은 테이블의 레코드가 아닌 인덱스의 레코드를 잠근다는 점에서 중요한 차이가 있음
  - 여기서 락이 걸리는 인덱스는 클러스터 인덱스 및 세컨더리 인덱스 모두를 포함
- 인덱스를 통해 검색되는 모든 레코드에 잠금을 건다.
  - first_name='Georgi'인 사원이 253명이고 And 조건으로 last_name='Klassen'인 사원이 1명일 때, 아래 쿼리는 253건의 레코드를 모두 잠근다.
  - UPDATE employees SET hire_date=NOW() WHERE first_name='Georgi' AND last_name='Klassen';
  - last_name에도 인덱스가 걸려 있다면 어떻게 되지? 복합 인덱스가 아니면 의미없나?
- 만약 적당한 인덱스가 없다면 모든 테이블의 레코드에 락을 걸고, 테이블을 풀스캔 하면서 작업을 처리하게 된다.
  - MySQL의 InnoDB에서 인덱스 설계가 중요한 이유 또한 이것이다.
- 리마큐 책 보면서 좀 더 학습 필요

### 갭 락
- 레코드 자체가 아니라 레코드와 바로 인접한 레코드 사이의 간격만을 잠금으로써 레코드와 레코드 사이의 간격에 새로운 레코드가 생성되는 것을 제어
- 갭 락은 인덱스 범위 조건 중에서 실제 레코드를 제외하고, 데이터가 추가될 수 있는 범위에 걸린다.
  - 즉, 갭 락은 아직 존재하지는 않지만 지정된 범위에 해당하는 인덱스 테이블 공간을 대상으로 거는 잠금
  - 따라서 데이터의 유일성이 보장되는 PK 또는 유니크 인덱스에 의한 작업에서는 갭 락이 사용되지 않는다.(?)
  - 아... 그럼 미아 블로그에서 데이터가 아직 존재하지 않을 때 갭락 때문에 데드락이 걸린게 이 이유인가? 더 공부
- 예를 들어 SELECT * FROM member WHERE last_name LIKE "J%" FOR UPDATE;를 수행하면
  - 이미 J로 시작하는 인덱스에는 레코드 락이 걸리고, J가 들어갈 수 있는 범위에 갭락이 걸리는 듯. 이게 넥스트 키락?
  - Hong과 Jo 사이에 갭락이 걸리면, I로 시작하는 값도 추가가 불가능한 건가? 
- 갭 락은 Pantom Read를 방지하는데 도움이 된다.

### 넥스트 키 락
- 레코드 락과 갭 락을 합친 잠금으로, 갭 락은 단독으로 사용되기 보다는 넥스트 키 락의 일부로 함께 사용된다.
- 바이너리 로그에 기록되는 쿼리가 리플리카 서버에서 실행될 때 소스 서버에서 만들어낸 결과와 동일한 결과를 만들어내도록 보장하는 것이 주목적
  - 그런데 넥스트 키 락과 갭 락으로 인해 데드락이 발생하거나 다른 트랜잭션이 기다리는 일이 자주 발생한다.
  - 따라서 바이너리 로그 포맷을 ROW 형태로 바꿔서 넥스트 키 락이나 갭 락을 줄이는 것이 좋다.(?)

### 자동 증가 락
- AUTO_INCREMENT 컬럼은 여러 레코드가 동시에 INSERT 되더라도 중복되지 않고 순차적으로 증가하는 일련번호를 제공하기 위해 내부적으로 테이블 수준의 잠금인 자동 증가 락을 사용
- INSERT, REPLACE와 같이 새로운 레코드를 저장하는 쿼리에서만 사용
- 자동 증가 락은 테이블에 1개만 존재하기 때문에, 한 쿼리에서 락을 획득하여 채번중이라면 다음 쿼리는 락을 대기해야 함
  - 하지만 아주 짧은 순간만 걸렸다가 즉시 해제되므로 대부분의 경우 문제가 되지 않음
- 잠금을 최소화하기 위해 한 번 증가하면 절대 자동으로 줄어들지 않음
  - 자동 증가값 채번에 성공했지만 이후의 쿼리가 실패해 트랜잭션이 롤백되어도 자동 증가 값은 복구되지 않고 그대로 남는다. 

### 의도 락(Intention Lock)
- 의도 락은 테이블 락과 레코드 락이 공존할 수 있도록 만든다. 
