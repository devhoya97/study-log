### Distance vector 알고리즘
- x 입장에서 이웃한 노드는 v뿐일 때, y,w,z까지 가는 최단 경로를 알아야 한다면, v로부터 정보를 받아야 한다.
- 이 때 v가 x에게 넘겨주는 D_v(y), D_v(w), D_v(z) 정보들의 모음을 distance vector라고 부른다.
- 벨만포드 알고리즘이 그래프에서 최단 경로를 구하는 일반적인 방식이라면, Distance vector 알고리즘은 네트워크 라우팅에 특화된 변형 버전이다. (지피티)
- 식 -> D_x(y) = min_v{ c(x,v) + D_v(y) } 
  - x에서 y까지 가는 최소비용은, x와 연결된 모든 v에 대해 min(x-v link 비용 + v에서 y까지 가는 최소 비용) 이다.
  - 예를 들어 x가 y, z와 연결되어 있고 x에서 y까지 가는 최소 비용을 구한다면
    - min { (c(x,y) + D_y(y)), (c(x,z) + D_z(y)) }
    - D_y(y) 값은 당연히 0이지만, D_z(y)는 z로부터 리포트 받아야 구할 수 있다.
    - z입장에서도 D_z(y)를 곧바로 알아낼 수 없는 상황일 수 있다. 이 경우 재귀적으로 알아내야 한다.
    - 각 라우터가 가진 Distance Vector가 변경될 때마다, 본인과 연결된 인접 라우터들에게 변경된 값을 리포트 해줘야 한다.
    - 또는 local link cost가 변경된 경우에도 리포트 해줘야 한다.
    - 주변으로부터 변경된 Distance Vector를 리포트 받으면, 리포트 받은 라우터는 자신의 Distance Vector를 다시 업데이트 한다.
    - 업데이트 시 변경되는 내용이 있으면 또 다시 인접 라우터에게 이를 리포트한다. 없으면 리포트할 필요가 없다.
    - 결국 모두가 리포트하지 않는 안정된 상태에 들어가면 Distance Vector 계산이 끝난다.
- count to infinity
  - local link cost가 기존보다 커지면 발생
  - z 입장에서 D_z(x)가 y를 거쳐야 한다면, y에게는 D_z(x)를 리포트할 때 무한대로 리포트해야 한다.
