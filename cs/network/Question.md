# 전산 기본
### OSI 7계층에 대해서 설명해주세요.
### TCP/IP 4계층에 대해서 설명해주세요.
### DNS가 무엇인가요?
IP는 기억하기 어렵고, 변경될 여지가 있기 때문에 사용자가 IP를 직접 사용하기는 번거로운 점이 많습니다.
DNS는 사용자가 도메인만 기억하면, 이를 IP로 바꿔주는 작업을 수행해주는 서버입니다.

### www.naver.com에 접속할때 일어나는 일에 대해 설명해주세요.
클라이언트의 웹 브라우저가 네이버 서버에게 index.html을 HTTP로 요청하는 과정을 애플리케이션 레이어 레벨에서 설명해보겠습니다.
먼저 웹브라우저는 DNS 질의를 통해 도메인 주소를 IP 주소로 변환합니다.
이후 IP 주소와 포트번호로 TCP 소켓을 생성하고 연결을 위한 시스템콜을 호출하면, 서버측에서 클라이언트를 위한 소켓을 하나 할당합니다. 
이 때 TCP 연결이 이루어지는 구체적인 과정은 웹브라우저와 서버애플리케이션 입장에서는 신경쓸 요소가 아닙니다. 
이들의 입장에서는 application layer의 아랫단이 어떻게 동작하는 지는 이해할 필요가 없고, 추상화된 API를 제공받아 활용할 뿐이기 때문입니다.
소켓 연결이 완료되면, 웹브라우저는 소켓에 대고 미리 생성해둔 HTTP 메시지를 write() 하고 서버의 HTTP 응답메시지를 읽기 위해 소켓에 read()를 호출합니다.
서버애플리케이션도 마찬가지로 소켓에 read()를 호출해 HTTP 요청 메시지를 받으면, 톰캣과 같은 웹서버가 HTTP 요청을 파싱해 URL에 대응하는 서블릿을 호출합니다.
스프링애플리케이션이라면 DispatcherServlet이 호출될 것입니다. 여러 서버단 로직을 거쳐 톰캣은 HTTP 응답 메시지를 만들고
소켓에 대고 write()를 호출합니다. (명확하게는 소켓으로부터 얻어낸 InputStream, OutputStream을 이용)
그럼 클라이언트쪽 웹브라우저가 호출한 소켓의 read()가 드디어 응답하여 index.html을 HTTP response body로부터 받을 수 있게 됩니다.

<br> 
지피티가 보완한 버전 : HTTP 요청이라고 가정하고, 클라이언트의 웹 브라우저가 네이버 서버에게 index.html을 요청하는 과정을 애플리케이션 레벨에서 설명해보겠습니다.

먼저 웹브라우저는 로컬 DNS 캐시를 확인한 후, 캐시에 없으면 DNS 질의를 수행하여 도메인 주소를 IP 주소로 변환합니다.
이후, 웹브라우저는 변환된 IP 주소와 포트 번호를 사용하여 TCP 소켓을 생성하고 연결을 시도합니다.
이 과정에서 TCP 3-Way Handshake 및 HTTPS라면 TLS Handshake도 수행됩니다.

연결이 완료되면, 웹브라우저는 소켓에 대고 미리 생성한 HTTP 요청 메시지를 write() 합니다.
이때, OS 네트워크 스택을 거쳐 메시지가 전송되며, 서버에서는 대기 중인 데몬 스레드가 새로운 소켓을 할당하여 클라이언트와 통신할 준비를 합니다.

서버의 웹 서버(Tomcat과 같은)가 소켓을 통해 요청을 수신하면, HTTP 요청을 파싱하여 적절한 서블릿(또는 Spring 애플리케이션에서는 DispatcherServlet)을 호출합니다.
DispatcherServlet은 URL 매핑을 기반으로 적절한 컨트롤러 메서드를 실행하고, 필요한 서비스 로직을 수행한 후 HTTP 응답을 생성합니다.

서버는 응답 메시지를 다시 소켓을 통해 write()하며, 클라이언트 웹브라우저의 read() 호출이 응답하여 index.html을 전달받습니다.
이후, 브라우저는 HTML을 해석하고 추가적인 CSS, JS, 이미지 요청을 수행하며 페이지를 렌더링합니다.

### 도메인 이름으로 실제 IP를 어떻게 찾을 수 있는지 흐름을 설명해 주세요.
www.naver.com 을 검색하는 과정에서 호스트는 먼저 DNS 캐시 역할을 수행하는 로컬 DNS 서버에 질의하는데, 여기서 캐시미스가 난 상황을 가정해보겠습니다.
결국 naver.com 도메인을 관리하는 Sub Domain NS까지 가야만 해당 도메인에서 www라는 이름을 가진 컴퓨터의 IP 주소를 알 수 있는데,
계층 구조를 타고 찾아가야 합니다. 먼저 Root NS 서버에게 접근해 .com 도메인을 관리하는 TLD NS의 IP 주소를 찾아냅니다.
그리고 .com 도메인을 관리하는 TLD NS에게 접근해 naver.com 도메인을 관리하는 Sub Domain NS 서버의 IP 주소를 찾아냅니다.
그리고 naver.com 도메인을 관리하는 Sub Domain NS에게 접근해 도메인 내 www 이름을 가진 컴퓨터의 IP 주소를 반환받습니다.
위 복잡한 DNS 질의 과정은 로컬 DNS 서버가 수행해주고, 실제 호스트는 마치 로컬 DNS 서버가 IP를 바로 알아온 것과 다름없이 응답을 받습니다.

<br>
예를 들어 .com 도메인을 관리하는 DNS 서버에서 naver.com 도메인을 관리하는 authoritative DNS 서버의 도메인명을 굳이 NS타입으로 저장하는 이유가 뭘까? 
그냥 바로 A 타입으로 IP 주소를 맵핑해주면 되는거 아닌가?

### DNS가 UDP를 사용하는 이유를 설명해주세요.
DNS는 HTTP 메시지를 전달하기 위한 사전작업에 불과하므로 충분히 빨라야 하는데, 심지어 메시지의 크기도 굉장히 작습니다.
따라서 패킷이 유실될 가능성도 HTTP 메시지에 비해 희박하고, 유실되더라도 재요청 오버헤드가 비교적 작기 때문에 TCP가 아닌 UDP를 사용합니다.

### 꼬리질문. 메시지의 크기가 작을수록 패킷이 유실될 가능성도 작아지는 이유가 무엇인가요?
우선 패킷 사이즈가 MTU보다 크면 여러 개의 패킷으로 나뉘는데, DNS 패킷의 경우 MTU를 초과할 가능성이 매우 낮습니다.
또한 라우터를 거치면서 큐에 들어갈 때, 큐가 고정된 사이즈로 엔트리를 관리하지 않는다면, 하나의 패킷이더라도 큰 사이즈의 패킷보다 작은 사이즈의 패킷이 드랍될 가능성이 낮아질 것 같습니다.
마지막으로 데이터 전송 과정에서 bit error가 발생할 가능성도 작습니다.

### 유니캐스트, 멀티캐스트, 브로드캐스트란?

---
# TCP/UDP

### TCP가 필요한 이유가 무엇인가요?
IP 프로토콜의 비연결성, 비신뢰성, 프로그램 구분 불가라는 한계를 보충하기 위해서입니다.
비연결성이란 패킷을 받을 대상이 없거나 서비스 불능 상태여도 패킷을 전송하는 한계를 갖고,
비신뢰성이란 중간에 패킷이 사라지거나, 순서대로 오지 않을 경우에 대처하지 못한다는 한계를 갖습니다.
프로그램 구분 불가는 같은 IP를 사용하는 서버에서 통신하는 애플리케이션이 둘 이상이면 IP로는 구분할 수 없습니다.
TCP를 사용하면 위와 같은 문제를 모두 해결할 수 있습니다.

### TCP 프로토콜의 특징에 대해 설명해주세요.
연결지향, 데이터 전달 보증, 순서 보장이라는 특징이 있습니다.
첫 번째로 연결지향은 3 way handshake로 상대방과 연결이 됐는지 확인하여 대상이 존재하지 않거나 서비스 불능 상태인지 확인할 수 있습니다.
두 번째로 데이터 전달 보증은 상대가 메시지를 성공적으로 받으면 ACK를 응답함으로써 이뤄집니다.
마지막으로 순서 보장은 sequence number를 TCP헤더에 기입함으로써 수신자는 패킷을 순서대로 정렬할 수 있습니다.

### TCP와 UDP의 차이에 대해서 설명해 주세요.
TCP는 연결지향의 신뢰성 있는 프로토콜이기 때문에 연결을 맺고 끊기 위한 handshake 과정을 필요로 하고,
패킷의 순서가 잘못되거나 유실됐을 때 이를 재전송하는 매커니즘을 갖고 있습니다.
반면 UDP는 비연결지향이며 신뢰성을 보장하지 않는 프로토콜이기 때문에 패킷의 순서를 보장하지 않고 중간에 패킷이 유실되어도 책임지지 않습니다.
하지만 그만큼 패킷의 헤더의 크기가 작고, 속도가 빠르다는 이점이 있습니다.

### 3-way hand shake, 4-way hand shake 흐름에 대해서 설명해주세요.
TCP 연결을 위해 3-way handshake가 필요합니다. 먼저 클라이언트가 서버에게 SYN을 보내고, 서버는 이에 ACK와 함께 SYN을 보냅니다.
클라이언트는 이에 ACK를 보냄으로써 연결이 완료되고, 마지막 ACK와 함께 데이터도 보낼 수 있습니다.
TCP 연결종료를 위해 4-way handshake가 필요합니다. 먼저 클라이언트가 서버에게 FIN을 보내고, 서버는 ACK를 답하지만, 
이후 바로 FIN을 보내는 것이 아니라 일단 더 보내야할 데이터가 있으면 계속 보냅니다. 
서버가 모든 데이터 전송을 완료했으면 FIN을 보내고, 클라이언트는 이에 대해 ACK를 보냅니다.
이 때 주목할만한 점은 클라이언트가 ACK를 보내자마자 TCP 연결이 끊기는게 아니라, 어느정도 유휴시간을 둔다는 점입니다.
그 이유는 클라이언트가 보낸 ACK가 서버에게 가다가 유실될 경우, 서버가 다시 FIN을 보낼 가능성이 있기 때문입니다.

### 꼬리질문. 연결 수립을 위해 2-way handshake를 하면 안 될까요?
첫 번째로 서버 입장에서 연결을 수락했을 때, 해당 ACK를 클라이언트가 정말 받았는지 확인하기 위해서 SYN + ACK를 보내야 합니다.
두 번째로 서버가 사용할 sequence number를 공유하기 위해 SYN 과정이 필요합니다.

### TCP 헤더에 대해서 설명해 주세요.
TCP는 애플리케이션 계층으로부터 받은 메시지에 송수신측 포트번호를 포함한 각종 정보들을 덧붙이는데, 이 정보들을 TCP 헤더라고 합니다.
송신하는 입장에서 순서를 나타내기 위한 sequence number, 수신하는 입장에서 순서를 나타내기 위한 acknowledgement number,
SYN, ACK, FIN과 같은 각종 flag, 흐름제어를 위한 window size, 오류 검출을 위한 checksum 등이 있습니다.

### TCP 요청을 받는 서버와 UDP 요청을 받는 서버가 demultiplexing 과정에서 어떤 차이가 있나요?
TCP 서버의 경우, 예를 들어 ServerSocket이 80포트에 열려있다면, 클라이언트1과 클라이언트2가 connect를 요청했을 때
클라이언트마다 각각 다른 소켓을 할당하게 됩니다. 하지만 할당된 소켓이 모두 포트까지 할당받지는 않습니다.
따라서 연결 이후 클라이언트가 메시지를 보낼 때, 서버 입장에서는 src IP:port 값이 있어야 할당 받은 소켓으로 demultiplexing이 가능해집니다.
반면 UDP의 경우 connection 과정이 없기 때문에 모든 클라이언트의 요청을 하나의 데이터그램 소켓으로 전달합니다.
따라서 소켓을 결정하는 과정에서 src IP:port 값이 필요하지 않습니다.

### 꼬리질문. 같은 src IP:port로 TCP 요청이 여러 번 들어오면 어떻게 될까요?
서버 입장에서 (src IP:port, dest IP:port)라는 4 튜플을 기반으로 연결된 소켓을 찾아야 하므로
같은 튜플 값으로 연결을 요청한다면 이를 거절할 것 같습니다.

### MTU가 무엇인가요?
네트워크 장비마다 한 번에 보낼 수 있는 데이터의 최대 전송 단위가 각각 다릅니다. 
이를 MTU라고 부르며, 패킷의 크기가 MTU를 넘어가면 여러 개의 패킷으로 분할됩니다.
패킷이 분할되면, Identification, Flags, Fragment Offset 필드를 사용하여 패킷이 분할되었음을 알리고, 
이 필드들을 활용하면 분할된 패킷들을 올바르게 재조합할 수 있습니다.

### 꼬리질문. MTU와 관련된 IP 헤더가 각각 무엇을 의미하는지 설명해주세요.
하나의 패킷에서 여러 패킷으로 분할되면, 해당 패킷들은 모두 같은 Identification 값을 갖습니다.
또한 Fragment Offset을 통해 자신이 분할된 패킷 중 몇 번째인지 알림으로써 수신측에서 패킷들을 재조합할 수 있고,
Flags를 통해 자신이 분할된 패킷 중 마지막 패킷인지 아닌지 알림으로써, 분할되었던 패킷들이 모두 도착했는지 판단할 수 있습니다.

### Go-Back-N 방식과 Selective Repeat 방식의 차이점에 대해 설명해주세요.
Go-Back-N 방식은 window 사이즈만큼 패킷을 보내고 cumulative ack를 받을 때마다, 그만큼 윈도우를 오른쪽으로 이동시키는 방식입니다.
n번 패킷에서 타임아웃이 발생한다면, 해당 패킷을 포함한 윈도우 전체 데이터를 재전송해야 하므로, sender는 윈도우 패킷들을 버퍼에 저장해둬야 합니다.
Selective Repeat 방식은 sender 뿐만 아니라 receiver에 버퍼를 두어 순서에 맞게 들어오지 않은 패킷이더라도 버퍼에 저장합니다.
sender는 윈도우 내의 모든 패킷에 대해 타이머를 두고, 타임아웃이 발생한 패킷만 재전송합니다.
 
### 꼬리질문. window size가 n일 때, sequence number는 최소 몇이어야 중복 패킷을 검출할 수 있나요?
sequence number가 최소 2n이면 중복 패킷을 검출할 수 있습니다.
예를 들어 window size = 3이여서 receiver에서 0,1,2 번의 패킷을 모두 받고 ACK를 보냈는데, 모든 ACK가 분실될 경우
이 때 receiver는 sequence number가 0~5까지 있다면 3,4,5를 기다리고 있고 sender는 0,1,2를 재전송해도
receiver 입장에서는 이 패킷들이 중복전송됐다는 사실을 인지할 수 있습니다.
하지만 sequence number가 0~4까지만 있다면, receiver는 3,4,0을 기다리고 있을 것이고 sender가 보낸 0이 중복패킷이라는 사실을 알아챌 수 없습니다.

### 흐름제어에 대해 설명해주세요.
흐름 제어는 sender가 receiver 버퍼의 현재 상태를 고려해서 전송할 데이터의 양을 조절하는 방법입니다.
TCP 헤더에는 receive 버퍼 관련 필드가 있어서, sender 입장에서는 얼마나 보낼 수 있는지 명확하게 알 수 있습니다. 

### 혼잡제어에 대해 설명해주세요.
혼잡 제어는 sender가 네트워크의 혼잡 상황을 고려해서 전송할 데이터의 양을 조절하는 방법입니다.
처음에는 네트워크의 상황을 모르므로 slow start로 윈도우 사이즈를 1부터 시작하지만, 윈도우의 크기는 exponential하게 증가시킵니다.
이 때 threshold 지점에 도달하면, 그 때부터는 linear하게 윈도우 크기를 증가시킵니다.
네트워크가 막혔을 때, 3 duplicated ack 또는 time out이 발생하는데, 각각에 따라 sender의 대처가 달라집니다.
3 duplicated ack가 발생했다면, 특정 패킷 하나만 유실된 것으로 판단합니다. 
따라서 threshold 값을 패킷 유실이 감지된 지점의 1/2 값으로 변경하고, threshold 값부터 시작해 linear하게 윈도우 크기를 다시 증가시킵니다.
반면 time out이 발생하면 네트워크가 매우 혼잡해 전송한 모든 패킷이 유실된 것으로 판단합니다.
따라서 threshold 값을 패킷 유실이 감지된 지점의 1/2 값으로 변경하되, 1부터 다시 시작합니다.

### 오류제어에 대해 설명해주세요.

### TCP는 Go-Back-N 방식과 Selective Repeat 방식의 장점만 혼합해서 사용하는걸로 이해했는데, 만약 10번 패킷에 대해 3 dup ACK가 오면, 11, 12번 패킷은 잘 도착했더라도, 10번 패킷부터 다시 보내야되나?
아 10번 패킷만 다시 보내면, receiver에서 다음으로 받아야 하는 sequence number를 알려주니까, 그거 보고 다시 보내기 시작하는 듯

---
# IP

### IP란 무엇인가요?
네트워크상에서 송신자와 수신자를 유일하게 구별하기 위한 일종의 주소값입니다.
하지만 IPv4의 경우 32bit로 전세계의 모든 네트워크 인터페이스를 구분하는 것이 불가능하므로 
NAT의 도움을 받아 LAN과 LAN 사이에서는 중복된 IP를 사용할 수 있도록 translation 과정을 거칩니다. 

### 꼬리질문1. NAT에 대해 설명해주세요.
하나의 LAN 내에서 사용하는 사설 IP는 LAN내에서는 유일하지만, WAN에서는 유일하지 않는 문제를 해소하기 위해 LAN과 WAN을 연결해주는 작업을 NAT라고 합니다.
IPv4의 경우 32bit로는 40억개 정도의 네트워크 인터페이스밖에 유일하게 구별하지 못하므로, 전 세계의 IP 수요를 감당할 수 없습니다.
따라서 NAT 혼자서 공인 IP를 할당받고, LAN 내의 네트워크 인터페이스들은 사설 IP를 할당받습니다.
LAN에서 WAN으로 나가는 요청의 경우 NAT는 요청을 보낸 장치의 사설 IP 주소와 포트번호를 공인 IP 주소와 새로운 포트 번호로 매핑하여 내보내고,
WAN에서 LAN으로 들어오는 응답의 경우 공인 IP주소와 포트번호를 사설 IP 주소와 포트번호로 변환하여 LAN 내의 장치를 찾습니다.
이는 당장 IP 고갈 문제를 해결해주긴 하지만, 네트워크 계층에서 전송 계층의 포트번호를 사용한다는 점에서 완전한 해결책이라 보기는 어렵습니다.

### 꼬리질문2. 네트워크 계층에서 전송 계층의 포트 번호를 사용하면 어떤 문제가 있나요?
하나의 NAT에 속한 여러 장치가 동시에 웹 서버를 띄울 수 없습니다.
웹 서버는 일반적으로 80포트를 사용하도록 약속되어 있는데, WAN에서 NAT로 들어오는 요청이 NAT의 공인 IP 주소 + 80 포트라면,
NAT 입장에서는 이를 LAN에서 하나의 사설 IP + 포트 번호로만 맵핑해줄 수 있기 때문입니다.
이는 근본적으로 포트 번호를 용도에 맞게 사용하고 있지 않기 때문에 발생한 문제점이며 layer violation이 발생했다고 볼 수 있습니다.

### IPv4와 서브넷마스크에 대해 설명해주세요.
IPv4는 네트워크 인터페이스를 유일하게 구분하기 위한 32bit 값입니다.
32bit는 네트워크 ID와 호스트 ID로 나뉘고, 서브넷마스크가 네트워크 ID의 크기를 결정합니다.
예를 들어 127.0.0.1/24에서 127.0.0이 네트워크 ID이고 1이 호스트 ID이며, 이 서브넷에는 최대 256개의 호스트가 존재할 수 있습니다.

### 꼬리질문. 네트워크 ID는 왜 필요한건가요?
라우팅테이블에서 사용하는 엔트리의 수를 최소화하기 위해서입니다. 
라우터는 input link로 들어온 IP 패킷을 적절한 output link로 포워딩하기 위해 라우팅테이블을 사용합니다.
이 때 하나의 기관에서 사용하는 IP들이 네트워크 ID로 묶여있지 않고 중구난방의 값을 가진다면, 
호스트 하나당 라우팅테이블의 엔트리 하나가 필요하므로, 라우팅테이블 엔트리 크기가 과도하게 커집니다.
네트워크 ID로 이들을 묶어서 다루면 라우팅테이블 엔트리 수를 기하급수적으로 줄일 수 있습니다.

### Longest Prefix Match Forwarding에 대해 설명해주세요.
CIDR을 사용하면 특정 IP가 라우팅테이블의 여러 엔트리와 매핑될 수 있습니다.
이 때, 매핑된 여러 엔트리 중 왼쪽에서부터 카운팅해서 가장 길게 IP 값이 맵핑되는 엔트리를 선택하는 것이 Longest Prefix Match Forwarding입니다.

# HTTP
### HTTP에 대해 설명해주세요.
HTTP는 hyper text transfer protocol로 웹에서 하이퍼텍스트 및 다양한 리소스를 주고받기 위한 프로토콜입니다.
HTTP는 request, response 기반의 클라이언트 서버 모델을 사용하므로 클라이언트와 서버가 각각 진화할 수 있는 토대를 만들어주었습니다.
HTTP의 stateless 특성을 최대한 활용할수록 서버의 scale out에 유리해지고,
connnectionless 특성 덕분에 서버 입장에서 물리적으로 동시에 연결되는 클라이언트의 수를 최소화하여 동시 사용자 수를 최대한으로 받을 수 있습니다.
하지만 매번 TCP/IP 연결을 새로 맺어야 한다는 오버헤드가 있으므로, HTTP persistent connection으로 연결 시간을 어느정도 타협하고 있는 것으로 알고 있습니다.

### HTTP 메시지의 구조에 대해 설명해주세요.
요청 메시지와 응답 메시지 모두 start line, header, empty line, message body로 이루어져 있으며
start line에는 요청 메시지의 경우 HTTP method, 요청대상, HTTP 버전 정보가 들어가고
응답 메시지의 경우 HTTP 버전 정보, 상태코드, 상태 코드에 대한 짧은 설명 글이 들어갑니다.

### HTTP와 HTTPS 의 차이는 무엇인가요?
HTTPS는 HTTP를 기본적으로 사용하되 SSL을 함께 사용하는 방식입니다.
대칭키를 사용해서 HTTP 메시지를 암호화, 복호화하는 방식으로 이루어지는데, 클라이언트와 서버가 대칭키를 교환하는 과정은
서버가 가지고 있는 개인키와 공개키를 활용한 비대칭키 방식으로 이루어져 대칭키를 포함한 메시지가 탈취돼도
개인키를 가지고 있는 서버만이 이를 복호화할 수 있도록 함으로써 네트워크 과정에서의 보안을 안전하게 만들 수 있습니다.
(클라이언트가 대칭키를 생성하고, 서버의 공개키로 이를 암호화해서 서버에게 공유하는 방식인 듯)
또한 제3자인 CA의 도움을 받아서 서버는 CA의 개인키로 암호화된 인증서를 발급받게 되고, 클라이언트에게 인증서를 보내주면,
클라이언트는 CA의 공개키를 활용해 이를 복호화함으로써 서버가 CA의 인증을 받았다는 사실을 확인하고 안전한 서버임을 보장받을 수 있습니다.

### HTTP Method 종류 및 역할에 대해 설명해주세요.
GET은 리소스를 조회할 때 사용되고
POST는 리소스를 등록하거나 어떤 처리 작업이 필요할 때 사용되며
PUT은 리소스를 전체 대체하기 위해 사용되고
PATCH는 리소스를 부분 변경하기 위해 사용되며
DELETE는 리소스를 제거하기 위해 사용됩니다.

### HTTP 메서드의 멱등성에 대해 설명해주세요.
멱등이란 한 번 호출한 결과와 여러 번 호출한 결과가 같음을 뜻합니다.
예를 들어 서버가 time out 등으로 정상 응답을 못 주었을 때, 멱등성이 보장되어 있다면, 클라이언트는 같은 요청을 다시 할 수 있습니다. 
GET, PUT, DELETE는 멱등하지만 POST는 멱등하지 않습니다.
예를 들어 결제 요청을 POST로 여러 번 호출하면, 결제가 중복해서 발생할 수 있기 때문입니다.

### 재요청 중간에 다른 곳에서 리소스를 변경해버리면, GET 결과가 달라지니 멱등성이 없는 것 아닌가요?
멱등은 외부 요인으로 중간에 리소스가 변경되는 것까지는 고려하지 않습니다.

### HTTP 1.0과 1.1의 차이는 무엇인가요?
### HTTP2와 그 특징에 대해서 설명해 주세요.
### HTTP 헤더에 대해서 설명해 주세요.
HTTP 헤더란 HTTP 전송에 필요한 모든 부가정보로서,
메시지 바디의 크기, 인증을 위한 정보, 캐시 관리 정보, 쿠키 등이 들어갑니다.
클라이언트와 서버 간 약속만 되어 있다면, 임의의 헤더를 추가할 수도 있습니다.

### keep-alive 헤더에 대해서 설명해 주세요.
HTTP/1.1에서는 기본적으로 Persistent Connection(Keep-Alive)이 활성화되어 있어, 모든 요청마다 새 연결을 맺지는 않습니다 (보충 필요)

### HTTP GET과 POST의 차이는 무엇인가요?
### 쿠키와 세션에 대해서 설명해 주세요.

### PUT과 PATCH의 차이에 대해 설명해주세요.
PUT은 특정 자원의 모든 정보를 수정하기 위해 사용되고, PATCH는 특정 자원의 일부 정보만을 수정하기 위해 사용됩니다.

---
# 웹
### www.google.com에 접속할때 일어나는 일
### 웹브라우저에서 서버로 요청했을 때, 흐름을 설명해주세요.
### CORS란 무엇인가요?
### 웹 서버와 웹 어플리케이션 서버(WAS)의 차이는 무엇인가요?
### REST ful
### API Gateway란 무엇인가요?
### API Gateway가 다운되면 모든 API를 사용 못할지도 모르는데, 어떤 방안을 마련해야 할까요?

### API에 대해 설명해주세요.
애플리케이션 프로그래밍 인터페이스로서, 애플리케이션과 애플리케이션이 서로 소통할 수 있도록 도와주는 인터페이스입니다.
클라이언트 - 서버 모델을 기반으로 동작하며, 클라이언트 입장에서 API를 사용하면 특정 기능을 직접 구현하지 않고도 활용할 수 있습니다.

### REST API에 대해 설명해주세요.
API 개발자는 여러 아키텍쳐를 사용해 API를 설계할 수 있는데, 이 때 REST 아키텍쳐 스타일을 따르는 API를 REST API라고 합니다.
이 때 HTTP는 REST API의 필수 요소는 아니지만, REST API의 조건을 구현하기 용이하기 때문에 HTTP가 주로 사용됩니다.
HTTP에서 REST란 URI로 자원을 명시하고, HTTP Method를 통해 자원에 대한 행위를 표현하며, HTTP Message Pay Load를 통해 자원에 대한 행위의 내용을 표현합니다.
REST API에서는 메서드와 URI만으로도 어떤 요청인지 명확히 나타낼 수 있으므로 여러 개발자들이 협업할 때 효과적이여서 널리 사용되고 있습니다.
REST API의 특징으로는 서버 - 클라이언트 구조, stateless, cacheable, layered system, uniform interface가 있고
특히 stateless 특성 덕분에 서버의 scale out이 매우 편리해집니다.

---
# 웹소켓
### 웹소켓이란 무엇인가요?
웹소켓이란 클라이언트와 서버 간의 양방향 통신을 지원하는 프로토콜입니다.
HTTP의 요청-응답 방식과 달리 웹소켓은 한 번 연결을 맺으면, 연결이 유지된 상태에서 양방향으로 데이터를 주고 받을 수 있습니다.
일반적인 HTTP는 클라이언트가 요청을 보낼 때만 서버가 응답할 수 있지만, 웹소켓은 서버도 클라이언트에게 능동적으로 데이터를 전송할 수 있습니다.

### HTTP와 웹소켓의 차이점은 무엇인가요?
실시간 통신에서는 HTTP보다 웹소켓이 유리합니다.
HTTP는 connectless와 stateless 특성을 갖기 때문에, 실시간 통신을 위해서 매 통신마다 
3way handshake, 4way handshake가 필요함은 물론이고 수많은 헤더 정보를 보내야합니다.
하지만 웹소켓은 연결지향이기 때문에 한 번 연결을 맺고 나면 이후 재연결도 필요 없고, 
STOMP를 사용한다면 실시간 통신에 맞게 적은 양의 헤더 정보를 사용하므로 경제적입니다. 

### 웹소켓을 지원하지 않는 클라이언트라면 어떻게 대응할 수 있을까요?
웹소켓을 지원하지 않는 클라이언트의 경우, HTTP를 기반으로 실시간 통신을 구현하는 대체 방법을 사용할 수 있습니다.
대표적으로 streaming과 polling이 있으며, 스프링에서는 SockJS 라이브러리를 활용하여 자동으로 적절한 방식을 선택합니다.

### 꼬리질문1. HTTP의 streaming 방식에 대해 설명해주세요.
streaming은 서버가 클라이언트와의 연결을 유지한 채, 지속적으로 데이터를 푸시하는 방식입니다.
클라이언트가 한 번의 요청을 보내면, 서버는 새로운 데이터가 있을 때마다 주기적으로 응답을 전송합니다.
polling 기반의 방식보다 실시간성이 뛰어나며 불필요한 요청이 적지만, 연결을 지속적으로 유지해야 하므로, 서버의 동시 접속 처리 부담이 증가합니다.

### 꼬리질문2. HTTP의 polling 방식에 대해 설명해주세요.
polling은 클라이언트가 일정한 주기로 서버에 HTTP 요청을 보내 데이터를 가져오는 방식입니다.
응답으로 받을 메시지가 없음에도 불구하고 주기적으로 요청을 보낼 수 있어 불필요하게 서버 부하가 증가할 수 있습니다.
또한 응답으로 보낼 데이터가 생성돼도 곧바로 클라이언트에게 보내지는게 아니라 polling까지 기다려야 하므로 실시간성이 낮습니다.

### 꼬리질문3. polling의 단점을 보완한 다른 방법에 대해 알고 계신가요?
Long Polling은 Polling의 단점을 보완한 방식으로, 
클라이언트가 요청을 보내면, 서버는 즉시 응답하지 않고 새로운 데이터가 생길 때까지 기다렸다가 응답합니다.
따라서 실시간성이 polling보다 좋지만, 서버의 응답을 기다리는 동안 클라이언트는 다른 요청을 보낼 수 없다는 또다른 단점이 존재합니다.

### STOMP에 대해 설명해주세요.
Simple Text Oriented Messaging Protocol로, 웹소켓 위에서 동작하는 Pub-Sub 메시징 프로토콜입니다.
웹소켓은 기본적으로 클라이언트와 서버 간 일대일 통신을 지원하지만, STOMP는 메시지 브로커를 활요하여 일대다 또는 다대다 형태의 메시지 전송이 가능합니다.
대표적인 메시지 프로커로는 RabbitMQ, Kafka 등이 있습니다.
STOMP의 메시지는 프레임으로 이루어져 있으며, 하나의 프레임은 커맨드, 헤더, 바디로 구성됩니다.

### 꼬리질문1. 웹소켓을 사용할 때 STOMP를 얹어서 사용하는 이유가 무엇인가요?
웹소켓만 사용하면 단순한 일대일 통신만 가능하지만, STOMP를 사용하면 메시지 브로커를 활용한 일대다, 다대다 메시지 전송이 가능합니다.
또한 웹소켓을 직접 사용하면 메시지를 누가 받을지 직접 관리해야 하지만, 
STOMP를 사용하면 구독 기반 모델을 활용해 특정 채널을 구독한 사용자에게 자동으로 메시지를 전달할 수 있습니다. 
그 외에도 메시지 형식을 표준화하면 이를 처리하는 다양한 프레임워크가 발전하면서 개발자는 비즈니스 로직에만 집중할 수 있다는 장점이 생깁니다.

### 꼬리질문2. 메시지 브로커란 무엇인가요?
메시지 브로커란 발신자가 보낸 메시지를 수신자에게 안전하게 전달하는 중간 관리자 역할을 수행합니다.
메시지 브로커를 활용하면 메시지가 손실되지 않도록 큐에 메시지를 저장하므로 구독자에게 안정적으로 전달이 가능하고,
비동기 방식으로 데이터를 처리할 수 있어 시스템의 안정성과 확장성이 증가하며
발신자와 수신자가 서로를 몰라도 메시지 브로커가 중개역할을 수행하므로 발신자와 수신자간 결합도를 낮출 수 있습니다.
또한 웹소켓을 그대로 사용하는 것과 달리 Pub-Sub 방식으로 일대다 메시지 전달이 가능해집니다.

### 꼬리질문3. pub-sub 방식에 대해 설명해주세요.
발신자가 메시지를 발행하면 수신자가 그것을 수신하는 메시징 패러다임 ?


---

# 기타
### URI와 URL의 차이에 대해 알려주세요.
URI에는 URL과 URN이 있으므로 URL은 URI에 포함되는 개념입니다.
URI는 자원을 식별하는 방법으로 볼 수 있는데, 
그 중 URL이 자원의 위치로 자원을 식별하는 방법이며 URN은 자원의 이름으로 자원을 식별하는 방법입니다.
현재는 URN은 거의 사용되지 않고 URL이 주로 사용된다고 알고 있습니다.

### URL의 구성요소에 대해 설명해주세요.
프로토콜, 호스트명, 포트번호, 패스, 쿼리 파라미터가 들어갈 수 있습니다.
여기서 호스트명은 DNS를 통해 IP주소로 변경되며, 직접 IP주소를 기입하는 것도 가능합니다.
포트번호는 기입하지 않아도 프로토콜에 맞춰 디폴트로 들어갑니다.

### nagle 알고리즘에 대해 설명하세요.
### TLS에 패킷 프토토콜의 대해 설명하세요
### TLS
### 네트워크 Layer 라우팅 알고리즘
### SNI 필드 차단
### 흐름제어 / 혼잡제어 / 오류제어
### 로드 밸런서 / 로드 밸런싱은 무엇인지 설명하세요.
### WebRTC
