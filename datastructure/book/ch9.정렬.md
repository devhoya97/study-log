# 기본정렬

### 선택정렬
- 배열 A[0...n-1]에서 가장 큰 원소를 찾아 배열의 맨 끝자리 원소 A[n-1]과 자리를 바꾼다.
- A[0...n-2]를 대상으로 같은 작업을 반복한다.
- 수행 시간은 모든 경우에 O(n^2)이 된다.
  - (n-1) + (n-2) + ... + 1 

### 버블정렬
- 왼쪽부터 한 칸씩 이동하면서 이웃한 두 수를 비교해서 순서가 제대로 되어 있지 않으면 바꾼다.
- 선택정렬처럼 한 번의 for 루프마다 가장 큰 수를 맨 오른쪽으로 보내고, 정렬 대상을 한 칸씩 축소시킨다.
  - 시간복잡도는 O(n^2)으로 선택정렬과 동일하다.
  - 선택정렬은 한 번의 for 루프에서 비교 작업이 여러 번 이루어지지만, 두 수를 맞바꾸는 과정은 한 번만 이뤄진다.
  - 버블정렬은 한 번의 for 루프에서 비교 작업도 여러 번 이루어지고, 두 수를 맞바꾸는 과정도 여러 번 발생할 수 있으므로, 선택정렬보다 느리다.
- for 루프에서 원소 교환이 한 번도 일어나지 않는지를 체크하는 태그를 두면 대체로 더 빨리진다.
  - 선택정렬은 항상 O(n^2)이 필요하지만, 버블정렬은 태그를 두면 최선의 경우 O(n)이 된다는 장점이 있다.
  - 이미 대체로 정렬되어 있는 상태면 선택정렬보다 버블정렬이 낫겠구나.

### 삽입정렬
- 선택정렬과 버블정렬은 '정렬되지 않은' 배열의 크기를 n부터 시작하여 하나씩 '줄인다.'
- 반면 삽입정렬은 '정렬된 배열'의 크기를 1에서 시작하여 하니씩 '늘린다.'
  - 이미 정렬된 i개짜리 배열에 하나의 원소를 더하여 정렬된 i+1개짜리 배열을 만드는 과정이다.
- '정렬된 배열'에 끼어들어가는 수보다 큰 수들은 한 칸씩 오른쪽으로 밀린다.
- '정렬된 배열'의 크기가 i-1일 때, A[i]를 끼워넣는 경우,
  - 가장 운이 좋으면 A[i]가 제자리에 있게 되어 while 루프는 한 번도 수행되지 않는다. (비교 횟수는 1회)
  - 가장 운이 나쁘면 A[i]가 A[0] 자리에 들어가게 되어 i-1번의 순환이 필요하다. (비교 횟수는 i회)
  - 따라서 최악의 경우 수행 시간은 1+2+...+(n-1)
- 삽입정렬은 최악의 경우 O(n^2) 시간이 드는 비효율적인 정렬 알고리즘 군에 속하지만 배열이 거의 정렬된 상태로 입력된다면 가장 매력적인 알고리즘이 된다.
  - 배열이 완전히 정렬된 채로 입력된다면 while 루프는 한 번도 수행되지 않으므로(단 한 번의 원소 비교로 끝난다) for 루프를 한 번 순환할 때마다 상수 시간이 소요된다.
  - for 루프는 n-1번 순환되므로 총 O(n)의 시간이 든다.
  - 배열이 거의 정렬되어 있을 때도 A[i]의 삽입이 매우 수월해져 O(n)에 가까운 시간이 든다.
  - 이런 매력 때문에 많은 지능적인 프로그래머들이 다른 정렬을 사용하는 경우에도 상황에 따라 삽입 정렬을 섞어서 쓴다.

---

# 고급정렬

### 병합정렬
- 입력을 반으로 나눠 전반부와 후반부를 각각 독립적으로 정렬한다.
- 마지막으로 정렬된 두 부분을 병합하여 정렬된 배열을 얻는다.
- 위 작업을 재귀적으로 반복한다.
- 수행 시간은 최악, 평균, 최선의 모든 경우에 O(nlogn)이다.
- 이론적으로 완벽한 O(nlogn)을 보장하는 알고리즘이지만, 주어진 배열과 같은 크기의 tmp 배열이 추가로 필요하다.
- 또한 보조 배열 tmp로 병합했다가 다시 주어진 배열로 되써주는 과정에서 시간 낭비가 생긴다.
  -주어진 배열과 tmp 배열의 역할을 매번 바꾸면서 요령 있게 정렬하면 개선할 수 있다?

![스크린샷, 2025-03-06 오후 6.08.08.jpeg](..%2F..%2F..%2F..%2F..%2FDownloads%2F%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%2C%202025-03-06%20%EC%98%A4%ED%9B%84%206.08.08.jpeg)
![IMG_0710.jpg](..%2F..%2F..%2F..%2F..%2FDownloads%2FIMG_0710.jpg)


### 퀵 정렬
- 최악의 경우 O(n^2) 시간이 소요되지만, 평균 성능은 매우 빨라 실무에서 많이 사용된다.
- 병합정렬은 먼저 재귀적으로 작은 문제를 해결한 다음 후처리를 하는 데 반해, 퀵 정렬은 선행 작업을 한 다음 재귀적으로 작은 문제를 해결하면서 바로 끝난다.
  - 기준 값을 하나 정하고, 이를 기준으로 더 작은 값은 기준 값보다 왼쪽에, 더 크거나 같은 값은 기준 값보다 오른쪽에 배치한다. 
    - 더 작은 값(1구역), 더 큰 값(2구역), 아직 검사하지 않은 값(3구역), 기준값(4구역)으로 구역을 나눈다.
    - for 루프를 돌 때마다 j값은 항상 증가하므로 3구역이 한 칸씩 줄고, 1구역 또는 2구역이 한 칸씩 늘어난다.
    - 2구역이 늘어날 땐 j 값만 증가 외엔 아무 일도 할 필요가 없고, 1구역이 늘어날 때는 i값을 증가시키고, A[i]와 A[j]의 값을 맞바꾸고, j를 증가시킨다.
- 입력이 이미 정렬되어 있거나 거의 정렬되어 있는 경우 분할이 항상 최악의 경우를 만나므로 O(n^2) 시간복잡도가 걸린다.
  - 이런 경우를 굳이 방지하고 싶다면, 기준 원소를 잡을 때 맨 앞의 원소나 맨 뒤의 원소로 잡지 말고, 임의의 한 원소를 고르면 된다.
- 동일한 원소가 많이 존재해도 퀵 정렬의 성능이 좋지 않다.
  - 모든 원소가 동일하지 않더라도 중복이 무시하지 못할 정도로 있으면 그에 비례해서 성능이 떨어진다.
  - 분할 알고리즘에서 기준 원소와 동일한 원소를 만나면 양쪽에 골고루 나누어주도록 변경하면 개선할 수 있다.

![스크린샷, 2025-03-06 오후 6.43.00.jpeg](..%2F..%2F..%2F..%2F..%2FDownloads%2F%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%2C%202025-03-06%20%EC%98%A4%ED%9B%84%206.43.00.jpeg)
![스크린샷, 2025-03-06 오후 6.43.25.jpeg](..%2F..%2F..%2F..%2F..%2FDownloads%2F%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%2C%202025-03-06%20%EC%98%A4%ED%9B%84%206.43.25.jpeg)

### 힙 정렬


### 셸 정렬

---

# 특수정렬
### 계수정렬
### 기수정렬
### 버킷정렬
