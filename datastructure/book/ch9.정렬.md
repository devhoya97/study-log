# 기본정렬

### 선택정렬
- 배열 A[0...n-1]에서 가장 큰 원소를 찾아 배열의 맨 끝자리 원소 A[n-1]과 자리를 바꾼다.
- A[0...n-2]를 대상으로 같은 작업을 반복한다.
- 수행 시간은 모든 경우에 O(n^2)이 된다.
  - (n-1) + (n-2) + ... + 1 

### 버블정렬
- 왼쪽부터 한 칸씩 이동하면서 이웃한 두 수를 비교해서 순서가 제대로 되어 있지 않으면 바꾼다.
- 선택정렬처럼 한 번의 for 루프마다 가장 큰 수를 맨 오른쪽으로 보내고, 정렬 대상을 한 칸씩 축소시킨다.
  - 시간복잡도는 O(n^2)으로 선택정렬과 동일하다.
  - 선택정렬은 한 번의 for 루프에서 비교 작업이 여러 번 이루어지지만, 두 수를 맞바꾸는 과정은 한 번만 이뤄진다.
  - 버블정렬은 한 번의 for 루프에서 비교 작업도 여러 번 이루어지고, 두 수를 맞바꾸는 과정도 여러 번 발생할 수 있으므로, 선택정렬보다 느리다.
- for 루프에서 원소 교환이 한 번도 일어나지 않는지를 체크하는 태그를 두면 대체로 더 빨리진다.
  - 선택정렬은 항상 O(n^2)이 필요하지만, 버블정렬은 태그를 두면 최선의 경우 O(n)이 된다는 장점이 있다.
  - 이미 대체로 정렬되어 있는 상태면 선택정렬보다 버블정렬이 낫겠구나.

### 삽입정렬
- 선택정렬과 버블정렬은 '정렬되지 않은' 배열의 크기를 n부터 시작하여 하나씩 '줄인다.'
- 반면 삽입정렬은 '정렬된 배열'의 크기를 1에서 시작하여 하나씩 '늘린다.'
  - 이미 정렬된 i개짜리 배열에 하나의 원소를 더하여 정렬된 i+1개짜리 배열을 만드는 과정이다.
- '정렬된 배열'에 끼어들어가는 수보다 큰 수들은 한 칸씩 오른쪽으로 밀린다.
- '정렬된 배열'의 크기가 i-1일 때, A[i]를 끼워넣는 경우,
  - 가장 운이 좋으면 A[i]가 제자리에 있게 되어 while 루프는 한 번도 수행되지 않는다. (비교 횟수는 1회)
  - 가장 운이 나쁘면 A[i]가 A[0] 자리에 들어가게 되어 i-1번의 순환이 필요하다. (비교 횟수는 i회)
  - 따라서 최악의 경우 수행 시간은 1+2+...+(n-1)
- 삽입정렬은 최악의 경우 O(n^2) 시간이 드는 비효율적인 정렬 알고리즘 군에 속하지만 배열이 거의 정렬된 상태로 입력된다면 가장 매력적인 알고리즘이 된다.
  - 배열이 완전히 정렬된 채로 입력된다면 while 루프는 한 번도 수행되지 않으므로(단 한 번의 원소 비교로 끝난다) for 루프를 한 번 순환할 때마다 상수 시간이 소요된다.
  - for 루프는 n-1번 순환되므로 총 O(n)의 시간이 든다.
  - 배열이 거의 정렬되어 있을 때도 A[i]의 삽입이 매우 수월해져 O(n)에 가까운 시간이 든다.
  - 이런 매력 때문에 많은 지능적인 프로그래머들이 다른 정렬을 사용하는 경우에도 상황에 따라 삽입 정렬을 섞어서 쓴다.

---

# 고급정렬

### 병합정렬
- 입력을 반으로 나눠 전반부와 후반부를 각각 독립적으로 정렬한다.
- 마지막으로 정렬된 두 부분을 병합하여 정렬된 배열을 얻는다.
- 위 작업을 재귀적으로 반복한다.
- 수행 시간은 최악, 평균, 최선의 모든 경우에 O(nlogn)이다.
- 이론적으로 완벽한 O(nlogn)을 보장하는 알고리즘이지만, 주어진 배열과 같은 크기의 tmp 배열이 추가로 필요하다.
- 또한 보조 배열 tmp로 병합했다가 다시 주어진 배열로 되써주는 과정에서 시간 낭비가 생긴다.
  - 주어진 배열과 tmp 배열의 역할을 매번 바꾸면서 요령 있게 정렬하면 개선할 수 있다?

![스크린샷, 2025-03-06 오후 6.08.08.jpeg](..%2F..%2F..%2F..%2F..%2FDownloads%2F%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%2C%202025-03-06%20%EC%98%A4%ED%9B%84%206.08.08.jpeg)
![IMG_0710.jpg](..%2F..%2F..%2F..%2F..%2FDownloads%2FIMG_0710.jpg)


### 퀵 정렬
- 최악의 경우 O(n^2) 시간이 소요되지만, 평균 성능은 매우 빨라 실무에서 많이 사용된다.
- 병합정렬은 먼저 재귀적으로 작은 문제를 해결한 다음 후처리를 하는 데 반해, 퀵 정렬은 선행 작업을 한 다음 재귀적으로 작은 문제를 해결하면서 바로 끝난다.
  - 기준 값을 하나 정하고, 이를 기준으로 더 작은 값은 기준 값보다 왼쪽에, 더 크거나 같은 값은 기준 값보다 오른쪽에 배치한다. 
    - 더 작은 값(1구역), 더 큰 값(2구역), 아직 검사하지 않은 값(3구역), 기준값(4구역)으로 구역을 나눈다.
    - for 루프를 돌 때마다 j값은 항상 증가하므로 3구역이 한 칸씩 줄고, 1구역 또는 2구역이 한 칸씩 늘어난다.
    - 2구역이 늘어날 땐 j 값만 증가 외엔 아무 일도 할 필요가 없고, 1구역이 늘어날 때는 i값을 증가시키고, A[i]와 A[j]의 값을 맞바꾸고, j를 증가시킨다.
- 입력이 이미 정렬되어 있거나 거의 정렬되어 있는 경우 분할이 항상 최악의 경우를 만나므로 O(n^2) 시간복잡도가 걸린다.
  - 이런 경우를 굳이 방지하고 싶다면, 기준 원소를 잡을 때 맨 앞의 원소나 맨 뒤의 원소로 잡지 말고, 임의의 한 원소를 고르면 된다.
- 동일한 원소가 많이 존재해도 퀵 정렬의 성능이 좋지 않다.
  - 모든 원소가 동일하지 않더라도 중복이 무시하지 못할 정도로 있으면 그에 비례해서 성능이 떨어진다.
  - 분할 알고리즘에서 기준 원소와 동일한 원소를 만나면 양쪽에 골고루 나누어주도록 변경하면 개선할 수 있다.

![스크린샷, 2025-03-06 오후 6.43.00.jpeg](..%2F..%2F..%2F..%2F..%2FDownloads%2F%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%2C%202025-03-06%20%EC%98%A4%ED%9B%84%206.43.00.jpeg)
![스크린샷, 2025-03-06 오후 6.43.25.jpeg](..%2F..%2F..%2F..%2F..%2FDownloads%2F%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%2C%202025-03-06%20%EC%98%A4%ED%9B%84%206.43.25.jpeg)

### 힙 정렬
배열을 최대 힙으로 만들고, 힙의 루트를 삭제하는 작업을 힙의 크기만큼 반복하면 배열이 오름차순으로 정렬됩니다.
루트를 삭제할 때, 힙의 가장 마지막 원소를 루트에 복사하게 되는데, 이 때 루트 값을 힙의 가장 마지막 원소 자리에 넣어줍니다.
그 후 힙의 새로운 루트가 스며내리기를 완료하면, 가장 큰 원소가 배열의 맨 끝으로 이동한 상태에서 다시 힙 구조가 유지됩니다.
따라서 이 작업을 반복하면 결국엔 오름차순 배열이 완성됩니다.
스며내리기 작업을 n번 반복해야 하는데, 한 번의 스며내리기가 O(logn)의 시간복잡도를 가지므로, 
힙 정렬은 O(nlogn)의 시간복잡도를 갖습니다.
힙 정렬은 일반적으로 병합정렬보다 느리지만, 새로운 배열이 필요하지 않고,
모든 원소가 동일한 경우엔 모든 스며내리기가 O(1)로 끝나므로, 총 O(n)의 시간 복잡도가 소요됩니다.

### 셸 정렬
- 이미 정렬되어 있거나 '거의' 정렬되어 있으면 삽입정렬의 시간은 O(n)이 된다.
  - 끼워 넣는 비용이 거의 들지 않기 때문이다.
  - 끼워 넣는 비용이 많이 드는 경우는 끼워 넣는 새 원소가 자기 자리에서 멀리 앞쪽으로 가는 경우다.
- 셸 정렬은 마지막에 삽입정렬로 끝난다.
- 마지막 삽입정렬을 하기 전에 각 원소가 있어야 할 자리에서 멀리 떨어져 있을 가능성을 현저히 줄이는 작업을 한다.
  - 먼저 배열 전체를 h0 간격의 부분 배열들로 나눠서 h1개의 부분 배열 각각을 삽입정렬한다.
  - 그 다음 더 좁아진 간격인 h1로 만들어지는 h1개의 부분 배열 각각을 삽입정렬한다.
  - 이렇게 간격을 좁혀나가면서 삽입 정렬을 반복하다 마지막으로 간격 1이 되면 전체가 하나의 그룹이 된다.
  - 이 때 h0, h1, ... 을 갭 수열이라 한다.
- 셸 정렬의 수행 시간은 갭 수열에 따라 편차가 있어서 분석하기가 쉽지 않으나, 알려진 가장 좋은 상한은 O(n^1.25)다.

---

# 특수정렬
- 평균 또는 최악의 경우 O(n) 시간이 드는 정렬 알고리즘은 없을까?
  - 정렬을 하려면 모든 원소를 적어도 한 번씩은 보아야 하므로, 정렬 시간의 하한선은 O(n)이다.
- 두 원소 간 비교를 기본으로 하는 작업에서는 원소 비교 횟수가 최악의 경우 O(nlogn)이라는 사실이 증명되어 있다.
  - 이를 피하려면 '두 원소 간 비교'를 기본으로 하지 않아야 한다.
  - 예를 들어, 자신의 값으로 '분류'하면 된다.

### 계수정렬
- 배열 A[0...n-1]에 있는 원소들의 값이 0~2n, -n~3n 등의 범위에 있는 정수인 경우 사용할 수 있다.
- 예를 들어, 원소들의 값이 모두 0~k 사이의 정수일 때 계수 정렬은 먼저 배열에 있는 원소를 다 훑어서 1부터 k까지의 자연수가 각각 몇 번 나타나는지를 센다.
  - 이 정보가 있으면 배열 A[]의 각 원소가 몇 번째 자리에 놓이면 되는지를 계산할 수 있다.
  - 특정 원소보다 작거나 같은 원소의 총 갯수를 누적합으로 계산해서, 해당 원소가 뒤에서 몇번째에 위치할 수 있는지 알아낸다.
- 계수 정렬의 수행 시간은 O(n)이다.
  - 총 4개의 for 루프가 시간을 결정하는데, 2개의 for 루프는 O(k), 2개의 for 루프는 O(n) 시간이 소요된다.
  - k가 n을 초과하면 시간이 O(k)가 되므로 계수 정렬의 매력이 떨어진다.
![스크린샷, 2025-03-10 오후 11.28.13.jpeg](..%2F..%2F..%2F..%2F..%2FDownloads%2F%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%2C%202025-03-10%20%EC%98%A4%ED%9B%84%2011.28.13.jpeg)

### 기수정렬
- 원소들이 모두 상수 k개 이하의 자릿수를 가진 자연수와 같은 특수한 경우 사용할 수 있다.
![스크린샷, 2025-03-10 오후 11.35.18.jpeg](..%2F..%2F..%2F..%2F..%2FDownloads%2F%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%2C%202025-03-10%20%EC%98%A4%ED%9B%84%2011.35.18.jpeg)
- (1)에서 '정렬'하는 데 앞에서 배운 정렬 알고리즘 중 하나를 쓰면 그것만으로도 이미 O(n) 시간을 초과하므로 다른 방법을 사용해야 한다.
  - 예를 들어, 0부터 9까지 표시된 10개의 버킷을 준비해놓고 각각의 수를 가진 입력을 해당 공간에 차례대로 넣어준다든지 하는 간단한 방법을 써서 이 부분을 O(n) 시간에 끝내야 한다?
  - 이 부분을 O(n) 시간에 끝낼 수 있으면 알고리즘은 이런 일을 k번 반복하므로 시간은 O(kn)이 된다.
  - 이 때 k가 상수면 O(n)이 된다.
  - k가 상수가 아니라면 기수 정렬은 매력이 없다.

### 버킷정렬
- 정렬하고자 하는 원소들이 균등 분포할 때를 가정한 유용한 정렬 알고리즘
- 정규 분포가 가운데에 데이터가 가장 많이 몰리고 양쪽으로 가면서 수가 적어지는 종형 분포인 데 반해, 균등 분포는 데이터가 전 영역에 고루 존재하는 분포다.
  - 컴퓨터에서 랜덤으로 생성한 데이터는 전형적으로 균등 분포를 갖는다.
- 정렬할 원소들은 [a, b] 사이의 실숫값이면 된다.
  - 균등 분포이기만 하면 [a, b] 사이의 값들을 [0, 1] 범위의 실숫값으로 매핑할 수 있기 때문이다.
- 버킷 정렬은 먼저 n개의 리스트 배열을 준비한다.
  - 각각에는 평균 1개의 원소가 들어오는데, 확률적 편차에 따라 하나도 없을 수 있고, 여러 개가 있을 수도 있다.
  - 영역 [0, 1]을 n개의 동일한 윈도우 크기로 자르면 그 각각에 들어있는 원소들이 한 버킷(리스트)에 저장된다.
  - 총 n개의 원소가 총 n개의 버킷에 들어가므로 한 버킷에 들어가는 원소 수의 기대치는 1이다.
![스크린샷, 2025-03-10 오후 11.48.11.jpeg](..%2F..%2F..%2F..%2F..%2FDownloads%2F%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%2C%202025-03-10%20%EC%98%A4%ED%9B%84%2011.48.11.jpeg)
