# B-트리
### B-트리
- 앞서 배운 이진 검색 트리는 모두 메모리에 올려서 사용한다고 가정한다.
  - 이런 인덱스를 internal index라고 한다.
- 검색 트리의 분기 수를 늘리면 검색 트리의 기대 깊이를 낮출 수 있다.
  - 예를 들어 10억 개의 키를 관리하는 이진 검색 트리가 균형을 완벽하게 이루고 있다면 가장 이상적인 경우 트리의 깊이가 30정도 된다.
  - 한 노드에서 1000개의 분기가 가능하다면 가장 이상적인 경우 트리의 깊이가 4정도 된다.
  - 검색 트리의 각 노드가 디스크에 자유로이 흩어져 있다면 전자는 디스크에 최대 30번 접근해야 하고, 후자는 최대 4번이면 된다.
- 디스크에 있는 상태로 사용되는 검색 트리를 external search tree라 한다.
- 분기의 수가 2개를 넘으면 multi-way search tree라 한다.
- B-트리는 디스크 환경에서 사용하기에 적합한 external multi-way search tree이다.
- B-트리는 균형 다진 검색 트리로 다음 성질을 만족한다.
  - 노드의 크기가 k라면, 루트를 제외한 모든 노드는 [k/2]내림 ~ k개의 키를 갖는다.
  - 모든 리프 노드는 같은 깊이를 가진다.
- B-트리는 분기의 수를 가능하면 늘리되 노드의 활용도를 높이기 위해 각 노드가 채울 수 있는 최대 허용량에서 반 이상의 키를 채우도록 강요한다.
- 디스크의 한 블록이 4096 바이트, 키의 크기가 16바이트, 페이지 번호가 4바이트라면, 각 블록은 최대 170개의 키를 가질 수 있다.
  - (16 + 4 + 4) * 170 = 4080
  - 즉, B-트리의 한 노드가 최대 170개의 키를 가질 수 있다.
  - 이렇게 디스크 블록의 크기와 노드의 크기를 일치시키는 이유는 디스크에서 정보를 읽어올 때 블록(페이지) 단위로 읽어오기 때문에 최대한 효율을 높이기 위해서다.
  - 레코드의 위치를 나타내기 위해 페이지 번호에 추가로 레코드 위치까지 나타낼 수도 있겠지만 이를 위한 공간이 더 필요하기 때문에 감수할 만한 가치는 없다.
    - 차라리 페이지 하나를 통째로 메인 메모리로 가져온 후 그 안에서 해당 레코드를 찾아 처리한다. (이걸 DBMS가 해주는 듯)
  - 임의의 키가 검색키와 일치했을 때 해당 키를 가진 레코드에 접근할 수 있는 페이지 번호가 같이 있어야 한다는데, 이해 안 됨. 
    - 양 옆 페이지 중 하나로 편입하면 되는거 아닌가?
    - 아... 검색키와 동일한 키가 노드에서 발견되면 바로 데이터 페이지로 이동하면 되고, 발견하지 못하면 키와 키 사이의 데이터를 저장하는 페이지 번호를 보고 찾아가야하는구나.
    - 즉 검색키 양 옆의 페이지 번호는 인덱스 서브트리의 페이지 번호고, 검색키와 붙어있는 페이지 번호는 실제 데이터의 페이지 번호인 듯.

### B-트리 알고리즘. (1) 검색
- B-트리에서 키 x에 대한 검색은 기본적으로 이진 검색 트리의 검색과 같다.
- 이진 검색 트리에는 각 노드에 키가 하나밖에 없지만 B-트리는 최대 k개의 키를 가질 수 있다.
- 이진 검색 트리에서는 검색 키가 노드의 유일한 키와 일치하는지 확인하는 반면, B-트리에서는 노드의 여러 키 중 검색 키와 일치하는 것이 있는지 본다.
- 이진 검색 트리는 유일한 키와 비교하여 왼쪽 또는 오른쪽 분기를 정하는 반면, B-트리는 노드에서 key_(i-1) < x < key_i 인 두 키를 찾아 분기해야 할 자식 노드를 찾는다.
  - 자식으로 분기하고 나면 깊이만 하나 내려간 똑같은 검색 문제가 된다.
  - 이것은 이진 검색 트리에서처럼 재귀적이다.

### B-트리 알고리즘. (2) 삽입
- B-트리에서 키 x를 삽입하는 작업
  - x를 삽입할 리프 노드 r을 찾는다.
  - 노드 r에 공간의 여유가 있으면 키를 삽입하고 끝낸다.
  - 노드 r에 여유가 없으면 형제 노드에 공간의 여유가 있는지 살펴본다. 형제 노드에 공간의 여유가 있으면 키를 하나 넘기고 끝낸다.
    - 맨 오른쪽의 키를 형제 노드에 바로 넘기면 검색 트리의 성질이 깨지는 경우, 부모 노드에 있는 키를 형제 노드에게 옮기고, 원래 넘기려던 키는 부모 노드로 들어간다.
    - 이런 작업을 재분배(Redistribution)라 한다.
  - 형제 노드에 여유가 없으면 노드를 2개로 분리한다. 분리 작업은 부모 노드로 키를 하나 넘기는 작업을 포함한다.
    - 부모 노드에도 여유가 없으면, 부모 노드 기준으로 형제 노드가 여유 있는지 확인하고, 여유가 없다면, 부모 노드에서도 분리가 일어나야 한다.
    - 위와 같은 과정이 재귀적으로 발생한다.

### B-트리 알고리즘. (3) 삭제
- B-트리에서 키 x를 삭제하는 작업
  - x를 키로 갖고 있는 노드를 찾는다.
  - 이 노드가 리프 노드가 아니면 x의 직후 원소 y를 가진 리프 노드 r을 찾아 x와 y를 맞바꾼다.
    - 직후 원소 y는 반드시 리프 노드에 있다? 아 직후 원소가 없었으면 애초에 x가 리프 노드에 있었겠구나.
  - 리프 노드 r에서 x를 제거한다.
  - x를 제거한 후 노드에 언더플로우가 발생하면 적절히 해소한다.
    - 키를 가져올 수 있는 형제 노드를 보고, 그런 노드가 있으면 가져다 채운다.
      - 형제 노드의 원소를 가져다 채우면 검색 트리의 성질이 깨지는 경우, 부모 노드에 있는 키를 가져오고, 그 자리에는 원래 가져오려 했던 형제 노드의 키를 채운다.
      - 이런 작업을 재분배(Redistribution)라 한다.
    - 그렇지 않으면 형제 노드와 병합한다.
      - 병합은 두 노드를 하나로 합치는 것이므로 이들을 분기시켰던 부모 노드의 키가 필요 없어진다.
      - 이 필요 없는 키와 두 노드를 합쳐 하나의 노드로 만든다.
      - 병합의 결과 키가 하나 줄어든 부모 노드에서 언더플로우가 발생할 수 있다.
      - 앞에서 발생한 언더플로우와 성격은 같지만 발생 장소만 다르므로 재귀적으로 처리할 수 있다.

### B-트리의 작업 성능
- 이진 검색 트리는 균형을 아주 잘 맞추면 높이가 log_2n에 근접할 수 있다.
- 마찬가지로 d진 검색 트리가 균형을 아주 잘 맞추면 높이가 log_dn에 근접할 수 있다.
- B-트리에서 임의의 노드가 최대 d개의 자식을 가질 수 있다면(d-1 개의 키) 최소한 대략 d/2개의 자식을 가져야 한다. (루트만 예외)
  - 그러므로 B-트리의 깊이는 최악의 경우에도 대략 log_(d/2) n 보다 깊을 수는 없다.
  - 즉 높이는 O(logn)이다. (점근적 표현에서 log의 밑이 어떤 상수이건 상관없이 모두 동일하다.)
- B-트리의 작업 수행 시간은 디스크 접근 횟수를 기준으로 한다.
  - 노드를 메인 메모리에 가져온 다음 수행하는 작업에 소요되는 시간은 디스크 접근 시간에 비하면 무시할 수 있을 정도로 작기 때문에 여기서는 고려하지 않는다.
- B-트리의 검색 시간은 당연히 O(logn)이다.
- 삽입 작업은 일단 실패하는 검색을 한 번 수행하므로 O(logn) 시간이 든다.
  - 오버플로우가 발생하지 않으면 트리의 맨 아래에 원소 하나를 추가할 때 상수 시간이 든다.
  - 오버플로우가 반복적으로 발생해서 루트 노드까지 파급될 수도 있으므로 트리의 높이에 비례하는 시간이 들 수 있다.
    - 이 때에도 검색과 오버플로우 처리를 합하여 삽입 작업은 O(logn)시간이 든다.
- 삭제 작업은 삭제 원소 검색과 직후 원소를 찾는 작업에 O(logn) 시간이 든다.
  - 언더플로우가 발생하지 않으면 노드에서 단순히 키 하나를 제거할 때 상수 시간이 든다.
  - 언더플로우가 반복적으로 발생해서 루트 노드까지 파급될 수 있으므로 트리의 높이에 비례하는 시간이 들 수 있다.
- B-트리의 작업 시간은 모두 '점근적'으로는 O(logn)으로 통칭되지만 이진 검색 트리의 O(logn)에 비해 상수 인자가 상당히 작다.
