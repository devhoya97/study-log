### 우선순위 큐와 힙
- 우선순위 큐도 선형 자료구조를 이용해서 구현할 수 있지만 그보다 더 효율적인 방법이 있다.
- 우선순위를 효율적으로 다루는 대표적인 자료구조가 힙이다.

### 이진 트리
- 모든 노드가 2개 이하의 자식을 갖는 트리
- 힙은 이진 트리 구조 중에서도 완전 이진 트리라는 특수한 구조를 갖는다.

### 완전 이진 트리
- 노드 수가 맞지 않아 포화 이진 트리를 만들 수 없을 때 최대한 포화 이진트리에 가깝게 만든 것
  - 노드의 수가 2^k - 1개가 되지 않으면 맨 아래 레벨을 모두 채울 수가 없다.
  - 이 때 왼쪽부터 차례로 채운 것이 완전 이진 트리다.

### 힙은 다음의 두 가지 조건을 만족해야 한다.
1. 완전 이진 트리
2. 힙 특성: 모든 노드는 값을 갖고, 자식 노드(들) 값보다 크거나 같다.
- 힙 특성을 만족하면, 우선순위가 가장 큰 원소가 루트에 자리하게 된다. (최대 힙)
- 힙에는 동일한 값이 여러 개 저장되어도 상관 없다.

### 배열과 완전 이진 트리
- 배열은 기초적인 자료구조지만 완전 이진 트리를 표현하는 데는 안성맞춤이다.
- 배열이 A[0]부터 시작된다면 A[k]의 자식은 A[2k+1]과 A[2k+2]다.
- A[k]의 부모 노드는 A[소수점버림((k-1) / 2)]이다.
- 다만 배열은 힙 특성을 만족할 확률이 거의 없다.
- 배열이 힙 특성을 만족하도록 수선 작업이 필요하다.

# 힙 작업 알고리즘과 구현 (최대힙 기준)
### 원소 삽입
- 힙 A[0...n-1]에 새 원소가 들어오면 일단 맨 끝에 추가(A[n])한 다음 힙 특성을 만족하도록 올라가면서 수선한다.
- 삽입된 값이 부모 값보다 크다면, 둘을 맞바꾼다. (여기서 최대 logN번의 작업이 필요한가보다.)
  - 이를 스며오르기(Percolate Up)라 하고, 재귀적인 작업이다.

### 원소 삭제
- A[0]을 무작정 빼버리면 나머지 배열 A[1...n-1]은 A[1]을 루트로 하는 트리와 A[2]를 루트로 하는 트리로 끊어진 2개의 트리가 되므로 완전 이진 트리가 되지 못한다.
- 완전 이진 트리 모양을 깨지 않기 위해 맨 끝 원소 A[n-1]을 A[0] 자리로 옮기고 A[n-1]을 버린다.
- A[0]을 시작으로 스며내리기(Percolate Down) 작업을 재귀적으로 수행한다.
  - A[0]의 자식 노드 값들 중 큰 값이 A[0]보다 크다면, 둘을 맞바꾼다.
- 스며내리기를 시작하는 시점에 A[0]의 두 자식 A[1]과 A[2]를 루트로 하는 두 서브 트리는 이미 힙인 상태다.

### 힙 생성
- 임의의 배열을 힙으로 만드는 방법은 다음과 같다.
1. 맨 마지막 노드의 부모를 루트로 하는 서브 트리를 힙으로 수선한다.
2. 서브 트리의 루트가 되는 노드를 하나씩 앞으로 이동하면서 해당 서브 트리를 힙으로 수선하는 과정을 반복한다. 
   - 여기서 임의의 노드를 루트로 해서 수선하는 과정은 스며내리기를 한 번 하는 것이다. (스며내리기 한 번 당 최대 logN이니까 O(NlogN)일 듯? -> O(N)임...)
   - 수선 과정은 아래에서부터 차례로 루트를 바꿔가면서 수선해 올라가므로 어떤 노드를 루트로 삼아 스며내리기를 하는 시점에 이 노드의 자식들을 루트로 하는 서브트리들은 이미 힙으로 수선되어 있다.
   - 따라서 스며내리기 알고리즘의 전제 조건을 만족한다.
