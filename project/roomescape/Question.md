### 개발을 하면서 가장 힘들었던 순간이 언제인가요?
SpringBootTest에서 테스트 격리가 되지 않았을 때. -> 이거 어떻게 해결했더라?
DirtiesContext 쓰지 않고 격리하기 위해 schema.sql 쓰는 걸로 결론 내렸었나?

### OOP에 대해 설명해주세요.
객체지향 프로그래밍은 대규모 소프트웨어 개발에 필요한 프로그래밍 방법론입니다.
각 객체마다 적절한 역할과 책임을 부여하고 이들의 협력 관계를 잘 갖추는 것이 중요합니다.
OOP의 핵심 원칙으로는 캡슐화, 상속, 다형성, 추상화가 있으며 
스프링애플리케이션에서 3 layered 아키텍쳐를 사용하는 이유도 이와 같이 OOP를 지키기 위함입니다.
특히 비즈니스 로직을 수행하는 service 레이어를 중심으로 여러 도메인 객체에게 적절하게 책임을 부여하는 것이 핵심입니다.

### 꼬리질문1. 객체지향 프로그래밍의 장단점에 대해 설명해주세요.
장점으로는 객체를 잘 설계해놓으면 이를 여러 곳에서 활용하거나, 상속하여 기능을 추가할 수 있으므로 코드 재사용성이 좋습니다.
또한 객체마다 책임을 적절하게 부여하면, 기능 확장이나 변경사항이 생겼을 때, 특정 객체의 코드만을 변경하면 되므로 
유지보수 범위를 한정지을 수 있고, 이러한 장점 때문에 객체지향 프로그래밍은 대규모 소프트웨어 설계에 적합합니다.
단점으로는 절차지향 프로그래밍에 비해 객체마다 적절한 책임을 부여하며 설계하기 위해 많은 시간과 노력이 필요하다는 점과
객체를 생성하고 관리하는 과정에서 추가적인 메모리와 성능 비용이 발생한다는 점이 있습니다.

### 꼬리질문2. 캡슐화, 상속, 다형성, 추상화에 대해 각각 설명해주세요.
캡슐화는 객체의 수정이 일어났을 때, 영향 범위를 최소화하기 위한 방법이며, 필드를 private으로 지정하고
메서드 또한 내부적으로 사용하는 메서드는 private, 외부로 공개하는 메서드만 public으로 공개하는 방법입니다.
이를 통해 외부로 공개하는 메서드만이 API와 같이 공개된 정보가 되며, 그 외의 로직은 객체 내부적으로 변경되어도 다른 객체에는 영향이 전파되지 않습니다.
상속은 기존 클래스를 재사용해서 기능을 추가하거나 일부 변경하기 위한 방법으로, 적절하게 사용한다면 중복 코드 작성을 줄여 유지보수성을 높일 수 있습니다.
다형성은 인터페이스를 포함한 부모 클래스로 여러 자식 타입을 받음으로써 같은 메서드 시그니쳐를 호출해도 각자 오버라이딩한 기능을 수행하므로
추상화와 함께 사용했을 때 좋은 시너지를 낼 수 있습니다. 예를 들어 의존관계 주입도 다형성과 추상화를 활용한 방법입니다.

### 꼬리질문3. SOLID에 대해 설명해주세요.
S는 단일책임원칙으로 하나의 객체가 하나의 책임을 가져야 유지보수성을 높일 수 있다는 원칙입니다.
O는 개방폐쇄 원칙으로 확장에는 열려있지만 수정에는 닫혀있어야 한다는 원칙입니다. 
이와 관련해 D에 해당하는 의존관계 역전 원칙을 함께 설명드리면, 객체간 의존시 구현 클래스보다 추상클래스나 인터페이스에 의존하도록 함으로써
의존관계를 동적으로 주입해줄 수 있고, 이를 통해 개방폐쇄 원칙도 지킬 수 있게 됩니다.
L은 리스코프치환원칙으로, 서브 타입의 동작을 예상 가능하도록 정의함으로써 부모 타입으로 교체해도 동작이 의도대로 흘러가야 함을 의미하며
I는 인터페이스 분리 원칙으로, 여러 책임이 있다면 이를 하나의 인터페이스가 아닌 여러 개의 인터페이스로 나눠야 함을 의미합니다.

### TDD에 대해 설명해주세요.
테스트 주도 개발로서, 기능을 구체적으로 구현하기 전에 테스트 코드를 먼저 작성해서 기능을 정의하는 방법입니다.
Red Green Refactor의 반복적인 사이클을 따름으로써 스스로 작성한 코드에 대해 가장 빠른 피드백을 받을 수 있습니다.
또한 모든 단위 기능에 대해 자연스럽게 테스트가 작성된다는 장점이 있고,
구현 단계를 미리 생각하기보다 객체가 어떤 일을 수행해줘야 하는지 책임을 먼저 부여함으로써
큰 그림에서의 협력관계를 먼저 설계할 수 있다는 장점이 있습니다.

### 스프링의 장점에 대해 설명해주세요.
스프링은 다양한 기능이 있지만, 특히 서버 개발 시 객체지향 원칙을 쉽게 지킬 수 있도록 도와주는 프레임워크입니다.
그 중심으로는 스프링 컨테이너와 의존관계 주입이 있으며, 컨테이너에 등록된 빈들을 활용해 의존관계를 적절하게 연결해줌으로써
SOLID의 핵심인 OCP와 DIP를 쉽게 지킬 수 있도록 도와줍니다.
위와 같은 장점은 프로젝트의 규모가 커질수록 더욱 강점을 발휘한다고 생각합니다. 
반대로 소규모 프로젝트에서는 활용하는 객체의 수나 역할이 제한적이기에 객체를 여러 가지로 갈아끼워보는 경험을 하기 어려우므로
이 때는 위와 같은 장점보다는 개발자가 비즈니스 로직 작성에만 집중할 수 있도록 여러 기능을 제공한다는 점이 더 실전적인 장점으로 와닿았던 것 같습니다. 

### 프로젝트에서 스프링을 선택한 이유가 무엇인가요?
개발자가 비즈니스 로직 작성에만 집중할 수 있도록 큰 도움을 줬기 때문입니다.
스프링이니셜라이저를 사용하면 웹개발에 필요한 의존성을 쉽게 추가하면서, 프로젝트를 곧바로 생성할 수 있습니다. 
이후 스프링부트에 포함된 내장톰캣을 활용해 웹서버를 쉽게 구축할 수 있었고, 애노테이션 기반 컨트롤러만 만들어도
사실상 서버로서의 요청과 응답을 주고 받기 위한 기본적인 셋팅이 끝나기 때문에 매력적이라고 느꼈던 것 같습니다.
또한 DB 접근을 위해 JdbcTemplate을 제공한다거나, JPA의 도움을 받을 수 있다는 점에서도 매력을 느꼈고
덕분에 개발자는 비즈니스 로직을 작성하는 것에 집중할 수 있으므로 스프링을 선택했습니다.

### 스프링 부트에서 외부 API 테스트할 때 중요한 점을 설명해주세요.
아이러니하게 외부 서버에 직접 API를 쏘지 않는 것이 핵심인데요. 
그 이유는 외부 서버가 정상작동하는지는 우리 테스트의 테스트 범위를 넘어서기 때문입니다.
만약 CI/CD를 구축했는데 외부 서버의 장애로 인해 우리 테스트 코드가 깨진다면 배포가 원활하지 않게 됩니다.
또한 테스트를 위한 API를 제공받아야 하고, 테스트 코드를 실행할 때마다 해당 API를 매번 호출해야 한다면 테스트 속도에도 영향을 미칠 수 있게 됩니다.
따라서 자체적으로 API의 스펙에 맞게 요청과 응답을 정의한 목 서버가 필요하게 되는데요.
스프링이 제공하는 MockRestServiceServer를 활용하면 목 서버를 쉽게 정의할 수 있습니다.

### 꼬리질문1. 외부 API를 테스트할 때 어떤 것들을 테스트해야 하나요?
외부 API를 호출해서 받은 응답을 DTO로 변환하고 있다면, 목 서버가 API에 맞게 응답을 내려줬을 때, DTO 변환이 잘 일어나는지 확인해야 합니다.
이 때는 특히 필드명이나 타입변환과 같은 이유로 오류가 날 수 있으므로, 목 서버의 API를 정의할 때 실제 스펙과 완전히 동일하게 설정해주는 것이 중요합니다.
그리고 외부 API를 호출해서 4xx나 500과 같은 예외 응답을 받았다면, 이에 대해 의도한대로 대처하는지 테스트 해야 합니다. 

### 예약 취소 시 대기 1순번이 자동으로 예약으로 승격되는 기능에 대해 설명해주세요.
특정 시간에 특정 방에 대한 예약은 하나만 가능하지만, 대기는 여러 개 생성될 수 있습니다.
따라서 reservation_slot 테이블을 따로 마련해, 시간과 방번호에 대해 unique 제약 조건을 걸어주고,
예약을 생성할 때, slot을 먼저 생성하고, slot_id를 fk로 예약에서 들고 있게 됩니다.
예약 대기를 생성한다는 것은 이미 예약이 존재한다는 뜻이므로 slot 또한 존재한다는 사실을 내포합니다.
따라서 대기를 생성할 때도 이미 만들어진 slot_id를 fk로 들고있도록 생성하게 됩니다.
이 때 예약을 삭제하면 해당 slot_id에 대해 대기가 걸려있는지 확인합니다. 
테이블에 insert 된 순서대로 id값을 부여받았기 때문에 특정 slot_id를 가진 대기 중 가장 id가 빠른 대기를 찾아와서
status를 예약으로 변경해주면 대기 1순번이 예약으로 승격됩니다.

-> 테이블 구성을 이미 설명했다는 가정하에 좀 더 두괄식 버전
예약이든 대기든 slot_id를 fk로 들고 있게 됩니다. 따라서 예약이 삭제되면 해당 slot_id를 갖는 대기가 있는지 확인하고,
대기 중 id가 가장 빠른 row의 status 컬럼을 대기에서 예약으로 변경해주면 대기 1순번이 예약으로 승격됩니다.

### 동시 요청으로 인해 스레드 경합이 발생할 수 있다고 했는데, 스레드 경합이 왜 발생하는지 설명해주세요.
스레드 경합은 멀티 스레드 환경에서 하나의 공유 자원을 여러 개의 스레드가 점유하려고 시도할 때 발생합니다.
일반적으로 이미 DB에 insert된 row를 수정하거나 조회할 때는 로우락을 활용해서 동시성 문제를 해결하는데요.
예약 생성의 경우에는 존재하지 않는 row를 생성하는 것이기 때문에 로우락이 아닌 테이블락이 필요해지므로 부담스럽습니다.
그에 대한 대안으로 select exists 쿼리를 먼저 수행해 검증하고 insert 작업을 수행하도록 설계했는데, 이 경우에도
WAS가 멀티 스레드 환경이므로 경우에 따라 여러 개의 스레드가 거의 동시에 요청을 보내게 된다면, 
insert 작업을 수행하기 전에 여러 스레드가 select exists 쿼리를 수행해서 검증을 통과하게 되면 같은 슬롯에 대해 중복 예약이 발생할 수 있습니다.
따라서 시간과 방번호에 대해 unique 제약조건이 필수적이라고 생각했고, 이를 reservation_slot이라는 테이블로 분리하게 되었습니다.
-> repeatable read... 를 보장한다면... select 쿼리의 결과가 같아야 하니까... 어떻게 되는거지? 중복 예약은 그래도 발생하는거지?
-> MySQL InnoDB에서 REPEATABLE READ 이상의 격리 수준에서 갭 락을 활용하면 insert까지 방지할 수 있다는데, 이거 공부해보기

### 꼬리질문1. 동시성을 처리하기 위한 방법들이 무엇이 있는지 설명해주세요
대표적으로 자바에서는 객체마다 모니터를 활용해 락을 수행할 수 있습니다.
따라서 메서드에 synchronized 키워드를 사용하면 한 번에 하나의 스레드만이 메서드를 실행시킬 수 있어, 중복 예약 방지에 대한 해결책이 될 수 있으나
중복 예약이 아닌 경우에도 다른 스레드들이 메서드에 접근하지 못하도록 막게 되어 비효율적이라고 생각해 사용하지 않았습니다.

세마포어, 모니터, 락? 이거 구분이 아직 정확하게 안 됨. 운영체제 부분 다시 복습 필요.

### Unique 제약 조건에 대해 설명해주세요.
특정 컬럼의 값이 유일해야 하는 조건이며 대표적으로 PK에는 Unique 제약조건이 기본적으로 포함되어있습니다.
또는 여러 컬럼을 묶어서 하나의 Unique 제약 조건을 걸 수도 있습니다.

### 예약에 대기를 걸면 왜 Unique 제약 조건을 못 걸게 되나요?
대기가 없는 경우에는 특정 시간에 특정 방에 대한 예약은 단 한 명의 사용자만이 가능하므로, 특정 시간과 특정 방번호를 가진 row가 1개 뿐입니다.
하지만 대기가 생기고, status 컬럼으로 예약과 대기를 구분하게 되면, 같은 시간과 방번호를 가진 row가 여러 개 생성될 수 있으므로 
Unique 제약 조건을 해제해야 합니다.

### 예약과 대기를 함께 다뤄야 하는 요구사항이 정확히 무엇이었나요? 
내 예약 조회시 예약과 대기를 시간순으로 정렬하여 응답해야 하는 요구사항이 있었습니다.
당시 reservation과 waiting 테이블을 분리해서 구현했고, 두 테이블에서 특정 회원의 예약과 대기를 각각 가져와 애플리케이션 단에서 정렬을 수행했습니다.
이 때 현업에 계신 개발자 선배님이 코드리뷰를 해주셨는데, 이 API에 페이징 요구사항이 들어오면 어떻게 할 건지 고민해보라고 하셨고,
둘을 함께 페이징하려면, 매 조회시마다 대용량의 join이 필요하다는 것을 알게 되었습니다.
따라서 예약과 대기를 reservation 테이블에서 한 번에 관리하는 방법을 고민했고, 그 결과 reservation_slot 테이블을 만들게 되었습니다.
실제로 두 방법의 쿼리 성능을 비교해보니, 100만건의 테스트 데이터가 있는 환경에서 쿼리 성능이 40배 이상 차이나는 것을 확인할 수 있었습니다.

### 1번 방법에 첨부된 쿼리가 어떻게 동작하는지 설명해주세요.
특정 회원의 모든 예약과 대기를 함께 조회하되, 날짜 순으로 정렬해 1페이지에 10개, 2페이지에 10개와 같이 페이징이 필요한 상황을 가정해 쿼리를 작성했습니다.
이 때 페이징을 위해선 join이 필수적입니다. 예를 들어 각 테이블별로 데이터를 가져온 뒤 날짜순으로 정렬하여 10번~19번에 대한 데이터를 페이징을 하려면, 
매번 모든 데이터를 가져와서 날짜순으로 정렬해봐야 하기 때문에 페이징을 하는 의미가 사라지기 때문입니다.  
waiting 테이블은 reservation_id를 fk로 갖고 있으므로 이를 활용해 join을 수행합니다.
이 때 ON절에서 waiting 테이블의 member_id로 join 데이터를 줄일 수 있지만, reservation 테이블에서는 줄일 수 없습니다.
왜냐하면 다른 회원의 예약일지라도, 우리가 찾는 2번 회원의 대기가 걸려있을 수 있으므로, reservation에 대해 left join이 필요하기 때문입니다.
join 후 2번 회원의 예약이거나, 2번 회원의 대기인 것들만 남긴 후 정렬하여 페이징을 수행할 수 있습니다.
waiting 테이블을 join할 때 ON 절에서 2번 회원의 데이터만 남겼으므로, 2번 회원의 대기가 없는 예약의 경우, w.id가 NULL로 표기됩니다.

### 테이블이 추가되면 어떤 단점이 있나요?
테이블이 추가될수록 관리지점이 늘어나고, 테이블 간 관계가 늘어나면서 시스템 구조가 복잡해질 수 있습니다.
또한 join이 발생할 여지가 많아져 성능이 저하될 수 있습니다.

### 2번 방법에서, 예약 성공 여부를 곧바로 판단하여 응답할 수 없는 이유를 자세히 설명해주세요.
스레드 1이 먼저 트랜잭션을 시작해 id = 1 값을 획득했고, 스레드 2가 이후 트랜잭션을 시작해 id = 2 값을 획득했지만,
스레드 2의 트랜잭션이 먼저 커밋된 상황을 가정해보겠습니다. 이 때 트랜잭션의 커밋 여부에 상관없이 스레드 1은 예약에 성공한 것이고, 스레드 2는 대기에 성공한 것입니다.
스레드 2가 API에 대한 응답으로 예약에 성공했는지, 대기에 성공했는지 판단하려면 같은 시간, 방번호에 대해 자신보다 id가 빠른 예약이 존재하는지 확인하는 쿼리를 수행해야 하는데,
그 때까지도 스레드 1의 트랜잭션이 커밋되지 않았다면, 자신이 예약에 성공했다고 착각할 수 있습니다.
위와 같은 경우는 흔치 않겠지만, 오류 없이 안정적인 서비스를 생각한다면, 예약을 생성할 때마다, 내가 정말 예약에 성공한 것인지 해당 API로는 
확인할 수 없다는 문제가 있다고 생각했습니다.

### 2번 방법에서 예약들만 가져오는 쿼리를 어떻게 짤 수 있을까요?
날짜와 방번호로 데이터를 추리고, id로 정렬했을 때 가장 순서가 빠른 row가 예약이고, 그 외의 row들이 대기입니다.
-> 특정 날짜에 모든 예약들을 가져오는 쿼리를 짜라고 하면 어떻게 할지 잘 생각이 안 남

### 트랜잭션이란 무엇인가요?
데이터베이스의 상태를 변경시키는 작업의 단위를 뜻하고, ACID라는 4가지 특징을 갖고 있습니다. 

### @Transcational에 대해 설명해주세요.
스프링에서 트랜잭션을 관리하는데 도움을 주기 위해 제공하는 애노테이션으로, AOP 기술을 기반으로 동작합니다.
트랜잭셔널 애노테이션이 달린 메서드를 호출하면, 해당 메서드가 직접 호출되는게 아닌 프록시의 메서드가 호출되며
프록시 메서드는 트랜잭션을 시작하고, 타겟 메서드를 실행시킨 후, 트랜잭션을 종료하게 됩니다.
트랜잭셔널 애노테이션이 없다면, 서비스 단에서 트랜잭션을 관리하기 위한 로직이 비즈니스 로직에 섞이게 되어 유지보수성이 나빠집니다.

### AOP에 대해 설명해주세요
관점지향 프로그래밍은 횡단 관심사를 비즈니스 로직에서 분리해 모듈성을 증가시키는 프로그래밍 기법입니다.
주로 트랜잭션 관리나 로깅과 같이 여러 로직에서 필요로 하지만, 모듈로 분리하여 재사용성을 높일 수 있는 기능에 적용하면 효과적입니다.
Aspect는 공통 기능을 모듈화한 객체이고, Advice는 Join Point에서 실행되는 부가기능 그 자체이며,
Join Point는 Advice가 적용될 수 있는 지점이고, Point cut은 Join Point의 부분집합으로 실제 Advice가 적용되는 부분입니다.
스프링 AOP에서는 프록시 방식을 사용하므로 Join Point는 항상 메소드 실행 지점으로 제한됩니다.
