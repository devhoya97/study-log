### 생산자 소비자 문제 - synchronized 활용 버전
- 버퍼가 꽉 찼을 때 생산자가 생산을 시도하려 한다면, 데이터를 어떻게 해야 안 버릴 수 있을까? 에 대한 고민이 필요하다.
- 버퍼가 비어있을 때 소비자가 소비를 시도하려 한다면, 어떻게 해야 데이터가 생산될 때까지 기다릴 수 있을까? 에 대한 고민이 필요하다.
- 버퍼의 put은 생산자를 위한 메서드고, take는 소비자를 위한 메서드다.
  - 이 때, put과 take에 모두 synchronized를 적용한다면, 생산자와 소비자가 같은 모니터 락을 사용하게 된다.
  - 따라서 생산자가 sleep으로 모니터 락을 쥐고 소비자의 소비를 기다려봤자, 소비자는 모니터 락을 획득하지 못해 소비를 할 수 없다. (반대도 마찬가지)
- 아무 일도 하지 않고 대기하는 동안, Object.wait(), Object.notify()를 활용해 잠시 다른 스레드에게 락을 양보해야 한다.
  - 주의! notify()를 호출하면 WAITING -> BLOCKED로 상태가 바뀐다. 깨워준 스레드가 아직 synchronized에서 나가지 않았을 수 있다.
  - 다만, 생산자와 소비자가 같은 공간(객체마다 존재하는 wait set)에서 대기하므로, notify()를 호출할 때 생산자와 소비자 중 지정해서 깨울 수가 없다.
  - 따라서 소비자1이 소비를 완료하고, 애꿎은 소비자2를 깨울 수 있다. (반대도 마찬가지)
  - 물론 로직상 문제는 없지만, 소비자2는 괜히 일어났다가 다시 자러 들어가야 하는 비효율이 발생한다.
  - 즉, 서로 같은 종류의 스레드를 깨울 때 비효율이 발생한다.
  - 또한 notify()로 어떤 스레드가 깨어날 지 알 수 없기 때문에 스레드 기아 문제가 발생할 수 있다.
    - notifyAll()을 사용해서 스레드 기아 문제는 막을 수 있지만, 비효율을 막지는 못한다.

### Object.wait()
- 현재 스레드가 가진 락을 반납하고 WAITING 상태로 들어간다.
  - 이 때 스레드가 대기하는 집합은 락을 획득하기 위해 BLOCKED 스레드가 대기하는 집합과 별개다.
  - 즉 자바의 모든 객체 인스턴스는 멀티 스레드와 임계 영역을 다루기 위해 내부에 모니터 락, 락 대기 집합, 스레드 대기 집합을 각각 갖게 된다.
- 현재 스레드가 synchronized 블록이나 메서드에서 락을 소유하고 있을 때에만 호출할 수 있다.
- 대기 상태로 전환된 스레드는 다른 스레드가 notify() 또는 notifyAll()을 호출할 때까지 대기 상태를 유지한다.
  - WAITING 상태니까 인터럽트를 걸어서 깨울 수는 없나? -> InterruptedException과 함께 깨울 수 있는 듯. notify()는 예외없이 깨우는거고

### Object.notify(), Object.notifyAll()
- 대기 중인 스레드 중 하나 또는 모두를 깨운다.
  - 스레드 대기 집합에서 탈출한 스레드는 BLOCKED 스레드 대기 집합으로 이동한다.
  - Object.notify()를 호출한 스레드가 락을 반납하면, 그제서야 BLOCKED 스레드 대기 집합에서 대기하던 스레드가 락을 획득하며 RUNNABLE 상태가 된다.
- 이 메서드는 synchronized 블록이나 메서드에서 호출되어야 한다.
- 깨운 스레드는 락을 다시 획득할 기회를 얻게 된다.

### 생산자 소비자 문제 - ReentrantLock 활용 버전
- ReentrantLock은 하나만 사용하되, 생산자가 대기하는 Condition과 소비자가 대기하는 Condition을 나눈다.
  - Object.wait() 때문에 대기하던 스레드 대기 집합과 Condition은 서로 다른 대기 공간이다.
  - signal()에 의해 Condition에서 빠져나온 스레드는 락(모니터락 아님) 획득을 바로 시도하는게 아니라 락 대기 집합으로 우선 이동하며 WAITING 상태를 유지.
  - 락이 사용 가능하면 락 대기 집합에 있던 스레드 중 하나가 락을 획득하고 RUNNABLE로 바뀌는 과정은 자동으로 되도록 ReentrantLock에 구현되어 있다.
- 사용하는 메서드
  - reentrantLock.newCondition()
  - reentrantLock.lock()
  - condition.await()
  - condition.signal()

### java.util.concurrent.BlockingQueue
- 자바에서 생산자 소비자 문제를 해결하기 위해 제공하는 인터페이스
- 구현체로는 ArrayBlockingQueue, LinkedBlockingQueue가 있다.
- 추가, 제거, 관찰 행위에 대해 대기 시 예외, 대기 시 즉시 반환, 대기, 시간 대기와 같은 상황에 맞는 다양한 메서드를 제공한다.
  - 참고) 관찰의 경우 대기, 시간 대기 메서드는 제공하지 않는다.
