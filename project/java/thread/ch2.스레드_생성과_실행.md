### 자바 메모리 구조
- 메서드 영역
  - 코드 영역 + 데이터 영역으로 볼 수 있다.
  - 프로그램을 실행하는데 필요한 공동 데이터를 관리
- 스택 영역
  - 각 스레드별로 하나의 실행 스택이 생성
  - 메서드를 호출할 때마다 하나의 스택 프레임이 쌓이고, 메서드가 종료되면 해당 스택 프레임이 제거됨
  - 각 스택 프레임은 지역 변수, 중간 연산 결과, 메서드 호출 정보 등을 포함
- 힙 영역
  - 객체와 배열이 생성되는 영역
  - 가비지 컬렉션이 이루어지는 주요 영역이며, 더 이상 참조되지 않는 객체는 GC에 의해 제거됨

### 스레드 생성 (1) Thread 상속
- 자바가 예외를 객체로 다루듯이 스레드도 객체로 다룬다.
  - 스레드가 필요하면 스레드 객체를 생성해서 사용하면 된다.
- Thread 클래스를 상속하고, 스레드가 실행할 코드를 run() 메서드에 재정의한다.
- 메인 스레드는 메인 메서드를 실행시키면, 자바가 직접 만들어주는 특별한 스레드
- 스레드 객체를 생성해서 start()를 호출하면, 메인 스레드가 비동기적으로 메서드를 호출해준다.
  - 정확히는 JVM이 운영체제의 API를 호출하며, 운영체제가 직접 네이티브 스레드를 생성한다. (GPT)
  - 자바는 새로운 스레드를 위한 별도의 스택 공간을 할당하고, run() 메서드의 스택 프레임이 최초로 들어간다.
  - 이제 run() 메서드를 실행하는 건 메인 스레드가 아닌 새롭게 만들어진 스레드
  - 새로운 스레드의 run() 메서드와 메인 스레드의 다음 코드 중 어느 것이 먼저 CPU를 점유할 지는 매번 달라질 수 있다.

### 스레드 생성 (2) Runnable 인터페이스 구현
- Runnable 인터페이스에는 run() 메서드가 정의되어 있음
  - 이를 구현한 클래스를 만들고, Thread 클래스의 생성자에 넣어주면 된다.
- 스레드를 사용할 때는 Thread를 상속 받는 방법보다 Runnable 인터페이스를 구현하는 방식을 사용하자.
  - Thread 클래스를 상속하는 방법은 다른 클래스를 상속할 수 없지만, Runnable 인터페이스를 구현하는 방법은 다른 클래스를 상속할 수 있다.
  - 스레드와 실행할 작업을 분리하여 코드의 가독성을 높일 수 있다.
  - 여러 스레드가 동일한 Runnable 객체를 공유할 수 있어 자원 관리를 효율적으로 할 수 있다.
  - Thread 클래스의 생성자에 매개변수로, 람다식을 활용해서 간편하게 넘겨줄 수도 있다.

### user 스레드와 데몬 스레드
- user 스레드
  - 프로그램의 주요 작업을 수행
  - 작업이 완료될 때까지 실행되며, 모든 user 스레드가 종료되면 JVM도 종료됨
  - setDaemon(true)를 호출하지 않는 이상 우리가 직접 생성해서 사용하는 스레드는 모두 user 스레드인 듯
- 데몬 스레드
  - 백그라운드에서 보조적인 작업을 수행
  - 모든 user 스레드가 종료되면 데몬 스레드는 자동으로 종료
  - 스프링애플리케이션에서 데몬 스레드의 예시는 뭐가 있지?
