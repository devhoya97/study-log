### 메모리 가시성
- 현대의 CPU 대부분은 코어 단위로 캐시 메모리를 각각 보유하고 있다.
  - 참고로 여러 코어가 공유하는 캐시 메모리도 있음
- 캐시 메모리를 메인 메모리에 반영하거나, 메인 메모리의 반영 내역을 캐시 메모리에 다시 불러오는 것은 언제 발생할 지 알 수 없다.
  - 주로 컨텍스트 스위칭이 될 때, 캐시 메모리가 함께 갱신되지만, 무조건은 아니다?
- 멀티스레드 환경에서 한 스레드가 변경한 값이 다른 스레드에서 언제 보이는지에 대한 문제를 메모리 가시성이라 한다.
- volatile 키워드를 사용하면, 값을 읽거나 쓸 때 항상 메인 메모리에 접근하게 된다.
  - 성능을 약간 포기하는 대신에, 여러 스레드에서 같은 시점에 정확히 같은 데이터를 보게 된다.
  - 캐시 메모리를 사용할 때보다 성능이 느려지는 단점이 있기 때문에 꼭 필요한 곳에만 사용하자.
- 단일 프로세서 환경에서도 컴파일러 최적화와 CPU 캐시 때문에 메모리 가시성 문제가 생길 수 있어서, volatile 키워드는 여전히 필요하다. (gpt)

### 자바 메모리 모델(JMM)
- 자바 프로그램이 어떻게 메모리에 접근하고 수정할 수 있는지를 규정
- 핵심은 여러 스레드들의 작업 순서를 보장하는 happens-before 관계에 대한 정의
- happens-before 관계
  - JMM에서 스레드 간의 작업 순서를 정의하는 개념
  - 스레드 간의 메모리 가시성을 보장하기 위한 규칙
  - 이 규칙을 따르면 프로그래머가 멀티스레드 프로그램을 작성할 때 예상치 못한 동작을 피할 수 있다.
  - 만약 A 작업이 B 작업보다 happens-before 관계에 있다면, A 작업에서의 모든 메모리 변경 사항은 B 작업에서 볼 수 있다.
  - 즉, A 작업에서 변경된 내용은 B 작업이 시작되기 전에 모두 메모리에 반영된다.
- happens-before 관계가 발생하는 경우
  - 한 스레드에서 volatile 변수에 대한 쓰기 작업은 해당 변수를 읽는 모든 스레드에 보이도록 한다.
    - 즉 volatile 변수에 대한 쓰기 작업은 그 변수를 읽는 작업보다 happens-before 관계를 형성한다.
  - 한 스레드에서 Thread.start()를 호출하면, 해당 스레드 내의 모든 작업은 start() 호출 이후에 실행된 작업보다 happens-before 관계가 성립한다.
  - 한 스레드에서 Thread.join()을 호출하면, join 대상 스레드의 모든 작업은 join()이 반환된 후의 작업보다 happens-before 관계를 가진다.
  - 한 스레드에서 Thread.interrupt()를 호출하는 작업이, 인터럽트된 스레드가 인터럽트를 감지하는 시점의 작업보다 happens-before 관계가 성립한다.
  - 객체의 생성자는 객체가 완전히 생성된 후에만 다른 스레드에 의해 참조될 수 있도록 보장한다.
    - 즉, 객체의 생성자에서 초기화된 필드는 생성자가 완료된 후 다른 스레드에서 참조될 때 happens-before 관계가 성립한다.
  - 한 스레드에서 synchronized 블록을 종료한 후, 그 모니터 락을 얻는 모든 스레드는 해당 블록 내의 모든 작업을 볼 수 있다.
    - 뿐만 아니라 reentrantLock과 같이 락을 사용하는 경우에도 happens-before 관계가 성립한다.
- 결론 : volatile 또는 스레드 동기화 기법(synchronized, ReentrantLock)을 사용하면 메모리 가시성의 문제가 발생하지 않는다.
