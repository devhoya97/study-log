### 원자적 연산
- 원자적 연산은 멀티스레드 상황에서 volatile을 사용하면 아무런 문제가 발생하지 않는다.
  - 원자적 연산이 아닌 경우에는 synchronized 블록이나 Lock 등을 사용해서 안전한 임계 영역을 만들어야 한다.
- 원자적 연산 예시
  - i = 1 은 둘로 쪼갤 수 없는 원자적 연산이다.
  - 반면 i = i + 1 은, i를 읽는 작업 + i에 1을 더하는 작업 + 더한 값을 i에 대입하는 작업 세 가지로 나뉠 수 있다.

### AtomicInteger
- 멀티스레드 상황에서 안전하게 증가 연산을 수행할 수 있는, 자바가 제공하는 클래스
- AtomicInteger가 제공하는 incrementAndGet() 메서드는 락을 사용하지 않고 원자적 연산을 만들어낸다.
- synchronized 또는 Lock(ReentrantLock)을 사용하는 경우보다 1.5 ~ 2배 정도 빠르다.

### CAS(Compare-And-Swap, Compare-And-Set)
- 락은 어느정도 오버헤드가 있다.
  - 락이 있는지 확인하고, 획득하고, 반납하는 과정이 필요하다.
  - 락을 획득하지 못하면 RUNNABLE -> BLOCKED, 획득하면 BLOCKED -> RUNNABLE로 바뀌는 과정에서 스케줄링 오버헤드
- 락을 완전히 대체하는 것은 아니고 작은 단위의 일부 영역에 적용할 수 있다.
- 현대의 CPU는 대부분 원자적인 CAS 연산을 제공한다.
  - CAS(x001, 0, 1) 
  - (1) 메모리의 x001에 있는 데이터 값을 읽어서 0과 비교하고, (2) 두 값이 같으면 1로 변경한다.
  - (1)과 (2) 사이에 CPU가 자체적으로 x001 데이터에 대해 다른 CPU가 접근하지 못하도록 막는다. (마치 하드웨어 락)
  - 하지만 이 순간은 매우 찰나이기 때문에, SW에서 락을 직접 활용하는 것에 비해 성능 저하가 적다.
