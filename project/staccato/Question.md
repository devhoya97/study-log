### 스타카토는 어떤 프로젝트인가요?
스타카토는 일상을 빠르게 기록하고, 사용자 취향에 맞게 정리할 수 있도록 도와주는 서비스입니다.
휴대폰 사진앱의 확장판이라고 볼 수 있고, 글이나 이모지로 당시의 감정을 표현할 수 있습니다.
또한 기록들을 지도 위에서 직관적으로 확인할 수 있는 기능도 제공합니다. 

### 직접 맡아서 개발한 기능이 무엇인지 설명해주세요.
인프라를 개선할 때는 대부분 다같이 참여했지만, 그 중에서 CI/CD 중 발생한 문제와 무중단배포를 적용하면서 발생한 문제를 해결하기 위해 주도적으로 아이디어를 제시했습니다.
코드레벨에서는 방문기록에 추가할 수 있는 댓글과 관련된 API들을 담당했고, 카테고리는 기간을 갖는데, 특정 날짜를 포함하는 기간을 갖는 모든 카테고리를 가져오는 API를 구현했습니다.
특히 기간을 설정하지 않은 카테고리들의 경우엔 어떤 날짜로 조회하든 항상 조회되도록 만들기 위해 null 데이터를 다뤘던 과정이 기억에 남는 것 같습니다.

### 꼬리질문1. null 데이터를 어떤 식으로 다뤘나요?
카테고리에 기간 정보를 의도적으로 nullable하게 DB에 저장했습니다. 예를 들어 맛집 탐방과 같은 카테고리의 경우, 
기간을 정해놓지 않고, 계속해서 방문 기록이 쌓일 수 있기 때문에 기간을 필수로 지정하는게 오히려 사용성을 저하시킬 수 있다고 판단했기 때문입니다. 
따라서 카테고리에 기간이 null인 경우, 사실상 무한대의 기간을 가진다고 처리했고,
특정 날짜를 포함하는 모든 카테고리들을 조회할 때, 기간이 null로 지정된 카테고리들도 함께 조회되도록 JPQL을 작성했던 것이 기억에 남습니다.

### 꼬리질문2. JPQL을 어떤 식으로 작성했는지 설명해주실 수 있나요?
우선 JPA 연관관계를 어떻게 설정했는지에 대해 설명드리고 싶습니다.
하나의 카테고리를 여러 사용자가 공유할 수 있고, 각 사용자는 여러 카테고리를 가질 수 있어서 다대다 관계가 성립되었습니다.
따라서 CategoryMember라는 중간테이블을 활용했고, 특정 회원의 카테고리들 중 특정 날짜를 포함하는 카테고리들을 모두 가져오는 JPQL을 중간테이블을 기준으로 수행했습니다.
이 때, API에서 응답해야 하는 정보는 카테고리 엔티티에 포함되어 있으므로, fetch join을 활용해 카테고리 엔티티를 함께 가져오도록 JPQL을 작성했습니다.

### 꼬리질문3. N+1 문제를 해결하기 위한 해결책으로 fetch join 외에 다른 방법도 있는데, fetch join을 사용한 이유가 무엇인가요?
비교군으로 엔티티그래프 방법이 있는데, 이는 fetchType을 eager로 변환하는 방식으로 left outer join을 수행하여 데이터를 가져옵니다.
하지만 fetch join의 경우 따로 outer join으로 명시하지 않을 경우 inner join을 수행하게 되고, 
당시 inner join으로 인한 결과가 필요한 상황이었기 때문에 fetch join을 선택하게 되었습니다.

### 꼬리질문4. 엔티티그래프와 fetch join의 차이에 대해 더 설명해주실 수 있나요?
fetch join을 사용할 경우, JPQL을 직접 작성해줘야 하는 메서드가 많아질 수 있는데,
엔티티그래프를 사용하는 경우, fetchType을 eager로 동작하게 만듦으로써 쿼리를 반복적으로 직접 작성해줘야 하는 번거로움을 줄일 수 있습니다. 
다만 JPQL을 직접 보는 것에 비해 실제 실행되는 쿼리를 직관적으로 예상하기 어렵다는 단점이 있습니다.
또한 일대다 관계가 2개 이상일 때는 fetch join 사용이 불가능해 엔티티그래프를 사용해야 한다고 알고 있습니다.

### 사용자 피드백을 받아 수정한 기능이 있나요?
저희 서비스는 기록을 빠르게 할 수 있도록 도와주는게 목표이기 때문에, 방문기록을 작성할 때 시간과 위치 정보를 작성 시점을 기준으로 자동으로 불러오게 만들었습니다.
그리고 이렇게 만들어진 기록에 대해 시간과 위치 정보를 수정하지 못하게 만듦으로써 
사용자가 기록을 제때 남김으로써 기록이 숙제가 되지 않도록 유도하고 즉시 남긴 기록에 대해 좀 더 소중함을 느끼길 의도했습니다.
하지만 사용자 피드백에서, 기획 의도는 알겠지만, 기록을 즉시 하지 못하는 경우를 대비해서 시간과 위치 정보를 사용자가 변경할 수 있도록 권한을 주면 좋겠다는 피드백이 있었습니다.
따라서 위와 같은 사용자 피드백을 반영하기 위해 방문기록 수정 API를 추가했던 경험이 기억이 남습니다.

### 사용한 git flow에 대해 설명해주세요.
개발자간 협업을 위해 사용하는 git 브랜치 전략 중 하나로, 브랜치를 크게 5가지로 나누어 개발하는 전략입니다.
가장 중심이 되는 브랜치는 master와 develop 브랜치이며, feature, release, hotfix 브랜치가 필요에 따라 생성되고, merge후 삭제됩니다.
스타카토 프로젝트에서는 개발 서버와 운영 서버를 별도로 관리하고 있었기 때문에 develop 브랜치에 feature 브랜치가 merge되면
CI/CD workflow로 개발 서버에 자동으로 배포되고, main 브랜치에 develop 또는 hotfix 브랜치가 merge되면 운영 서버에 자동으로 배포되도록 설정했습니다.

### 꼬리질문. 여러 git 브랜치 전략 중 git flow를 사용한 이유가 무엇인가요?
저희 팀에서는 git flow와 github flow 중 고민을 했는데요.
새로운 기능을 개발할 때마다 운영 서버에 곧바로 배포되는 것보다는 개발 서버에만 먼저 배포 후 QA를 진행한 뒤에 운영 서버에 배포하는 과정을 거쳐
운영 서버의 안정성을 확보하기 위해 별도의 develop 브랜치와 release 브랜치가 필요하다고 생각했고, 따라서 git flow를 선택하게 되었습니다.

### 프로젝트를 개발하면서 가장 기억에 남는 트러블슈팅 경험이 있나요?
JPA의 orphanRemoval 옵션이 하이버네이트 버그로 인해 정상작동하지 않아 어려움을 겪었던 경험이 기억에 남습니다.
본래 orphanRemoval = true 옵션만 사용해도, 부모와 연관관계가 끊긴 자식 엔티티들을 고아로 취급해 delete 쿼리가 나가게 되는데요.
하이버네이트 버그로 인해 CascadeType.PERSIST 옵션을 함께 사용하지 않으면 delete 쿼리가 나가지 않는 문제가 있었습니다.
단순 하이버네이트 버그로 인한 문제였지만, 당시 문제를 분석하는 과정에서 JPA 연관관계에 대해 깊게 고민해볼 수 있었습니다.

### 프로젝트를 개선한다면 어느 부분을 개선하고 싶은가요?
본래 기획에서는 하나의 카테고리를 여러 회원이 공유할 수 있도록 만들고자 했는데요. 
따라서 카테고리와 회원을 다대다 관계로 정의하고 이 때 생기는 중간테이블까지 엔티티로 승격시켰지만, 서로 카테고리를 공유하는 기능까지는 완성하지 못했습니다.
따라서 프로젝트를 개선한다면 이와 같은 기능을 추가하고 싶습니다.

### 꼬리질문. 코드레벨에서 좀 더 개선하고 싶은 부분도 있을까요?
당시 코드리뷰를 열심히 진행했기 때문에, 코드 레벨에서 개선할 수 있는 사항들은 최대한 개선했다고 생각합니다.
그럼에도 불구하고 좀 더 넓은 시야를 갖고 계신 멘토님들이 코드를 본다면 개선할만한 지점이 많이 보이지 않을까 생각합니다.
이렇게 멘토님으로부터 방향성을 제시받아 좀 더 올바른 방향으로 프로젝트를 수행할 수 있다는 점에서 소마가 경쟁력이 있다고 생각하기에, 소마에서 프로젝트를 진행하고 싶습니다.

### 프로젝트 아키텍쳐를 그려주세요.
ALB, EC2 인스턴스 2개, EC2 인스턴스 안에 Nginx, RDS

### CI/CD란 무엇이고 왜 필요한가요?
CI는 Continuous Integration으로, 변경사항을 최대한 자주 메인 코드베이스에 merge 시키는 개발 방식입니다. 
이를 통해 빌드,통합 오류를 최대한 빠르게 찾아[ch8.전송계층4.md](..%2F..%2Fnetwork%2Flecture%2Fch8.%EC%A0%84%EC%86%A1%EA%B3%84%EC%B8%B54.md)낼 수 있습니다.
merge가 필요할 때마다 수동으로 빌드나 테스트를 돌리기 번거롭고 실수의 여지가 있으므로 Github Actions와 같은 자동화를 위한 도구를 사용합니다.
CD는 두 가지로 나뉘는데요.
첫 번째로 Continuous Delivery는 프로덕션 코드에 직접 빌드 결과를 제공하기까지만 하며, 배포를 위해 추가적인 작업이 필요합니다.
두 번째로 Continuous Deployment는 배포까지 파이프라인에 포함시키는 방식으로, 프로젝트에서는 이를 선택했습니다.

### Self Hosted Runner가 무엇이고 왜 사용했는지 설명해주세요.
Self Hosted Runner는, workflow를 인스턴스가 스스로 수행하도록 Runner를 지정하는 방식을 의미합니다.
CD를 위해선 일반적으로 Github Actions가 제공하는 Runner가 서버애플리케이션을 실행 중인 인스턴스로 ssh 접속이 가능하도록 인바운드 규칙을 허용해야 합니다.
하지만 우아한테크코스에서 진행했던 프로젝트에서는 인스턴스의 22번 포트에 대한 인바운드 규칙이 교육장 내의 IP만 허용하도록 강제되었기 때문에
polling 기반의 self hosted runner 방식을 활용해 인스턴스가 주기적으로 Github 서버에게 배포작업이 필요한지 묻는 요청을 보냄으로써
CD가 가능하도록 구현했습니다.

### 당시 사용한 네트워크 구조도에 대해 그려주세요. (VPC 포함)
SPOF 문제를 방지하기 위해 두 EC2 인스턴스를 서로 다른 가용 영역으로 분리했고, 
DB단도 마찬가지로 RDS를 사용하면서 Reader와 Writer를 서로 다른 가용 영역으로 분리했습니다.
DB는 private subnet에 넣어 외부에서 접근하지 못하게 했고, ALB를 사용하고 있으므로 서버 인스턴스도 마찬가지로 private subnet에 넣었습니다.
그리고 각 가용영역의 public subnet에는 NAT를 둠으로써, 예를 들어 EC2 인스턴스에서 외부 라이브러리를 다운받거나, 
CD를 위해 Self Hosted Runner로 Github에 접근해야 하는 경우 NAT를 통해 외부 네트워크로 요청이 나갈 수 있게끔 설정했습니다.

### Github Actions란 무엇이고, 다른 도구말고 이를 선택한 이유가 무엇인가요?
Github에서 제공하는 CI/CD를 자동화할 수 있는 도구입니다.
특히 workflow의 step에는 shell script를 작성해야 하는데, 자주 사용되는 스크립트 코드는 마치 라이브러리와 같이 Actions로 제공해주므로 편리합니다.
다른 CI/CD 도구로서 젠킨스도 있었는데요. 조사해보니 러닝커브가 Github Actions에 비해 높다고 판단되어서 Github Actions를 선택하게 되었습니다.
젠킨스와의 비교? 깃허브액션만의 특징과 장단점을 말할 수 있으면 좋겠다.

### HTTPS에 대해 설명해주세요.
HTTPS는 HTTP에 보안을 강화한 버전으로 볼 수 있습니다.
데이터를 암호화 해서 기밀성을 유지하고, 위변조 여부를 검사해서 무결성을 지키며, 공개키로 복호화하는 과정에서 상대가 누구인지 인증할 수도 있습니다.
이를 위해 HTTP와 TCP 사이에 SSL/TLS라는 보안 계층이 추가됩니다.
HTTPS는 HTTP에서 전송하려는 메시지를 암호화 시키고, 

### SSL과 TLS의 차이가 무엇인가요?
SSL이 처음 도입되고, 폭넓게 사용되다가 표준화 기구에 의해 관리되면서 TLS라는 이름으로 변경된 것으로 알고 있습니다.
따라서 둘 다 웹 서버와 웹 브라우저 간의 보안을 위해 만든 프로토콜입니다.

### HTTPS의 대칭키(공통키) 암호화 방식에 대해 설명해주세요.
송신자와 수신자가 같은 키를 공유해서, 대칭키 방식이라고 부릅니다.
메시지가 탈취당하더라도 대칭키만으로 복호화할 수 있으므로 안전하지만,
서버와 클라이언트가 대칭키를 공유하는 과정에서 키를 탈취당하면, 해커가 암호를 쉽게 해독할 수 있게 된다는 단점이 있습니다.
이 문제를 해결하기 위해 클라이언트가 대칭키를 생성하고 서버에게 공유할 때, 서버의 공개키로 대칭키 값을 암호화합니다.
그럼 메시지가 탈취당해도 서버의 비밀키 없이는 대칭키의 정보를 빼갈 수 없으므로, 대칭키 공유 과정을 안전하게 수행할 수 있습니다. 
또한 암호화와 복호화를 같은 키로 수행하므로 속도가 빠릅니다.

### HTTPS의 비대칭키(공개키) 암호화 방식에 대해 설명해주세요.
암호화를 위한 키와 복호화를 위한 키를 구분해서 사용하는 방식입니다.
비밀키는 오직 서버만이 가지고 있고, 클라이언트는 누구에게나 공개된 공개키를 갖습니다.
공개키로 암호화된 메시지는 오직 비밀키로만 복호화할 수 있지만, 서버의 비밀키로 암호화된 메시지는 공개키로 모두가 복호화할 수 있습니다.
그럼에도 비밀키로 메시지를 암호화 하는 이유는 누가 메시지를 썼는지 알려주고, 메시지가 위조되지 않았음을 증명하기 위해서 입니다.
암호화와 복호화를 다른 키로 수행하므로 속도가 느립니다.

### SSL 인증서란 무엇인가요?
CA라는 인증기관이 자신의 개인키로 인증서를 암호화해서 서버에게 보내주고, 서버는 클라이언트에게 인증서를 보내줍니다.
클라이언트는 CA로부터 받은 공개키로 해당 인증서의 복호화를 시도하고, 복호화에 성공했다면 CA가 발급한 인증서가 맞다고 믿고
인증받은 서버와 안전하게 소통할 수 있게 됩니다.

### 도커에 대해 설명해주세요.
도커란 컨테이너 기반 가상화 기술을 제공하는 오픈 소스 플랫폼입니다.
도커를 사용하면 애플리케이션을 컨테이너 단위로 패키징하여, 도커 이미지로 만들어 일관된 실행 환경에서 애플리케이션을 배포하고 운영할 수 있습니다. 
따라서 로컬 개발 환경과 운영 환경의 차이로 인한 오류가 발생하지 않아 배포를 안정적으로 수행할 수 있다는 장점이 있습니다.

### 도커 데몬이란 무엇인가요?
도커 데몬은 호스트에서 메모리에 상주하며 백그라운드에서 컨테이너를 관리하는 프로세스 입니다.
도커 데몬은 클라이언트의 요청을 기다리고 있다가 요청이 발생하면 적절히 대응합니다.

### 도커 이미지란 무엇인가요?
도커 이미지는 도커 컨테이너를 실행하기 위해 필요한 모든 요소를 포함한 불변 패키지입니다.
도커 이미지는 기본적으로 코드, 라이브러리, 커널을 제외한 운영체제의 user space로 구성되어 있고,
컨테이너가 어떻게 인스턴스화 되어야 하는지에 대한 실행 명령어 및 설정 정보까지 포함되어 있습니다.

### 도커 컨테이너란 무엇인가요?
도커 컨테이너는 가상화된 런타임 환경으로, 도커 이미지를 바탕으로 생성됩니다.
각 도커 컨테이너끼리는 격리된 환경에서 구동되지만, Host OS는 공유한다는 특징이 있습니다.
덕분에 실행 환경을 격리하면서도, 가볍고, 도커 이미지를 통해 일관된 실행 환경을 구축할 수 있다는 장점이 있습니다. 

### 도커컴포즈에 대해 설명해주세요. 왜 사용하셨나요?
도커 컴포즈는 여러 개의 컨테이너를 하나의 서비스로 정의하고 구성해 하나의 묶음으로 관리할 수 있도록 도와주는 도구입니다.
개발 초기 단계에는 하나의 EC2 인스턴스에 스프링 애플리케이션과 MySQL을 모두 실행시키고 있었고, 
두 개의 이미지를 한 번에 실행시킬 수 있도록 도커컴포즈를 사용했습니다.
하지만 이후 스프링 애플리케이션과 MySQL을 서로 다른 인스턴스로 분리했고, 도커컴포즈가 아닌 도커파일을 이용해 CD를 하는 방식으로 변경했습니다.

### gradle에 대해 설명해주세요.
오픈소스 빌드 자동화 도구로, 소프트웨어 프로젝트의 컴파일, 테스트, 패키징, 배포 및 실행 작업을 자동화해줍니다. 
또한 build.gradle에서는 의존성이나 플러그인 설정 등 프로젝트 빌드에 필요한 설정을 groovy 기반 스크립트로 비교적 간편하게 작성할 수 있습니다.

### 블루그린 방식 무중단 배포에 대해 설명해주세요.
블루그린 무중단 배포란, 기존 버전을 블루로 상정하고, 블루의 갯수만큼 인스턴스를 생성해 새로운 버전을 배포한 인스턴스를 그린으로 상정한 뒤,
모든 그린 인스턴스의 정상동작이 확인되면, 로드밸런서가 블루가 아닌 그린으로 트래픽을 분산하도록 한꺼번에 변경하는 방식입니다.
블루그린 방식은 그린을 사용하다가 문제가 발생하면 즉시 로드밸런서를 블루로 돌려 빠른 롤백이 가능하고, 
다중서버환경에서도 구버전과 신버전이 공존하지 않는다는 장점이 있습니다.

### 꼬리질문. 또 다른 무중단 배포 방식에 대해 알고 계신 게 있나요?
롤링 방식과 카나리 방식이 있는데요. 
롤링 방식은 일부 인스턴스를 점진적으로 업데이트하여 블루그린 방식과 반대로 추가 인스턴스가 필요하지 않지만, 구버전과 신버전이 공존하는 시간이 존재하고 
배포가 수행되는 동안 배포를 수행 중이지 않은 인스턴스에 트래픽이 몰릴 수 있습니다.
카나리 방식은 일부 사용자에게만 신버전을 배포 후 안정성을 확인한 다음, 점진적으로 확대하는 방식으로 안정성이 높지만 트래픽을 조절해줘야 합니다.

### SPOF 문제란 무엇인가요?
Single Point Of Failure 문제로, 시스템을 구성하는 하나의 요소에 장애가 발생했을 때, 전체 시스템이 마비되는 경우 SPOF 문제가 있다고 말합니다.
대표적으로 애플리케이션 서버 1대와 DB 서버 1대를 운영하고 있다면, 각 서버가 SPOF 문제를 갖게 됩니다.
이 문제를 해결하기 위해선 다중 애플리케이션 서버를 사용하고 DB 또한 RDB의 경우 reader와 writer를 나눠서 SPOF 문제를 방지해야 합니다.

### 서버가 다중화될 때 고려해야 하는 사항은 무엇이 있었나요?


### Nginx는 무엇인가요? Nginx를 왜 사용하셨나요?
포트포워딩 리버스 프록시

### 구버전 서버와 신버전 서버가 공존하면 어떤 문제가 있나요?
