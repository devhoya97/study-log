### 생산자 소비자 문제 - synchronized 활용 버전
- 버퍼가 꽉 찼을 때 생산자가 생산을 시도하려 한다면, 데이터를 어떻게 해야 한 버릴 수 있을까? 에 대한 고민이 필요하다.
- 버퍼가 비어있을 때 소비자가 소비를 시도하려 한다면, 어떻게 해야 데이터가 생산될 때까지 기다릴 수 있을까? 에 대한 고민이 필요하다.
- 버퍼의 put은 생산자를 위한 메서드고, take는 소비자를 위한 메서드다.
  - 이 때, put과 take에 모두 synchronized를 적용한다면, 생산자와 소비자가 같은 모니터 락을 사용하게 된다.
  - 따라서 생산자가 sleep으로 모니터 락을 쥐고 소비자의 소비를 기다려봤자, 소비자는 모니터 락을 획득하지 못해 소비를 할 수 없다. (반대도 마찬가지)
- 아무 일도 하지 않고 대기하는 동안, Object.wait(), Object.notify()를 활용해 잠시 다른 스레드에게 락을 양보해야 한다.
  - 주의! notify()를 호출하면 WAITING -> BLOCKED로 상태가 바뀐다. 깨워준 스레드가 아직 synchronized에서 나가지 않았을 수 있다.
  - 다만, 생산자와 소비자가 같은 공간(객체마다 존재하는 wait set)에서 대기하므로, notify()를 호출할 때 생산자와 소비자 중 지정해서 깨울 수가 없다.
  - 즉 소비자1이 소비를 완료하고, 애꿎은 소비자2를 깨울 수 있다. (반대도 마찬가지)
  - 물론 로직상 문제는 없지만, 소비자2는 괜히 일어났다가 다시 자러 들어가야 하는 비효율이 발생한다.

### Object.wait()
- 현재 스레드가 가진 락을 반납하고 WAITING 상태로 들어간다.
- 현재 스레드가 synchronized 블록이나 메서드에서 락을 소유하고 있을 때에만 호출할 수 있다.
- 대기 상태로 전환된 스레드는 다른 스레드가 notify() 또는 notifyAll()을 호출할 때까지 대기 상태를 유지한다.
  - WAITING 상태니까 인터럽트를 걸어서 깨울 수는 없나?

### Object.notify(), Object.notifyAll()
- 대기 중인 스레드 중 하나 또는 모두를 깨운다.
- 이 메서드는 synchronized 블록이나 메서드에서 호출되어야 한다.
- 깨운 스레드는 락을 다시 획득할 기회를 얻게 된다.
