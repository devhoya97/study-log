### 멀티태스킹과 멀티프로세싱의 차이에 대해 설명해주세요.
멀티태스킹은 하나의 코어가 여러 개의 프로세스를 컨텍스트 스위칭하며 마치 사용자 입장에서 동시에 여러 프로세스를 수행하는 것처럼 느끼도록 만드는 기술입니다.
반면 멀티프로세싱은 여러 개의 코어를 사용하여 병렬적으로 프로세스를 실행시키는 방법입니다.

### 자바 메모리 구조에 대해 설명해주세요.
자바 메모리 구조는 메서드 영역, 힙 영역, 스택 영역으로 구분됩니다.
메서드 영역에는 클래스와 같이 각종 코드들이 들어가고, static 변수나 리터럴 상수도 들어갑니다.
힙 영역은 객체나 배열이 할당되는데, 더 이상 참조되지 않는 객체나 배열은 GC에 의해 제거됩니다.
스택 영역은 특별히 스레드 별로 할당되며, 메서드가 실행될 때마다 스택 프레임이 할당되고 메서드가 끝날 때마다 스택 프레임이 제거됩니다.
스택 프레임에는 매개변수나 지역변수, 리턴 주소 등이 저장됩니다.

### 꼬리질문. 스택프레임이 생성될 때, this는 무슨 역할을 하나요?
static 메서드라면 상관 없지만, 인스턴스 메서드라면 메서드를 수행할 때 this라는 변수에 인스턴스의 주소 값을 저장하는데,
덕분에 스택 프레임은 스레드마다 스택 영역에 존재하지만, 힙 영역에 존재하는 인스턴스의 주소 값이 필요할 때 this를 사용하여 접근할 수 있습니다.

### 자바에서 스레드를 생성하는 방법에 대해 설명해주세요. 
Thread 클래스를 상속한 클래스를 만들거나, Runnable 인터페이스를 구현한 클래스를 Thread 클래스의 생성자 매개변수로 넘겨주는 방법이 있습니다.
어떤 방법으로든 Thread 객체를 생성했다면, 이 때 주의해야 할 점이 run() 메서드를 직접 호출하는게 아닌 start() 메서드를 호출해야 한다는 점입니다.
start() 메서드를 호출해야만 스레드를 생성하는 운영체제 API를 자바가 호출해주면서, OS 레벨에서 실제로 스레드가 생성되고 스택이 할당되기 때문입니다.
반면 run() 메서드를 직접 호출하면, 이를 호출한 스레드의 스택 프레임에 run() 메서드가 추가되므로, 의도대로 스레드를 생성했다고 보기 어렵습니다.

### 스레드 상태 중 Blocked와 Waiting을 비교해서 설명해주세요.
Blocked의 경우 다른 스레드에 의해 이미 점유된 동기화 락을 기다릴 때 스레드가 진입하는 상태이고,
Waiting의 경우 IO 작업과 같이 스레드가 다른 스레드의 작업을 기다리는 상태입니다. (IO 작업을 하는 스레드가 별도로 있는건가?)
둘은 락을 기다리는 것과, 다른 스레드의 작업을 기다리는 것에서 차이가 있지만
당장 CPU를 점유해도 작업을 진행할 수 없으므로 CPU 스케줄링에서 잠시 벗어나 있다는 공통점이 있습니다.

### 자바의 join() 메서드에 대해 설명해주세요.
스레드1이 스레드2의 작업이 끝나길 기다려야만 자신의 다음 작업을 수행할 수 있는 경우 join을 사용합니다.
이 때 스레드1은 스레드2의 상태가 terminated가 될 때까지 waiting 상태로 들어가게 됩니다.

### 자바에서 특정 스레드가 다른 스레드에 인터럽트를 발생시키면 어떻게 되나요?
스레드1이 스레드2에게 인터럽트를 걸면, 스레드2의 인터럽트 상태가 true로 변경됩니다.
이후 스레드2가 sleep(), join()과 같이 interruptedException을 발생시키는 메서드를 호출할 때 해당 예외가 발생되며 인터럽트 상태가 false로 돌아옵니다.
(서버 개발하면서 이렇게 인터럽트를 거는 상황이 언제가 있을까? -> 아래와 같은 사례들이 있다는데, 아직 잘 모르겠다.)
```
활용 사례	설명
타임아웃이 있는 비동기 작업 중단	@Async, Future.cancel(true)
서버 종료 시 실행 중인 작업 종료	@Scheduled, @PreDestroy
API 요청 취소 시 실행 중인 작업 종료	클라이언트가 요청을 취소하면 인터럽트 발생
스레드풀에서 실행 중인 작업 강제 종료	ThreadPoolTaskExecutor.shutdownNow()
```

### 메모리 가시성 문제에 대해 설명해주세요.
멀티스레드 환경에서 한 스레드가 변경한 값이 다른 스레드에서 언제 보이는가 하는 문제를 메모리 가시성 문제라고 합니다.
이는 스레드마다 사용하는 캐시값에 동기화가 되지 않아 발생하는 문제이며, 
자바에서는 volatile 키워드를 사용해 캐시가 아닌 메인메모리의 값만 사용하도록 설정함으로써 메모리 가시성 문제를 극복할 수 있습니다.
다만 캐시를 사용하지 않기 때문에 그만큼의 성능하락을 감안해야 하므로, 꼭 필요한 곳에만 사용하도록 주의해야 합니다. 

### 자바의 synchronized 키워드에 대해 설명해주세요.
