### 멀티태스킹과 멀티프로세싱의 차이에 대해 설명해주세요.
멀티태스킹은 하나의 코어가 여러 개의 프로세스를 컨텍스트 스위칭하며 마치 사용자 입장에서 동시에 여러 프로세스를 수행하는 것처럼 느끼도록 만드는 기술입니다.
반면 멀티프로세싱은 여러 개의 코어를 사용하여 병렬적으로 프로세스를 실행시키는 방법입니다.

### 자바 메모리 구조에 대해 설명해주세요.
자바 메모리 구조는 메서드 영역, 힙 영역, 스택 영역으로 구분됩니다.
메서드 영역에는 클래스와 같이 각종 코드들이 들어가고, static 변수나 리터럴 상수도 들어갑니다.
힙 영역은 객체나 배열이 할당되는데, 더 이상 참조되지 않는 객체나 배열은 GC에 의해 제거됩니다.
스택 영역은 특별히 스레드 별로 할당되며, 메서드가 실행될 때마다 스택 프레임이 할당되고 메서드가 끝날 때마다 스택 프레임이 제거됩니다.
스택 프레임에는 매개변수나 지역변수, 리턴 주소 등이 저장됩니다.

### 꼬리질문. 스택프레임이 생성될 때, this는 무슨 역할을 하나요?
static 메서드라면 상관 없지만, 인스턴스 메서드라면 메서드를 수행할 때 this라는 변수에 인스턴스의 주소 값을 저장하는데,
덕분에 스택 프레임은 스레드마다 스택 영역에 존재하지만, 힙 영역에 존재하는 인스턴스의 주소 값이 필요할 때 this를 사용하여 접근할 수 있습니다.

### 자바에서 스레드를 생성하는 방법에 대해 설명해주세요. 
Thread 클래스를 상속한 클래스를 만들거나, Runnable 인터페이스를 구현한 클래스를 Thread 클래스의 생성자 매개변수로 넘겨주는 방법이 있습니다.
어떤 방법으로든 Thread 객체를 생성했다면, 이 때 주의해야 할 점이 run() 메서드를 직접 호출하는게 아닌 start() 메서드를 호출해야 한다는 점입니다.
start() 메서드를 호출해야만 스레드를 생성하는 운영체제 API를 자바가 호출해주면서, OS 레벨에서 실제로 스레드가 생성되고 스택이 할당되기 때문입니다.
반면 run() 메서드를 직접 호출하면, 이를 호출한 스레드의 스택 프레임에 run() 메서드가 추가되므로, 의도대로 스레드를 생성했다고 보기 어렵습니다.

### 스레드 상태 중 Blocked와 Waiting을 비교해서 설명해주세요.
Blocked의 경우 다른 스레드에 의해 이미 점유된 동기화 락을 기다릴 때 스레드가 진입하는 상태이고,
Waiting의 경우 IO 작업과 같이 스레드가 다른 스레드의 작업을 기다리는 상태입니다. (IO 작업을 하는 스레드가 별도로 있는건가?)
둘은 락을 기다리는 것과, 다른 스레드의 작업을 기다리는 것에서 차이가 있지만
당장 CPU를 점유해도 작업을 진행할 수 없으므로 CPU 스케줄링에서 잠시 벗어나 있다는 공통점이 있습니다.

### 자바의 join() 메서드에 대해 설명해주세요.
스레드1이 스레드2의 작업이 끝나길 기다려야만 자신의 다음 작업을 수행할 수 있는 경우 join을 사용합니다.
이 때 스레드1은 스레드2의 상태가 terminated가 될 때까지 waiting 상태로 들어가게 됩니다.

### 자바에서 특정 스레드가 다른 스레드에 인터럽트를 발생시키면 어떻게 되나요?
스레드1이 스레드2에게 인터럽트를 걸면, 스레드2의 인터럽트 상태가 true로 변경됩니다.
이후 스레드2가 sleep(), join()과 같이 interruptedException을 발생시키는 메서드를 호출할 때 해당 예외가 발생되며 인터럽트 상태가 false로 돌아옵니다.
(서버 개발하면서 이렇게 인터럽트를 거는 상황이 언제가 있을까? -> 아래와 같은 사례들이 있다는데, 아직 잘 모르겠다.)
```
활용 사례	설명
타임아웃이 있는 비동기 작업 중단	@Async, Future.cancel(true)
서버 종료 시 실행 중인 작업 종료	@Scheduled, @PreDestroy
API 요청 취소 시 실행 중인 작업 종료	클라이언트가 요청을 취소하면 인터럽트 발생
스레드풀에서 실행 중인 작업 강제 종료	ThreadPoolTaskExecutor.shutdownNow()
```

### 메모리 가시성 문제에 대해 설명해주세요.
멀티스레드 환경에서 한 스레드가 변경한 값이 다른 스레드에서 언제 보이는가 하는 문제를 메모리 가시성 문제라고 합니다.
이는 스레드마다 사용하는 캐시값에 동기화가 되지 않아 발생하는 문제이며, 
자바에서는 volatile 키워드를 사용해 캐시가 아닌 메인메모리의 값만 사용하도록 설정함으로써 메모리 가시성 문제를 극복할 수 있습니다.
다만 캐시를 사용하지 않기 때문에 그만큼의 성능하락을 감안해야 하므로, 꼭 필요한 곳에만 사용하도록 주의해야 합니다. 

### 자바의 synchronized 키워드에 대해 설명해주세요.
인스턴스마다 존재하는 모니터 락을 활용해 멀티스레드 환경에서 동시성 문제를 제어하는 방법입니다.
또한 volatile을 사용하지 않아도 happens-before 규칙에 따라 synchronized 안에서 접근하는 변수의 메모리 가시성 문제는 해결됩니다.
키워드 하나만으로 동기화 문제를 간편히 해결할 수 있다는 장점이 있지만, 무한대기와 공정성 문제라는 단점이 존재합니다.

### 꼬리질문. synchronized의 단점을 보완한 방법은 무엇이 있나요?
java.util.concurrent 라이브러리에서 제공하는 LockSupport.park()를 사용하면, 스레드가 BLOCKED가 아닌 WAITING 상태로 들어가므로,
unpark() 또는 interrupt()로 이를 깨울 수 있어 synchronized와 달리 무한 대기 문제가 발생하지 않습니다.
다만 LockSupport로 개발자가 직접 동시성 문제를 해결하는 코드를 짜기는 쉽지 않기 때문에 ReentrantLock 구현체를 활용하면 됩니다.

### ReentrantLock에 대해 설명해주세요.
synchronized의 무한 대기 문제와 공정성 문제를 해결하기 위해 등장한 방법으로, Lock 인터페이스의 구현체 중 하나입니다.
자바의 모니터 락을 사용하지 않고, 자체적으로 락과 대기 큐를 관리하며, 대기 중인 스레드는 BLOCKED 상태가 아닌 WAITING 상태로 들어간다는 특징이 있습니다.
WAITING 상태의 경우 인터럽트로 깨울 수 있어서 무한 대기 문제를 해결할 수 있고, ReentrantLock은 공정 모드와 비공정 모드를 선택할 수 있으므로
공정 모드를 선택할 경우 공정성 문제를 해결할 수 있습니다.

# 생산자 소비자
### 생산자 소비자 문제를 synchronized로 해결하는 방법에 대해 설명해주세요.
유한 버퍼 객체에 생산자를 위한 put 메서드와 소비자를 위한 take 메서드에 모두 synchronized를 걸어주고,
put 메서드에서 큐가 꽉 차있거나, take 메서드에서 큐가 비어있는 경우에 Object.wait()을 호출하여 모니터 락을 반납하면서 WAITING 상태로 들어가야 합니다.
put 메서드로 생산에 성공했거나, take 메서드로 소비에 성공하면 Object.notify()를 호출해 WAITING 상태에 있던 생산자 또는 소비자 스레드를
BLOCKED 상태로 깨워준 뒤, 깨운 스레드가 synchronized 블록을 나가면서 모니터 락을 반납하게 되면, 깨어난 스레드는 BLOCKED에서 모니터 락을 획득해
RUNNABLE 상태가 될 수 있는데, 이 때 소비자가 소비자를 깨운 경우에는 락을 획득해봤자 큐는 비어있으므로, 다시 잠들러 가야하는 비효율이 초래될 수 있습니다.
-> ReentrantLock을 활용해 생산자 락과 소비자 락을 분리하고 대기 큐 또한 분리하면 된다?

### 생산자 소비자 문제를 ReentrantLock으로 해결하는 방법에 대해 설명해주세요.
ReentrantLock으로 생산자가 대기할 Condition과 소비자가 대기할 Condition을 나눠서 생성할 수 있습니다.
생산자는 생산을 완료하고 소비자 Condition에 signal()을 호출해 소비자를 깨우고, 
소비자는 소비를 완료하고 생산자 Condition에 signal을 호출해 생산자를 깨움으로써 
synchronized + Object.wait() + Object.notify() 조합을 사용할 때 발생했던 비효율 문제를 해결할 수 있습니다.

### BlockingQueue 인터페이스에 대해 설명해주세요.
ReentrantLock을 활용해 생산자 소비자 문제를 해결할 수 있도록 java.util.concurrent 패키지에서 제공하는 인터페이스입니다.
구현체로는 ArrayBlockingQueue와 LinkedBlockingQueue가 있으며
대기 시 예외 발생, 대기 시 즉시 반환, 대기, 시간 대기 상황에 맞는 생산자 메서드와 소비자 메서드를 각각 제공합니다.

# CAS
### AtomicInteger가 synchronized나 Lock보다 성능이 좋은 이유가 무엇인가요?
AutomicInteger가 제공하는 incrementAndGet() 메서드는 락을 사용하지 않고, 원자적 연산을 만들기 때문입니다.
CPU가 자체적으로 제공하는 CAS 연산을 사용하게 되며, 값을 비교하고 변경하는 사이에 해당 데이터에 대해 물리적인 락이 걸리는데,
소프트웨어 레벨에서 락을 활용하는 것과 비교하면 매우 찰나의 시간이므로 성능 저하 부담이 덜하다는 장점이 있습니다.

### CAS와 락의 차이가 무엇인가요?
