# 질답 형식으로 요약

<details>
<summary>...</summary>

...
</details>

<hr style="height: 3px; background-color: black; border: none;">

# 이론 정리

### 멀티태스킹
- 하나의 CPU 코어로 여러 프로그램을 동시에 실행하는 기술
- 소프트웨어 기반으로 CPU 시간을 분할하여 각 작업에 할당

### 멀티프로세싱
- 최근에는 하나의 CPU 안에 보통 2개 이상의 코어가 들어있다.
- 코어가 2개이면 물리적으로 동시에 2개의 프로그램을 처리할 수 있다.
- 즉 하드웨어 기반으로 성능을 향상시키는 방법

### 프로세스의 메모리
- 운영체제 서적에서는 프로그램의 주소 영역이 코드, 데이터, 스택으로 구분된다고 배웠다.
  - 힙도 독립적인 영역을 갖는다고 보는게 맞는 것 같음
  - 프로세스 주소 영역은 낮은 주소부터 코드, 데이터, 힙, 스택으로 할당된다.
  - 컴파일 타임에 프로세스 주소 영역의 크기는 결정되므로, 
    - 힙은 데이터 영역 다음부터 시작해 높은 주소 방향으로 동적으로 할당되고
    - 스택은 프로세스 주소 영역의 가장 높은 주소부터 낮은 주소 방향으로 동적으로 할당된다.
    - 둘의 사이의 여유 공간이 모두 소모되고 서로 충돌이 발생하면 스택 오버플로우가 발생하는 듯
- 코드, 데이터, 힙 영역은 프로세스 내의 모든 스레드가 공유하지만, 스택은 각 스레드마다 할당된다.
    - 만약 하나의 프로세스에 10개의 스레드가 있다면, 스레드마다 스택의 크기는 고정되야 할 것 같다.
    - 그럼 스택과 힙 사이의 여유 공간은, 스택 입장에서는 새로운 스레드가 할당되어야 추가 할당받는 구조인 듯
- 각 프로세스는 별도의 메모리 공간을 갖고 있기 때문에 서로 간섭하지 않는다.

### WAS에서의 프로세스와 스레드 (출처 명확x)
- WAS의 경우 일반적으로 JVM이 하나의 프로세스로 실행되고 JVM 내에서 Tomcat이 동작한다.
  - Tomcat은 서블릿 컨테이너를 통해 Spring 애플리케이션을 관리한다.
  - Tomcat은 스레드 풀을 통해 HTTP 요청을 처리한다.
    - Acceptor Thread는 클라이언트의 새로운 TCP 연결 요청을 받아들이는 역할
      - 클라이언트로부터 들어오는 TCP 패킷 수신을 감지하는 과정은 CPU가 관여하지 않는다.
        - NIC(Network Interface Card)가 인지하여 CPU에 하드웨어 인터럽트를 발생시킨다.
        - CPU는 커널모드로 진입해 ISR에 따라 Acceptor Thread를 깨운다. 
      - 항상 CPU 코어를 점유하는 것이 아니라, 비동기 방식으로 소켓에 대한 연결 요청을 감시
      - 요청이 없으면 IO 이벤트를 기다리는 블로킹 상태로 대기하므로 CPU 리소스를 많이 사용하지 않는다.
      - 연결 요청이 들어오면 Ready 상태로 전환되어 빠르게 연결을 수락하고 이를 Worker Thread에 전달한다.
    - Worker Thread는 Acceptor Thread가 수락한 연결을 실제로 HTTP 요청 처리로 이어 받는다.

### 스레드
- 프로세스는 하나 이상의 스레드를 반드시 포함한다.
- 한 프로세스 내의 여러 스레드는 코드 영역, 데이터 영역, 힙 영역은 공유하지만 스택 영역은 개별적으로 사용한다.
- 프로그램이 실행된다 것은 어떤 의미?
  1. 프로그램을 메모리로 불러와서 프로세스를 만든다.
  2. 스레드가 코드를 하나씩 실행한다.

### 단일 코어 스케줄링
- 커널의 데이터 영역에는 스케줄링 큐가 포함되어 있다.
  - 각각의 스레드는 스케줄링 큐에서 대기한다.

### 스레드간 컨텍스트 스위칭 시 발생하는 비용
- 새로 실행할 스레드의 PC 값, register 값을 불러들여야 한다. (PCB에 저장되어 있나?)

### 스레드 간 컨텍스트 스위칭보다 프로세스 간 컨텍스트 스위칭이 부담스러운 이유
- 특히 CPU 캐시에 저장된 데이터가 모두 무효화 되기 때문에 캐시 미스가 증가하고 성능이 떨어지기 때문!
