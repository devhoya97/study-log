### 스레드 상태
- 종류
  - New : 스레드가 아직 시작되지 않은 상태. 즉 아직 start() 메서드가 호출되지 않음
  - Runnable : 스레드가 실행 중이거나 실행될 준비가 된 상태
  - Blocked : 스레드가 동기화 락을 기다리는 상태 (ex. synchronized 블록에 진입하기 위해 락을 얻어야 하는데 이미 다른 스레드가 락을 점유한 경우)
  - Waiting : 스레드가 다른 스레드의 특정 작업이 완료되기를 기다리는 상태 (ex.IO 요청을 하고 기다림, wait(), join())
  - Timed_Waiting : 일정 시간동안 기다리는 상태 (ex. sleep(long millis), wait(long timeout), join(long millis))
  - Terminated : 스레드의 스택이 텅텅 비게 되면 스레드가 끝난다. 참고로 스레드 스택의 가장 밑 단에는 run() 메서드가 있다.
- Blocked, Waiting, Timed_Waiting과 같이 일시 중지 상태에 있는 스레드들은 CPU 스케줄러에 들어가지 않는다. 

### 체크 예외 재정의
- Runnable 인터페이스의 run() 메서드 시그니처를 보면, 예외를 던지는 않는 걸로 정의되어 있다.
  - 따라서 sleep 시 발생하는 체크 예외인 InterruptedException을 밖으로 던질 수 없다.
  - 자바에서는 부모 메서드가 체크 예외를 던지지 않는 경우, 재정의된 자식 메서드도 체크 예외를 던질 수 없기 때문
  - 즉 자식 메서드는 부모 메서드가 던질 수 있는 체크 예외의 하위 타입 또는 언체크 예외만 던질 수 있다.
- 체크 예외를 run() 메서드에서 던질 수 없도록 강제함으로써, 개발자는 반드시 체크 예외를 try-catch 블록 내에서 처리하게 된다.
  - 이는 예외 발생 시 예외가 적절히 처리되지 않아서 프로그램이 비정상 종료되는 상황을 방지할 수 있다.
  - 특히 멀티스레딩 환경에서는 예외 처리를 강제함으로써 스레드의 안정성과 일관성을 유지할 수 있다.
  - 하지만 Runnable의 최근 버전인 Callable 인터페이스는 메서드 시그니처에서 Exception을 던진다. 요즘엔 체크 예외를 잘 안 쓰기 때문

### this의 비밀
- 어떤 메서드를 호출하는 것은, 정확히는 특정 스레드가 어떤 메서드를 호출하는 것이다.
- 스레드는 메서드의 호출을 관리하기 위해 메서드 단위로 스택 프레임을 만들고 해당 스택 프레임을 스택 위에 쌓아 올린다.
- 이 때 인스턴스의 메서드를 호출하면, 어떤 인스턴스의 메서드를 호출했는지 기억하기 위해, 해당 인스턴스의 참조값을 스택 프레임 내부에 this로 저장해둔다.
  - 아.. 그럼 인스턴스의 필드 값은 힙 영역에 저장되어 있고, 메서드 호출 시 지역변수는 스택 프레임에 저장되어 있겠구나.

### join
- 스레드1이 스레드2의 작업이 끝나길 기다려야만 자신의 다음 작업을 수행할 수 있는 경우, join을 사용한다.
- 즉 스레드1은 스레드2의 상태가 Terminated로 변경될 때까지 Waiting 상태로 대기한다.
  - 이 때 스레드2가 완료될 때까지 무한정 기다리는 것을 원하지 않는다면, join(long millis)로 최대 대기 시간을 지정할 수 있다.
  - 그럼 스레드1이 Waiting이 아닌 Timed_Waiting 상태로 들어가게 된다.

### 인터럽트
- 인터럽트를 사용하면 Waiting, Timed_Waiting 같은 대기 상태의 스레드를 직접 깨워서, 작동하는 Runnable 상태로 만들 수 있다.
- 특정 스레드의 인스턴스에 interrupt() 메서드를 호출하면, 해당 스레드에 인터럽트가 발생한다.
  - interrupt()를 호출했다고 해서 즉각 InterruptedException이 발생하는 것은 아니다.
  - 오직 sleep() 처럼 InterruptedException을 던지는 메서드(ex. join())를 호출하거나 또는 호출 중일 때 예외가 발생한다.
  - 이 때 인터럽트를 받은 스레드는 대기 상태에서 깨어나 Runnable 상태가 되고, 코드를 정상 수행한다.
- Thread.isInterrupted()는 인터럽트의 상태를 변경시키기 않고, Thread.interrupted()는 인터럽트의 상태를 변경한다.

### yield
- Thread.yield() 메서드는 현재 실행 중인 스레드가 자발적으로 CPU를 양보하여 다른 스레드가 실행될 수 있도록 한다.
  - yield() 메서드를 호출한 스레드는 Runnable 상태를 유지하면서 CPU를 양보한다.
  - 즉, 이 스레드는 다시 스케줄링 큐에 들어가면서 다른 스레드에게 CPU 사용 기회를 넘기므로, 양보 받을 스레드가 딱히 없다면 자신이 다시 CPU를 점유한다.
