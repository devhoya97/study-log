# 문제
알고스팟 운영진이 모두 미로에 갇혔다. 미로는 N * M 크기이며, 총 1 * 1크기의 방으로 이루어져 있다. 미로는 빈 방 또는 벽으로 이루어져 있고, 빈 방은 자유롭게 다닐 수 있지만, 벽은 부수지 않으면 이동할 수 없다.

알고스팟 운영진은 여러명이지만, 항상 모두 같은 방에 있어야 한다. 즉, 여러 명이 다른 방에 있을 수는 없다. 어떤 방에서 이동할 수 있는 방은 상하좌우로 인접한 빈 방이다. 즉, 현재 운영진이 (x, y)에 있을 때, 이동할 수 있는 방은 (x+1, y), (x, y+1), (x-1, y), (x, y-1) 이다. 단, 미로의 밖으로 이동 할 수는 없다.

벽은 평소에는 이동할 수 없지만, 알고스팟의 무기 AOJ를 이용해 벽을 부수어 버릴 수 있다. 벽을 부수면, 빈 방과 동일한 방으로 변한다.

만약 이 문제가 알고스팟에 있다면, 운영진들은 궁극의 무기 sudo를 이용해 벽을 한 번에 다 없애버릴 수 있지만, 안타깝게도 이 문제는 Baekjoon Online Judge에 수록되어 있기 때문에, sudo를 사용할 수 없다.

현재 (1, 1)에 있는 알고스팟 운영진이 (N, M)으로 이동하려면 벽을 최소 몇 개 부수어야 하는지 구하는 프로그램을 작성하시오.

# 입력
첫째 줄에 미로의 크기를 나타내는 가로 크기 M, 세로 크기 N (1 ≤ N, M ≤ 100)이 주어진다. 다음 N개의 줄에는 미로의 상태를 나타내는 숫자 0과 1이 주어진다. 0은 빈 방을 의미하고, 1은 벽을 의미한다.

(1, 1)과 (N, M)은 항상 뚫려있다.

# 출력
첫째 줄에 알고스팟 운영진이 (N, M)으로 이동하기 위해 벽을 최소 몇 개 부수어야 하는지 출력한다.
```
예제 입력 1
3 3
011
111
110
예제 출력 1
3
예제 입력 2
4 2
0001
1000
예제 출력 2
0
예제 입력 3
6 6
001111
010000
001111
110001
011010
100010
예제 출력 3
2
```

# 풀이
- 무조건 DFS나 BFS겠거니 하고 접근했는데, 둘 다 풀이 방법이 떠오르지 않았다.
- 출발점에서 시작해 인접한 빈 방이 있는 경우, 해당 빈 방까지 도달하기 위한 최소 비용을 0으로 확정지어야 한다.
- 0으로 확정지은 방들 중에서 하나를 선택해 벽 하나를 뚫어서 새로운 빈 방을 만든다.
- 새로운 빈 방에 도달하기 위한 최소 비용은 1이고, 그 방 기준으로 또 다시 인접한 빈 방이 있는지 찾고, 그 방들도 모두 최소 비용을 1로 확정짓는다.
  - 다만, 이미 앞서서 최소 비용이 0이었던 방들의 비용을 1로 업데이트하면 안 된다.
- 위와 같이 사고 흐름을 거치다보니 다익스트라인가? 싶었다.
- 다익스트라 관점에서 생각해보니 상하좌우로 인접한 방들이 간선이 되고, 간선의 비용은 항상 0 또는 1이므로 조건을 만족한다.
- +) 반년 전 쯤 거의 똑같은 문제의 해설은 본 적이 있어서, 아리까리 했지만 그 기억이 어느정도 도움이 됐다. 그 기억없이 풀었으면 좋았을 텐데 아쉽다.
- +) Character.getNumericValue(c); 기억하자.
- +) 다른 블로그 풀이 보고 알게된 점
  - 배열을 탐색하는 것도 결국 배열 한 칸 한 칸이 노드이고 상하좌우가 엣지인 그래프라고 생각하면 된다.
  - 이 문제는 상하좌우 모두 갈 수 있기 때문에 dp 풀이가 불가능하다. dp는 아래나 오른쪽 방향으로 갈때만 가능하다.

```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        // 벽을 최소 몇 개 부숴야하는가
        // 0은 빈방, 1은 벽
        // 다익스트라를 활용해서 한칸씩...
        int m = sc.nextInt();
        int n = sc.nextInt();
        sc.nextLine();

        int[][] map = new int[n][m];
        int[][] dis = new int[n][m];
        for (int i = 0; i < n; i++) {
            String line = sc.nextLine();
            for (int j = 0; j < m; j++) {
                map[i][j] = Integer.parseInt(line.charAt(j) + ""); // Character.numericValue였나 함수 뭐였지
                dis[i][j] = Integer.MAX_VALUE;
            }
        }

        // a[0] : row값, a[1] : col값, a[2] : dis값
        PriorityQueue<int[]> pQ = new PriorityQueue<>((a, b) -> a[2] - b[2]);

        pQ.offer(new int[]{0, 0, 0});
        int[] dr = {-1, 1, 0, 0};
        int[] dc = {0, 0, -1, 1};
        while (!pQ.isEmpty()) {
            int[] cur = pQ.poll();
            int r = cur[0];
            int c = cur[1];
            int cost = cur[2];

            if (cost >= dis[r][c]) {
                continue;
            }
            // 여기서 확정지을 수 있음
            if (r == n - 1 && c == m - 1) {
                System.out.println(cost);
                return;
            }

            dis[r][c] = cost;
            for (int i = 0; i < 4; i++) {
                int nr = r + dr[i];
                int nc = c + dc[i];
                if (nr < 0 || nr >= n || nc < 0 || nc >= m) {
                    continue;
                }
                if (cost + map[nr][nc] >= dis[nr][nc]) {
                    continue;
                }
                pQ.offer(new int[]{nr, nc, cost + map[nr][nc]});
            }
        }
    }
}

```
