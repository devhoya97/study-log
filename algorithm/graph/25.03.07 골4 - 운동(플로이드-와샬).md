# 문제
V개의 마을와 E개의 도로로 구성되어 있는 도시가 있다. 도로는 마을과 마을 사이에 놓여 있으며, 일방 통행 도로이다. 마을에는 편의상 1번부터 V번까지 번호가 매겨져 있다고 하자.

당신은 도로를 따라 운동을 하기 위한 경로를 찾으려고 한다. 운동을 한 후에는 다시 시작점으로 돌아오는 것이 좋기 때문에, 우리는 사이클을 찾기를 원한다. 단, 당신은 운동을 매우 귀찮아하므로, 사이클을 이루는 도로의 길이의 합이 최소가 되도록 찾으려고 한다.

도로의 정보가 주어졌을 때, 도로의 길이의 합이 가장 작은 사이클을 찾는 프로그램을 작성하시오. 두 마을을 왕복하는 경우도 사이클에 포함됨에 주의한다.

# 입력
첫째 줄에 V와 E가 빈칸을 사이에 두고 주어진다. (2 ≤ V ≤ 400, 0 ≤ E ≤ V(V-1)) 다음 E개의 줄에는 각각 세 개의 정수 a, b, c가 주어진다. a번 마을에서 b번 마을로 가는 거리가 c인 도로가 있다는 의미이다. (a → b임에 주의) 거리는 10,000 이하의 자연수이다. (a, b) 쌍이 같은 도로가 여러 번 주어지지 않는다.

# 출력
첫째 줄에 최소 사이클의 도로 길이의 합을 출력한다. 운동 경로를 찾는 것이 불가능한 경우에는 -1을 출력한다.

```
예제 입력 1
3 4
1 2 1
3 2 1
1 3 5
2 3 2
예제 출력 1
3
```

# 풀이
- 플로이드 와샬 알고리즘을 몰라서, 처음에 삽질하다가 플로이드 와샬 알고리즘을 배우고 와서 풀었다.
  - 다익스트라를 모든 노드에 대해 돌리는 방법을 떠올렸다가 이건 아닌거 같다 싶었는데, 이것도 됐을지도?
  - 사이클이 생기는지 판단하는게 핵심이라고 생각했는데, 플로이드 와샬로 2차원배열을 완성시키면, 사이클 여부를 체크하는건 굉장히 쉽다.
- 중간노드를 거쳐서 가는 방법이 더 최선인지 확인함으로써 모든 노드에서 모든 노드로의 최단경로 완성
- exp[a][b]와 exp[b][a]가 둘 다 INF 값이 아니면, 사이클이 형성된 것으로 판단.

```java
import java.util.*;

public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int v = sc.nextInt();
        int e = sc.nextInt();

        int init = 100000000;
        int[][] exp = new int[v + 1][v + 1];
        for (int i = 1; i <= v; i++) {
            for (int j = 1; j <= v; j++) {
                if (i == j) {
                    continue;
                }
                exp[i][j] = init;
            }
        }

        for (int i = 0; i < e; i++) {
            int s = sc.nextInt();
            int end = sc.nextInt();
            int cost = sc.nextInt();
            exp[s][end] = cost;
        }

        for (int i = 1; i <= v; i++) {
            for (int j = 1; j <= v; j++) {
                if (j == i) {
                    continue;
                }
                for (int k = 1; k <= v; k++) {
                    if (k == i || j == k) {
                        continue;
                    }
                    exp[j][k] = Math.min(exp[j][k], exp[j][i] + exp[i][k]);
                }
            }
        }

        int answer = Integer.MAX_VALUE;
        for (int i = 1; i <= v; i++) {
            for (int j = i + 1; j <= v; j++) {
                if (exp[i][j] != init && exp[j][i] != init) {
                    answer = Math.min(answer, exp[i][j] + exp[j][i]);
                }
            }
        }
        if (answer == Integer.MAX_VALUE) {
            answer = -1;
        }
        System.out.println(answer);
    }
}

```

### 다익스트라 vs 플로이드 와샬
- 다익스트라는 하나의 정점에서 출발했을 때, 다른 모든 정점으로의 최단 경로를 구하는 알고리즘이다.
- 모든 정점에서 모든 정점으로의 최단 경로를 구하고 싶다면, 플로이드 와샬 알고리즘을 사용한다.
- 다익스트라는 가장 적은 비용을 하나씩 선택했다면, 플로이드 와샬은 거쳐가는 정점을 기준으로 알고리즘을 수행한다.
- 플로이드 와샬은 DP를 사용한다.
- 다익스트라는 1차원 배열만으로 해결됐지만, 플로이드 와샬은 2차원 배열이 필요하다.

### 플로이드 와샬 과정
- 간선의 정보만 이용해서 이차원 배열에 초기 비용을 셋팅한다.
- 1번 정점부터 시작해서 거쳐가는 정점으로 설정하고, 기존 비용 vs 거쳐가는 비용을 비교해서 최소값으로 갱신한다.
  - 이 때, 거쳐가는 정점이 a라고 하면, a가 포함된 테이블 값은 고칠 필요가 없다.
