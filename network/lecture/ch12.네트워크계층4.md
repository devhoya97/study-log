### ICMP (Internet Control Message Protocol)
- host와 router 사이에 네트워크레벨 정보를 주고받기 위해 사용
  - host 중 특히 sender만?
- ICMP도 결국 하나의 IP 패킷이므로 data 부분에 패킷이 유실된 이유가 8byte의 type, code 정보로 실린다.
- dest의 port까지 도달하지 못한 경우, 또는 TTL이 0이 된 경우와 같이 패킷을 drop해야 할 때, src를 배려하기 위한 차원에서 ICMP를 응답한다.
  - 예를 들어, traceroute www.google.com 하면 구글서버까지 가는데 거치는 라우터 정보들이 쭉 뜨는데, 이 때 ICMP가 사용된다.
  - IP헤더 중 TTL 필드를 1, 2, 3으로 증가시키면서 IP 패킷을 보내면, 라우터마다 TTL expired로 인해 패킷을 drop할 때마다 ICMP로 응답한다.
  - 응답된 ICMP를 통해 중간 라우터의 IP 정보를 알아낼 수 있다.

### tunneling
- IPv4 -> IPv6로 넘어가기 위한 방법
- 현실적으로 모든 라우터들을 한 순간에 교체할 수 없으므로, 두 버전의 라우터가 공존하는 과도기가 존재한다.
- IPv6를 지원하는 라우터는 IPv4도 지원할 수 있지만, IPv4를 지원하는 라우터는 IPv6를 지원할 수 없다.
  - IPv6 라우터가 IPv4 라우터에게 패킷을 보낼 때, IPv6 패킷 전체를 IPv4 datagram으로 취급하고 그 앞에 IPv4 헤더를 붙여서 보낸다.
  - 덕분에 IPv4 라우터는 해당 패킷을 해석할 수 있다.

### 라우팅 알고리즘
- 라우팅은 결국 longest prefix matching만 하면 되는데, 이를 위해선 라우팅 테이블이 필요하다.
- 라우팅 테이블을 만드는 알고리즘이 필요
- 전체 네트워크의 상황을 알고 있는지, 아니면 이웃 네트워크의 상황만 알고 있는지에 따라 사용할 수 있는 알고리즘이 나뉜다.
  - link state 알고리즘
  - distance vector 알고리즘

### link state 알고리즘
- 전체 네트워크 상황을 미리 알아야 사용할 수 있다.
  - 모든 라우터들이 자신의 link 정보를 브로드캐스트해서, 각 라우터에서 다른 라우터들의 정보를 받아서 link state를 완성해야 한다.
  - 인터넷의 모든 라우터가 브로드캐스트할 수는 없으므로, 현실적으로 하나의 도메인 내에 속한 라우터들끼리만 가능하다.
  - 네트워크 간 라우팅은 또 다른 문제이며, 이는 나중에 배울 예정
- cost 그래프를 완성시켰다면, 다익스트라 알고리즘을 적용시키면 된다.
  - 각 라우터마다 자신과 대응되는 노드의 cost = 0으로 시작해서 다익스트라 알고리즘을 돌려서 라우팅 테이블을 각자 완성할 수 있다.
  - 결국 라우터 본인으로부터 특정 노드까지 가려면 본인과 연결된 link 중 누구를 선택해야 할지 골라야 한다. 
  - 따라서 노드마다 최소 비용을 확정할 때, 바로 직전에 어느 노드에서 왔는지도 기록하면서 알고리즘을 진행해야 한다.
  - 노드마다 최소 비용을 확정할 때마다 for문을 돌면 O(n^2), PQ를 활용하면 O(nlogn)
- oscillations possible
  - 모든 라우터가 한 번에 라우팅 테이블을 업데이트하면, 라우팅 테이블을 업데이트 할 때마다 한 경로만 집중적으로 선택돼 트래픽이 몰리는 현상이 발생할 수 있다.
  - 경로를 변경했을 때 얻는 이득이 어떤 임계값을 넘어야만 경로를 변경하도록 만들면 되려나?

### distance vector 알고리즘
- 이웃한 라우터와의 네트워크 상황만 알고 있어도 사용할 수 있다.
- link state 알고리즘이나 distance vector 알고리즘이나 모두 하나의 네트워크(ex.한양대학교) 안에서 사용하는 알고리즘이다.
  - 하나의 네트워크 안에서 어떤 알고리즘을 사용할 지에 대한 자치권은 해당 네트워크 소유자에게 독립적으로 주어진다.
  - 하지만 네트워크와 네트워크 간에 어떤 알고리즘을 사용할 지는 다른 문제다. 이후 학습
- 다음 챕터에서 학습
