# 전산 기본
### OSI 7계층에 대해서 설명해주세요.
### TCP/IP 4계층에 대해서 설명해주세요.
### DNS가 무엇인가요?

### www.naver.com에 접속할때 일어나는 일에 대해 설명해주세요.
클라이언트의 웹 브라우저가 네이버 서버에게 index.html을 HTTP로 요청하는 과정을 애플리케이션 레이어 레벨에서 설명해보겠습니다.
먼저 웹브라우저는 DNS 질의를 통해 도메인 주소를 IP 주소로 변환합니다.
이후 IP 주소와 포트번호로 TCP 소켓을 생성하고 연결을 위한 시스템콜을 호출하면, 서버측에서 클라이언트를 위한 소켓을 하나 할당합니다. 
이 때 TCP 연결이 이루어지는 구체적인 과정은 웹브라우저와 서버애플리케이션 입장에서는 신경쓸 요소가 아닙니다. 
이들의 입장에서는 application layer의 아랫단이 어떻게 동작하는 지는 이해할 필요가 없고, 추상화된 API를 제공받아 활용할 뿐이기 때문입니다.
소켓 연결이 완료되면, 웹브라우저는 소켓에 대고 미리 생성해둔 HTTP 메시지를 write() 하고 서버의 HTTP 응답메시지를 읽기 위해 소켓에 read()를 호출합니다.
서버애플리케이션도 마찬가지로 소켓에 read()를 호출해 HTTP 요청 메시지를 받으면, 톰캣과 같은 웹서버가 HTTP 요청을 파싱해 URL에 대응하는 서블릿을 호출합니다.
스프링애플리케이션이라면 DispatcherServlet이 호출될 것입니다. 여러 서버단 로직을 거쳐 톰캣은 HTTP 응답 메시지를 만들고
소켓에 대고 write()를 호출합니다. (명확하게는 소켓으로부터 얻어낸 InputStream, OutputStream을 이용)
그럼 클라이언트쪽 웹브라우저가 호출한 소켓의 read()가 드디어 응답하여 index.html을 HTTP response body로부터 받을 수 있게 됩니다.

<br> 
지피티가 보완한 버전 : HTTP 요청이라고 가정하고, 클라이언트의 웹 브라우저가 네이버 서버에게 index.html을 요청하는 과정을 애플리케이션 레벨에서 설명해보겠습니다.

먼저 웹브라우저는 로컬 DNS 캐시를 확인한 후, 캐시에 없으면 DNS 질의를 수행하여 도메인 주소를 IP 주소로 변환합니다.
이후, 웹브라우저는 변환된 IP 주소와 포트 번호를 사용하여 TCP 소켓을 생성하고 연결을 시도합니다.
이 과정에서 TCP 3-Way Handshake 및 HTTPS라면 TLS Handshake도 수행됩니다.

연결이 완료되면, 웹브라우저는 소켓에 대고 미리 생성한 HTTP 요청 메시지를 write() 합니다.
이때, OS 네트워크 스택을 거쳐 메시지가 전송되며, 서버에서는 대기 중인 데몬 스레드가 새로운 소켓을 할당하여 클라이언트와 통신할 준비를 합니다.

서버의 웹 서버(Tomcat과 같은)가 소켓을 통해 요청을 수신하면, HTTP 요청을 파싱하여 적절한 서블릿(또는 Spring 애플리케이션에서는 DispatcherServlet)을 호출합니다.
DispatcherServlet은 URL 매핑을 기반으로 적절한 컨트롤러 메서드를 실행하고, 필요한 서비스 로직을 수행한 후 HTTP 응답을 생성합니다.

서버는 응답 메시지를 다시 소켓을 통해 write()하며, 클라이언트 웹브라우저의 read() 호출이 응답하여 index.html을 전달받습니다.
이후, 브라우저는 HTML을 해석하고 추가적인 CSS, JS, 이미지 요청을 수행하며 페이지를 렌더링합니다.

### 도메인 이름으로 실제 IP를 어떻게 찾을 수 있는지 흐름을 설명해 주세요.
www.naver.com 을 검색하는 과정에서 호스트는 먼저 DNS 캐시 역할을 수행하는 로컬 DNS 서버에 질의하는데, 여기서 캐시미스가 난 상황을 가정해보겠습니다.
결국 naver.com 도메인을 관리하는 authoritative DNS 서버까지 가야만 해당 도메인에서 www라는 이름을 가진 컴퓨터의 IP 주소를 알 수 있는데,
계층 구조를 타고 찾아가야 합니다. 먼저 루트 DNS 서버에게 접근해 .com 도메인을 관리하는 TLD 서버의 IP 주소를 찾아냅니다.
그리고 .com 도메인을 관리하는 DNS 서버에게 접근해 naver.com 도메인을 관리하는 authoritative DNS 서버의 IP 주소를 찾아냅니다.
그리고 naver.com 도메인을 관리하는 authoritative DNS에 접근해 도메인 내 www 이름을 가진 컴퓨터의 IP 주소를 반환받습니다.
위 복잡한 DNS 질의 과정은 로컬 DNS 서버가 수행해주고, 실제 호스트는 마치 로컬 DNS 서버가 IP를 바로 알아온 것과 다름없이 응답을 받습니다.

<br>
예를 들어 .com 도메인을 관리하는 DNS 서버에서 naver.com 도메인을 관리하는 authoritative DNS 서버의 도메인명을 굳이 NS타입으로 저장하는 이유가 뭘까? 
그냥 바로 A 타입으로 IP 주소를 맵핑해주면 되는거 아닌가?

### DNS가 UDP를 사용하는 이유를 설명해주세요.
DNS는 HTTP 메시지를 전달하기 위한 사전작업에 불과하므로 충분히 빨라야 하는데, 심지어 메시지의 크기도 굉장히 작습니다.
따라서 패킷이 유실될 가능성도 HTTP 메시지에 비해 희박하고, 유실되더라도 재요청 오버헤드가 비교적 작기 때문에
TCP가 아닌 UDP를 사용합니다.

### 꼬리질문. 메시지의 크기가 작을수록 패킷이 유실될 가능성도 작아지는 이유가 무엇인가요?
우선 패킷 사이즈가 MTU보다 크면 여러 개의 패킷으로 나뉘는데, DNS 패킷의 경우 MTU를 초과할 가능성이 매우 낮습니다.
또한 라우터를 거치면서 큐에 들어갈 때, 큐가 고정된 사이즈로 엔트리를 관리하지 않는다면, 하나의 패킷이더라도 큰 사이즈의 패킷보다 작은 사이즈의 패킷이 드랍될 가능성이 낮아질 것 같습니다.
마지막으로 데이터 전송 과정에서 bit error가 발생할 가능성도 작습니다.

### 유니캐스트, 멀티캐스트, 브로드캐스트란?

---
# TCP/UDP
### TCP와 UDP의 차이에 대해서 설명해 주세요.
TCP는 연결지향의 신뢰성 있는 프로토콜이기 때문에 연결을 맺고 끊기 위한 handshake 과정을 필요로 하고,
패킷의 순서가 잘못되거나 유실됐을 때 이를 재전송하는 매커니즘을 갖고 있습니다.
반면 UDP는 비연결지향이며 신뢰성을 보장하지 않는 프로토콜이기 때문에 패킷의 순서를 보장하지 않고 중간에 패킷이 유실되어도 책임지지 않습니다.
하지만 그만큼 패킷의 헤더의 크기가 작고, 속도가 빠르다는 이점이 있습니다.

### 3-way hand shake, 4-way hand shake 흐름에 대해서 설명해주세요.
TCP 연결을 위해 3-way handshake가 필요합니다. 먼저 클라이언트가 서버에게 SYN을 보내고, 서버는 이에 ACK와 함께 SYN을 보냅니다.
클라이언트는 이에 ACK를 보냄으로써 연결이 완료되고, 마지막 ACK와 함께 데이터도 보낼 수 있습니다.
TCP 연결종료를 위해 4-way handshake가 필요합니다. 먼저 클라이언트가 서버에게 FIN을 보내고, 서버는 ACK를 답하지만, 
이후 바로 FIN을 보내는 것이 아니라 일단 더 보내야할 데이터가 있으면 계속 보냅니다. 
서버가 모든 데이터 전송을 완료했으면 FIN을 보내고, 클라이언트는 이에 대해 ACK를 보냅니다.
이 때 주목할만한 점은 클라이언트가 ACK를 보내자마자 TCP 연결이 끊기는게 아니라, 어느정도 유휴시간을 둔다는 점입니다.
그 이유는 클라이언트가 보낸 ACK가 서버에게 가다가 유실될 경우, 서버가 다시 FIN을 보낼 가능성이 있기 때문입니다.

### TCP 헤더에 대해서 설명해 주세요.
TCP는 애플리케이션 계층으로부터 받은 메시지에 송수신측 포트번호를 포함한 각종 정보들을 덧붙이는데, 이 정보들을 TCP 헤더라고 합니다.
송신하는 입장에서 순서를 나타내기 위한 sequence number, 수신하는 입장에서 순서를 나타내기 위한 acknowledgement number,
SYN, ACK, FIN과 같은 각종 flag, 흐름제어를 위한 window size, 오류 검출을 위한 checksum 등이 있습니다.

### MTU가 무엇인가요?
네트워크 장비마다 한 번에 보낼 수 있는 데이터의 최대 전송 단위가 각각 다릅니다. 
이를 MTU라고 부르며, 패킷의 크기가 MTU를 넘어가면 여러 개의 패킷으로 분할됩니다.
패킷이 분할되면, Identification, Flags, Fragment Offset 필드를 사용하여 패킷이 분할되었음을 알리고, 
이 필드들을 활용하면 분할된 패킷들을 올바르게 재조합할 수 있습니다.

### 꼬리질문. MTU와 관련된 IP 헤더가 각각 무엇을 의미하는지 설명해주세요.
하나의 패킷에서 여러 패킷으로 분할되면, 해당 패킷들은 모두 같은 Identification 값을 갖습니다.
또한 Fragment Offset을 통해 자신이 분할된 패킷 중 몇 번째인지 알림으로써 수신측에서 패킷들을 재조합할 수 있고,
Flags를 통해 자신이 분할된 패킷 중 마지막 패킷인지 아닌지 알림으로써, 분할되었던 패킷들이 모두 도착했는지 판단할 수 있습니다.

### Go-Back-N 방식과 Selective Repeat 방식의 차이점에 대해 설명해주세요.
Go-Back-N 방식은 window 사이즈만큼 패킷을 보내고 cumulative ack를 받을 때마다, 그만큼 윈도우를 오른쪽으로 이동시키는 방식입니다.
n번 패킷에서 타임아웃이 발생한다면, 해당 패킷을 포함한 윈도우 전체 데이터를 재전송해야 하므로, sender는 윈도우 패킷들을 버퍼에 저장해둬야 합니다.
Selective Repeat 방식은 sender 뿐만 아니라 receiver에 버퍼를 두어 순서에 맞게 들어오지 않은 패킷이더라도 버퍼에 저장합니다.
sender는 윈도우 내의 모든 패킷에 대해 타이머를 두고, 타임아웃이 발생한 패킷만 재전송합니다.
 
### 꼬리질문. window size가 n일 때, sequence number는 최소 몇이어야 중복 패킷을 검출할 수 있나요?
sequence number가 최소 2n이면 중복 패킷을 검출할 수 있습니다.
예를 들어 window size = 3이여서 receiver에서 0,1,2 번의 패킷을 모두 받고 ACK를 보냈는데, 모든 ACK가 분실될 경우
이 때 receiver는 sequence number가 0~5까지 있다면 3,4,5를 기다리고 있고 sender는 0,1,2를 재전송해도
receiver 입장에서는 이 패킷들이 중복전송됐다는 사실을 인지할 수 있습니다.
하지만 sequence number가 0~4까지만 있다면, receiver는 3,4,0을 기다리고 있을 것이고 sender가 보낸 0이 중복패킷이라는 사실을 알아챌 수 없습니다.

### 흐름제어에 대해 설명해주세요.
흐름 제어는 sender가 receiver 버퍼의 현재 상태를 고려해서 전송할 데이터의 양을 조절하는 방법입니다.
TCP 헤더에는 receive 버퍼 관련 필드가 있어서, sender 입장에서는 얼마나 보낼 수 있는지 명확하게 알 수 있습니다. 

### 혼잡제어에 대해 설명해주세요.
혼잡 제어는 sender가 네트워크의 혼잡 상황을 고려해서 전송할 데이터의 양을 조절하는 방법입니다.
처음에는 네트워크의 상황을 모르므로 slow start로 윈도우 사이즈를 1부터 시작하지만, 윈도우의 크기는 exponential하게 증가시킵니다.
이 때 threshold 지점에 도달하면, 그 때부터는 linear하게 윈도우 크기를 증가시킵니다.
네트워크가 막혔을 때, 3 duplicated ack 또는 time out이 발생하는데, 각각에 따라 sender의 대처가 달라집니다.
3 duplicated ack가 발생했다면, 특정 패킷 하나만 유실된 것으로 판단합니다. 
따라서 threshold 값을 패킷 유실이 감지된 지점의 1/2 값으로 변경하고, threshold 값부터 시작해 linear하게 윈도우 크기를 다시 증가시킵니다.
반면 time out이 발생하면 네트워크가 매우 혼잡해 전송한 모든 패킷이 유실된 것으로 판단합니다.
따라서 threshold 값을 패킷 유실이 감지된 지점의 1/2 값으로 변경하되, 1부터 다시 시작합니다.

### 오류제어에 대해 설명해주세요.

### TCP는 Go-Back-N 방식과 Selective Repeat 방식의 장점만 혼합해서 사용하는걸로 이해했는데, 만약 10번 패킷에 대해 3 dup ACK가 오면, 11, 12번 패킷은 잘 도착했더라도, 10번 패킷부터 다시 보내야되나?
아 10번 패킷만 다시 보내면, receiver에서 다음으로 받아야 하는 sequence number를 알려주니까, 그거 보고 다시 보내기 시작하는 듯

---
# IP

### IPv4와 서브넷마스크에 대해 설명해주세요.
IPv4는 네트워크 인터페이스를 유일하게 구분하기 위한 32bit 값입니다.
32bit는 네트워크 ID와 호스트 ID로 나뉘고, 서브넷마스크가 네트워크 ID의 크기를 결정합니다.
예를 들어 127.0.0.1/24에서 127.0.0이 네트워크 ID이고 1이 호스트 ID이며, 이 서브넷에는 최대 256개의 호스트가 존재할 수 있습니다.

### 꼬리질문. 네트워크 ID는 왜 필요한건가요?
라우팅테이블에서 사용하는 엔트리의 수를 최소화하기 위해서입니다. 
라우터는 input link로 들어온 IP 패킷을 적절한 output link로 포워딩하기 위해 라우팅테이블을 사용합니다.
이 때 하나의 기관에서 사용하는 IP들이 네트워크 ID로 묶여있지 않고 중구난방의 값을 가진다면, 
호스트 하나당 라우팅테이블의 엔트리 하나가 필요하므로, 라우팅테이블 엔트리 크기가 과도하게 커집니다.
네트워크 ID로 이들을 묶어서 다루면 라우팅테이블 엔트리 수를 기하급수적으로 줄일 수 있습니다.

### Longest Prefix Match Forwarding에 대해 설명해주세요.
CIDR을 사용하면 특정 IP가 라우팅테이블의 여러 엔트리와 매핑될 수 있습니다.
이 때, 매핑된 여러 엔트리 중 왼쪽에서부터 카운팅해서 가장 길게 IP 값이 맵핑되는 엔트리를 선택하는 것이 Longest Prefix Match Forwarding입니다.

### NAT에 대해 설명해주세요.
하나의 LAN 내에서 사용하는 사설 IP는 LAN내에서는 유일하지만, WAN에서는 유일하지 않는 문제를 해소하기 위해 LAN과 WAN을 연결해주는 작업을 NAT라고 합니다. 
IPv4의 경우 32bit로는 40억개 정도의 네트워크 인터페이스밖에 유일하게 구별하지 못하므로, 전 세계의 IP 수요를 감당할 수 없습니다.
따라서 NAT 혼자서 공인 IP를 할당받고, LAN 내의 네트워크 인터페이스들은 사설 IP를 할당받습니다.
LAN에서 WAN으로 나가는 요청의 경우 NAT는 요청을 보낸 장치의 사설 IP 주소와 포트번호를 공인 IP 주소와 새로운 포트 번호로 매핑하여 내보내고,
WAN에서 LAN으로 들어오는 응답의 경우 공인 IP주소와 포트번호를 사설 IP 주소와 포트번호로 변환하여 LAN 내의 장치를 찾습니다.
이는 당장 IP 고갈 문제를 해결해주긴 하지만, 네트워크 계층에서 전송 계층의 포트번호를 사용한다는 점에서 완전한 해결책이라 보기는 어렵습니다.

### 꼬리질문. 네트워크 계층에서 전송 계층의 포트 번호를 사용하면 어떤 문제가 있나요?
하나의 NAT에 속한 여러 장치가 동시에 웹 서버를 띄울 수 없습니다.
웹 서버는 일반적으로 80포트를 사용하도록 약속되어 있는데, WAN에서 NAT로 들어오는 요청이 NAT의 공인 IP 주소 + 80 포트라면,
NAT 입장에서는 이를 LAN에서 하나의 사설 IP + 포트 번호로만 맵핑해줄 수 있기 때문입니다.
이는 근본적으로 포트 번호를 용도에 맞게 사용하고 있지 않기 때문에 발생한 문제점이며 layer violation이 발생했다고 볼 수 있습니다.

# HTTP
### HTTP 프로토콜에 대해서 아는대로 말해주세요.

### HTTP와 HTTPS 의 차이는 무엇인가요?
HTTPS는 HTTP를 기본적으로 사용하되 SSL을 함께 사용하는 방식입니다.
대칭키를 사용해서 HTTP 메시지를 암호화, 복호화하는 방식으로 이루어지는데, 클라이언트와 서버가 대칭키를 교환하는 과정은
서버가 가지고 있는 개인키와 공개키를 활용한 비대칭키 방식으로 이루어져 대칭키를 포함한 메시지가 탈취돼도
개인키를 가지고 있는 서버만이 이를 복호화할 수 있도록 함으로써 네트워크 과정에서의 보안을 안전하게 만들 수 있습니다.
(클라이언트가 대칭키를 생성하고, 서버의 공개키로 이를 암호화해서 서버에게 공유하는 방식인 듯)
또한 제3자인 CA의 도움을 받아서 서버는 CA의 개인키로 암호화된 인증서를 발급받게 되고, 클라이언트에게 인증서를 보내주면,
클라이언트는 CA의 공개키를 활용해 이를 복호화함으로써 서버가 CA의 인증을 받았다는 사실을 확인하고 안전한 서버임을 보장받을 수 있습니다.

### HTTP Method 종류 및 역할
### HTTP 1.0과 1.1의 차이는 무엇인가요?
### HTTP2와 그 특징에 대해서 설명해 주세요.
### HTTP 헤더의 구조에 대해서 설명해 주세요.
### keep-alive 헤더에 대해서 설명해 주세요.
### HTTP GET과 POST의 차이는 무엇인가요?
### 쿠키와 세션에 대해서 설명해 주세요.

### PUT과 PATCH의 차이에 대해 설명해주세요.
PUT은 특정 자원의 모든 정보를 수정하기 위해 사용되고, PATCH는 특정 자원의 일부 정보만을 수정하기 위해 사용됩니다.

---
# 웹
### www.google.com에 접속할때 일어나는 일
### 웹브라우저에서 서버로 요청했을 때, 흐름을 설명해주세요.
### CORS란 무엇인가요?
### 웹 서버와 웹 어플리케이션 서버(WAS)의 차이는 무엇인가요?
### REST ful
### API Gateway란 무엇인가요?
### API Gateway가 다운되면 모든 API를 사용 못할지도 모르는데, 어떤 방안을 마련해야 할까요?

### API에 대해 설명해주세요.
애플리케이션 프로그래밍 인터페이스로서, 애플리케이션과 애플리케이션이 서로 소통할 수 있도록 도와주는 인터페이스입니다.
클라이언트 - 서버 모델을 기반으로 동작하며, 클라이언트 입장에서 API를 사용하면 특정 기능을 직접 구현하지 않고도 활용할 수 있습니다.

### REST API에 대해 설명해주세요.
API 개발자는 여러 아키텍쳐를 사용해 API를 설계할 수 있는데, 이 때 REST 아키텍쳐 스타일을 따르는 API를 REST API라고 합니다.
이 때 HTTP는 REST API의 필수 요소는 아니지만, REST API의 조건을 구현하기 용이하기 때문에 HTTP가 주로 사용됩니다.
HTTP에서 REST란 URI로 자원을 명시하고, HTTP Method를 통해 자원에 대한 행위를 표현하며, HTTP Message Pay Load를 통해 자원에 대한 행위의 내용을 표현합니다.
REST API에서는 메서드와 URI만으로도 어떤 요청인지 명확히 나타낼 수 있으므로 여러 개발자들이 협업할 때 효과적이여서 널리 사용되고 있습니다.
REST API의 특징으로는 서버 - 클라이언트 구조, stateless, cacheable, layered system, uniform interface가 있고
특히 stateless 특성 덕분에 서버의 scale out이 매우 편리해집니다.

---
# 기타
### nagle 알고리즘에 대해 설명하세요.
### TLS에 패킷 프토토콜의 대해 설명하세요
### TLS
### 네트워크 Layer 라우팅 알고리즘
### SNI 필드 차단
### 흐름제어 / 혼잡제어 / 오류제어
### 로드 밸런서 / 로드 밸런싱은 무엇인지 설명하세요.
### WebRTC
