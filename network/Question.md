# 전산 기본
### OSI 7계층에 대해서 설명해주세요.
### TCP/IP 4계층에 대해서 설명해주세요.
### DNS가 무엇인가요?

### www.naver.com에 접속할때 일어나는 일에 대해 설명해주세요.
클라이언트의 웹 브라우저가 네이버 서버에게 index.html을 HTTP로 요청하는 과정을 애플리케이션 레이어 레벨에서 설명해보겠습니다.
먼저 웹브라우저는 DNS 질의를 통해 도메인 주소를 IP 주소로 변환합니다.
이후 IP 주소와 포트번호로 TCP 소켓을 생성하고 연결을 위한 시스템콜을 호출하면, 서버측에서 클라이언트를 위한 소켓을 하나 할당합니다. 
이 때 TCP 연결이 이루어지는 구체적인 과정은 웹브라우저와 서버애플리케이션 입장에서는 신경쓸 요소가 아닙니다. 
이들의 입장에서는 application layer의 아랫단이 어떻게 동작하는 지는 이해할 필요가 없고, 추상화된 API를 제공받아 활용할 뿐이기 때문입니다.
소켓 연결이 완료되면, 웹브라우저는 소켓에 대고 미리 생성해둔 HTTP 메시지를 write() 하고 서버의 HTTP 응답메시지를 읽기 위해 소켓에 read()를 호출합니다.
서버애플리케이션도 마찬가지로 소켓에 read()를 호출해 HTTP 요청 메시지를 받으면, 톰캣과 같은 웹서버가 HTTP 요청을 파싱해 URL에 대응하는 서블릿을 호출합니다.
스프링애플리케이션이라면 DispatcherServlet이 호출될 것입니다. 여러 서버단 로직을 거쳐 톰캣은 HTTP 응답 메시지를 만들고
소켓에 대고 write()를 호출합니다. (명확하게는 소켓으로부터 얻어낸 InputStream, OutputStream을 이용)
그럼 클라이언트쪽 웹브라우저가 호출한 소켓의 read()가 드디어 응답하여 index.html을 HTTP response body로부터 받을 수 있게 됩니다.

<br> 
지피티가 보완한 버전 : HTTP 요청이라고 가정하고, 클라이언트의 웹 브라우저가 네이버 서버에게 index.html을 요청하는 과정을 애플리케이션 레벨에서 설명해보겠습니다.

먼저 웹브라우저는 로컬 DNS 캐시를 확인한 후, 캐시에 없으면 DNS 질의를 수행하여 도메인 주소를 IP 주소로 변환합니다.
이후, 웹브라우저는 변환된 IP 주소와 포트 번호를 사용하여 TCP 소켓을 생성하고 연결을 시도합니다.
이 과정에서 TCP 3-Way Handshake 및 HTTPS라면 TLS Handshake도 수행됩니다.

연결이 완료되면, 웹브라우저는 소켓에 대고 미리 생성한 HTTP 요청 메시지를 write() 합니다.
이때, OS 네트워크 스택을 거쳐 메시지가 전송되며, 서버에서는 대기 중인 데몬 스레드가 새로운 소켓을 할당하여 클라이언트와 통신할 준비를 합니다.

서버의 웹 서버(Tomcat과 같은)가 소켓을 통해 요청을 수신하면, HTTP 요청을 파싱하여 적절한 서블릿(또는 Spring 애플리케이션에서는 DispatcherServlet)을 호출합니다.
DispatcherServlet은 URL 매핑을 기반으로 적절한 컨트롤러 메서드를 실행하고, 필요한 서비스 로직을 수행한 후 HTTP 응답을 생성합니다.

서버는 응답 메시지를 다시 소켓을 통해 write()하며, 클라이언트 웹브라우저의 read() 호출이 응답하여 index.html을 전달받습니다.
이후, 브라우저는 HTML을 해석하고 추가적인 CSS, JS, 이미지 요청을 수행하며 페이지를 렌더링합니다.

### 도메인 이름으로 실제 IP를 어떻게 찾을 수 있는지 흐름을 설명해 주세요.
www.naver.com 을 검색하는 과정에서 호스트는 먼저 DNS 캐시 역할을 수행하는 로컬 DNS 서버에 질의하는데, 여기서 캐시미스가 난 상황을 가정해보겠습니다.
결국 naver.com 도메인을 관리하는 authoritative DNS 서버까지 가야만 해당 도메인에서 www라는 이름을 가진 컴퓨터의 IP 주소를 알 수 있는데,
계층 구조를 타고 찾아가야 합니다. 먼저 루트 DNS 서버에게 접근해 .com 도메인을 관리하는 TLD 서버의 IP 주소를 찾아냅니다.
그리고 .com 도메인을 관리하는 DNS 서버에게 접근해 naver.com 도메인을 관리하는 authoritative DNS 서버의 IP 주소를 찾아냅니다.
그리고 naver.com 도메인을 관리하는 authoritative DNS에 접근해 도메인 내 www 이름을 가진 컴퓨터의 IP 주소를 반환받습니다.
위 복잡한 DNS 질의 과정은 로컬 DNS 서버가 수행해주고, 실제 호스트는 마치 로컬 DNS 서버가 IP를 바로 알아온 것과 다름없이 응답을 받습니다.

<br>
예를 들어 .com 도메인을 관리하는 DNS 서버에서 naver.com 도메인을 관리하는 authoritative DNS 서버의 도메인명을 굳이 NS타입으로 저장하는 이유가 뭘까? 
그냥 바로 A 타입으로 IP 주소를 맵핑해주면 되는거 아닌가?

### DNS가 UDP를 사용하는 이유를 설명해주세요.
DNS는 HTTP 메시지를 전달하기 위한 사전작업에 불과하므로 충분히 빨라야 하는데, 심지어 메시지의 크기도 굉장히 작습니다.
따라서 패킷이 유실될 가능성도 HTTP 메시지에 비해 희박하고, 유실되더라도 재요청 오버헤드가 비교적 작기 때문에
TCP가 아닌 UDP를 사용합니다.

### 꼬리질문. 메시지의 크기가 작을수록 패킷이 유실될 가능성도 작아지는 이유가 무엇인가요?
우선 패킷 사이즈가 MTU보다 크면 여러 개의 패킷으로 나뉘는데, DNS 패킷의 경우 MTU를 초과할 가능성이 매우 낮습니다.
또한 라우터를 거치면서 큐에 들어갈 때, 큐가 고정된 사이즈로 엔트리를 관리하지 않는다면, 하나의 패킷이더라도 큰 사이즈의 패킷보다 작은 사이즈의 패킷이 드랍될 가능성이 낮아질 것 같습니다.
마지막으로 데이터 전송 과정에서 bit error가 발생할 가능성도 작습니다.

### 유니캐스트, 멀티캐스트, 브로드캐스트란?

# TCP/UDP
### TCP와 UDP의 차이에 대해서 설명해 주세요.
TCP는 연결지향이기 때문에 패킷의 순서가 잘못되거나 유실됐을 때 이를 재전송하는 매커니즘을 갖고 있지만
UDP는 비연결지향이기 때문에 패킷의 순서를 보장하지 않고 중간에 패킷이 유실되어도 책임지지 않습니다.
TCP는 연결을 맺고 끊기 위한 handshake 과정을 필요로 하지만 UDP는 필요하지 않습니다.
다만 UDP도 전송계층의 프로토콜이기 때문에 메시지에 port 번호와 error detection을 위한 체크섬 헤더는 추가됩니다. 

### 3-way hand shake, 4-way hand shake 흐름에 대해서 설명해주세요.
TCP 연결을 위해 3-way handshake가 필요합니다. 먼저 클라이언트가 서버에게 SYN을 보내고, 서버는 이에 ACK와 함께 SYN을 보냅니다.
클라이언트는 이에 ACK를 보냄으로써 연결이 완료되고, 마지막 ACK와 함께 데이터도 보낼 수 있습니다.
TCP 연결종료를 위해 4-way handshake가 필요합니다. 먼저 클라이언트가 서버에게 FIN을 보내고, 서버는 ACK를 답하지만, 
이후 바로 FIN을 보내는 것이 아니라 일단 더 보내야할 데이터가 있으면 계속 보냅니다. 
서버가 모든 데이터 전송을 완료했으면 FIN을 보내고, 클라이언트는 이에 대해 ACK를 보냅니다.
이 때 재밌는 점은 클라이언트가 ACK를 보내자마자 TCP 연결이 끊기는게 아니라, 어느정도 유휴시간을 둔다는 점입니다.
그 이유는 클라이언트가 보낸 ACK가 서버에게 가다가 유실될 경우, 서버가 다시 FIN을 보낼 가능성이 있기 때문입니다.

### TCP 헤더에 대해서 설명해 주세요.
TCP는 애플리케이션 계층으로부터 받은 메시지에 송수신측 포트번호를 포함한 각종 정보들을 덧붙이는데, 이 정보들을 TCP 헤더라고 합니다.
송신하는 입장에서 순서를 나타내기 위한 sequence number, 수신하는 입장에서 순서를 나타내기 위한 acknowledgement number,
SYN, ACK, FIN과 같은 각종 flag, 흐름제어를 위한 window size, 오류 검출을 위한 checksum 등이 있습니다.

### MTU가 무엇인가요?
네트워크 장비마다 한 번에 보낼 수 있는 데이터의 최대 전송 단위가 각각 다릅니다. 
이를 MTU라고 부르며, 패킷의 크기가 MTU를 넘어가면 여러 개의 패킷으로 분할됩니다.
패킷이 MTU를 초과하여 분할되면, Identification, Flags, Fragment Offset 필드를 사용하여 패킷이 분할되었음을 알리고, 
이 필드들을 활용하면 분할된 패킷들을 올바르게 재조합할 수 있습니다.

### 꼬리질문. MTU와 관련된 IP 헤더가 각각 무엇을 의미하는지 설명해주세요.
하나의 패킷에서 여러 패킷으로 분할되면, 해당 패킷들은 모두 같은 Identification 값을 갖습니다.
또한 Fragment Offset을 통해 자신이 분할된 패킷 중 몇 번째인지 알림으로써 수신측에서 패킷들을 재조합할 수 있고,
Flags를 통해 자신이 분할된 패킷 중 마지막 패킷인지 아닌지 알림으로써, 분할되었던 패킷들이 모두 도착했는지 판단할 수 있습니다.

### 흐름제어에 대해 설명해주세요.


### 혼잡제어에 대해 설명해주세요.

### 오류제어에 대해 설명해주세요.

# HTTP
### HTTP 프로토콜에 대해서 아는대로 말해주세요.

### HTTP와 HTTPS 의 차이는 무엇인가요?
HTTPS는 HTTP를 기본적으로 사용하되 SSL을 함께 사용하는 방식입니다.
대칭키를 사용해서 HTTP 메시지를 암호화, 복호화하는 방식으로 이루어지는데, 클라이언트와 서버가 대칭키를 교환하는 과정은
서버가 가지고 있는 개인키와 공개키를 활용한 비대칭키 방식으로 이루어져 대칭키를 포함한 메시지가 탈취돼도
개인키를 가지고 있는 서버만이 이를 복호화할 수 있도록 함으로써 네트워크 과정에서의 보안을 안전하게 만들 수 있습니다.
(클라이언트가 대칭키를 생성하고, 서버의 공개키로 이를 암호화해서 서버에게 공유하는 방식인 듯)
또한 제3자인 CA의 도움을 받아서 서버는 CA의 개인키로 암호화된 인증서를 발급받게 되고, 클라이언트에게 인증서를 보내주면,
클라이언트는 CA의 공개키를 활용해 이를 복호화함으로써 서버가 CA의 인증을 받았다는 사실을 확인하고 안전한 서버임을 보장받을 수 있습니다.

### HTTP Method 종류 및 역할
### HTTP 1.0과 1.1의 차이는 무엇인가요?
### HTTP2와 그 특징에 대해서 설명해 주세요.
### HTTP 헤더의 구조에 대해서 설명해 주세요.
### keep-alive 헤더에 대해서 설명해 주세요.
### HTTP GET과 POST의 차이는 무엇인가요?
### 쿠키와 세션에 대해서 설명해 주세요.

# 웹
### www.google.com에 접속할때 일어나는 일
### 웹브라우저에서 서버로 요청했을 때, 흐름을 설명해주세요.
### CORS란 무엇인가요?
### 웹 서버와 웹 어플리케이션 서버(WAS)의 차이는 무엇인가요?
### REST API에 대해서 설명해 주세요.
### REST ful
### API Gateway란 무엇인가요?
### API Gateway가 다운되면 모든 API를 사용 못할지도 모르는데, 어떤 방안을 마련해야 할까요?

# 기타
### nagle 알고리즘에 대해 설명하세요.
### TLS에 패킷 프토토콜의 대해 설명하세요
### TLS
### 네트워크 Layer 라우팅 알고리즘
### SNI 필드 차단
### 흐름제어 / 혼잡제어 / 오류제어
### 로드 밸런서 / 로드 밸런싱은 무엇인지 설명하세요.
### WebRTC
