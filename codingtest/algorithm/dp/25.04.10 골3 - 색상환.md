# 25.05.01 다시 풀고 틀림. 다시 풀 것
- 아이디어가 또 안 떠올랐음
- 점화식을 세울 때, 작은 값은 이미 구해졌다고 생각하고 접근하자.
  - 그렇다고 항상 recursive + memoization은 아니다.

# 문제
색을 표현하는 기본 요소를 이용하여 표시할 수 있는 모든 색 중에서 대표적인 색을 고리 모양으로 연결하여 나타낸 것을 색상환이라고 한다. 미국의 화가 먼셀(Munsell)이 교육용으로 고안한 20색상환이 널리 알려져 있다. 아래 그림은 먼셀의 20색상환을 보여준다.

그림 1. 먼셀의 20색상환

색상환에서 인접한 두 색은 비슷하여 언뜻 보면 구별하기 어렵다. 위 그림의 20색상환에서 다홍은 빨강과 인접하고 또 주황과도 인접하다. 풀색은 연두, 녹색과 인접하다. 시각적 대비 효과를 얻기 위하여 인접한 두 색을 동시에 사용하지 않기로 한다.

주어진 색상환에서 시각적 대비 효과를 얻기 위하여 서로 이웃하지 않은 색들을 선택하는 경우의 수를 생각해 보자.  먼셀의 20색상환에서 시각적 대비 효과를 얻을 수 있게 10개의 색을 선택하는 경우의 수는 2이지만, 시각적 대비 효과를 얻을 수 있게 11개 이상의 색을 선택할 수 없으므로 이 경우의 수는 0이다.

주어진 정수 N과 K에 대하여, N개의 색으로 구성되어 있는 색상환 (N색상환)에서 어떤 인접한 두 색도 동시에 선택하지 않으면서 서로 다른 K개의 색을 선택하는 경우의 수를 구하는 프로그램을 작성하시오.

# 입력
입력 파일의 첫째 줄에 색상환에 포함된 색의 개수를 나타내는 양의 정수 N(4 ≤ N ≤ 1,000)이 주어지고, 둘째 줄에 N색상환에서 선택할 색의 개수 K(1 ≤ K ≤ N)가 주어진다.

# 출력
첫째 줄에 N색상환에서 어떤 인접한 두 색도 동시에 선택하지 않고 K개의 색을 고를 수 있는 경우의 수를 1,000,000,003 (10억 3) 으로 나눈 나머지를 출력한다.
```
예제 입력 1
4
2
예제 출력 1
2
```

# 풀이
- 못 품...
  - 특정 색을 선택했을 때, 해당 색 + 양 옆을 제외한 구간에 대해 k-1개를 선택하면 되는 식으로 top-down 식으로 생각하려 시도했음
  - recursive + memoization에 꽂혀서 처음부터 top-down을 시도하는 것 같은데, dp는 기본적으로 작은 결과를 활용해 더 큰 결과를 만들어내는 것임을 명심하자
    - 일단 어떻게든 점화식을 세워보려고 노력하는게 순서가 맞는 것 같다.
    - 일차원 dp로 점화식을 세우기 도전해보고, 안 될 것 같으면 이차원 dp로 점화식 세우기를 도전해보자.
  - 원 특성상 맨 앞과 맨 뒤가 붙어있어서 이거 처리하는 방법이 떠오르지 않는다.
- 블로그 풀이
  - DP[n][k]=DP[n−2][k−1]+DP[n−1][k]
  - 여기서 DP의 경우 선형적으로 나열된 n개의 색상환 중에서 인접하지 않은 색 k를 결정하는 경우라고 생각할 수 있습니다.
  - 이때, 가장 문제는 1번째 색을 선택했다고 했을 경우 N번째 색을 선택할 수 없습니다.
  - 그리고 1번째 색을 선택하지 않았다면, 선형적으로 구성되어 있을 때와 다를게 없습니다.
  - 따라서, 1번째 색을 선택하는 경우에는 선택할 수 있는 색상에서 1번째 색, 2번째 색, N번째 색을 제외시켜줘야 합니다.
  - 결국 구하고자 하던 DP[N][K] 값은 다음과 같습니다.
  - DP[N][K]=DP[N−3][K−1]+DP[N−1][K]
    - 아 1번째 색을 선택하는 경우와, 선택하지 않는 경우를 각각 구해서 더해주면 되는구나 
- 뭔가 색마다 고유한 숫자를 부여하지 않고 풀어나가는 사고의 전환이 필요했던 것 같은데 이게 어려웠다.
- 원형으로 되어있어도, 선형으로 풀고, 예외 케이스를 처리한다는 느낌으로 접근하는게 오히려 사고하기 편한 것 같다. 배열로 결국 푼다는 마인드.

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {
  static int MOD = 1000000003;
  public static void main(String[] args) throws IOException {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

    int N = Integer.parseInt(br.readLine());
    int K = Integer.parseInt(br.readLine());

    if (N / 2 < K)  {
      System.out.println(0);
      return;
    }

    // 선형으로 된 N개의 색상환에서 K개를 선택하는 경우
    int[][] dp = new int[N + 1][K + 1];

    // 선형 DP 리스트 초기화
    init_dp(dp, N, K);

    // 선형 DP 리스트로 구하였기 때문에 원형의 상황을 가정해서 구해야 한다.
    System.out.println((dp[N - 3][K - 1] + dp[N - 1][K]) % MOD);


  }
  static void init_dp(int[][] dp, int N, int K) {
    for (int i = 1; i < N + 1; i++) {
      dp[i][0] = 1;
      dp[i][1] = i;
    }
    for (int i = 3; i < N + 1; i++) {
      for (int j = 2; j <= (i + 1) / 2 && j < K + 1; j++) {
        // 원형이 아닌 선형 DP 리스트이다.
        dp[i][j] = (dp[i - 1][j] + dp[i - 2][j - 1]) % MOD;
      }
    }
  }
}
```
