# 문제
n×m의 0, 1로 된 배열이 있다. 이 배열에서 1로 된 가장 큰 정사각형의 크기를 구하는 프로그램을 작성하시오.
```
0	1	0	0
0	1	1	1
1	1	1	0
0	0	1	0
```
위와 같은 예제에서는 가운데의 2×2 배열이 가장 큰 정사각형이다.

# 입력
첫째 줄에 n, m(1 ≤ n, m ≤ 1,000)이 주어진다. 다음 n개의 줄에는 m개의 숫자로 배열이 주어진다.

# 출력
첫째 줄에 가장 큰 정사각형의 넓이를 출력한다.
```
예제 입력 1
4 4
0100
0111
1110
0010
예제 출력 1
4
```

# 풀이
- 점화식을 떠올리기 어려워서 결국 못 풀었다.
  - 그냥 dp 문제를 많이 풀어봐야 이건 감각이 생길 것 같다.
- dp문제라는 것을 인지하고 문제 풀이에 접했기 때문에 dp[i][j]가 무엇을 의미할지 고민했다.
  - "(i, j)를 왼쪽 위 꼭짓점으로 갖는 정사각형의 넓이"로 처음 생각했는데, 지금 돌아보니 최악의 선택지인 것 같다.
  - (i, j)를 왼쪽 위로 갖겠다고 하면, 이전에 만들어놓은 dp를 활용할 수가 없다.
  - 따라서 "(i, j)를 오른쪽 아래로 갖는" 까지는 생각해냈어야 하는 것 같다.
  - 또한 정사각형의 넓이라고 생각하면, 연산이 굉장히 복잡해진다.
  - 한 변의 길이만 알면, 넓이는 자동적으로 알 수 있으니, 넓이 대신 길이를 생각해보는 생각의 전환이 필요했다.
- 최대 값을 찾아야 하니, Math.max()를 활용하겠지? 라는 생각으로 접근하니까 더욱 안 풀렸다.
  - 최대값을 찾더라도 Math.min()을 활용해야 조건을 만족시킬 수 있는 상황이 존재한다는 것도 인지해야겠다.
- (i-1, j), (i-1, j-1), (i, j-1) 세 군데 중 min 값에 1을 더하면 된다는 사실을 알아챘어야 했다.
  - 그림을 그려보면 예를 들어 3 * 3 크기의 정사각형을 만드려면, 위 세 가지를 오른쪽 아래 꼭짓점으로 갖고 2 * 2 정사각형을 만들 수 있어야 한다.
  - 그럼 3 * 3 크기에 모두 1이 들어가는 것을 확신할 수 있다.
- 정답 코드
  - https://steady-coding.tistory.com/151

# 풀이 (25.04.06)
- arr[i-1][j], arr[i][j-1], arr[i-1][j-1]이 모두 1이면, dp[i][j] = dp[i-1][j-1] + 1 이라고 생각했다.
  - 근데 그림 그리면서 dp를 채워보니까, 예를 들어 arr[i-1][j]가 1이어도, 해당 값을 오른쪽 아래 꼭짓점으로 했을 때 만들어지는 정사각형의 크기도 중요했다.
  - 따라서 dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 이라는 것을 떠올릴 수 있었다.
  - 손으로 그리다가 깨닫기 전에 먼저 생각할 수 있는 실력이 갖춰져야 안정적으로 문제풀이가 가능할 것 같다.
- 정답코드
```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        int n = sc.nextInt();
        int m = sc.nextInt();
        sc.nextLine();
        
        int[][] arr = new int[n][m];
        int[][] dp = new int[n][m];
        
        int answer = 0;
        for (int i = 0; i < n; i++) {
            String line = sc.nextLine();
            for (int j = 0; j < m; j++) {
                arr[i][j] = Character.getNumericValue(line.charAt(j));
                
                if (arr[i][j] == 1) {
                    // 위, 왼쪽, 왼쪽 위 모두 1이면, min dp에서 뽑아내고, 아니면 그냥 1로 셋팅
                    if (i - 1 >= 0 && j - 1 >= 0 && arr[i-1][j] == 1 && arr[i][j-1] == 1 && arr[i-1][j-1] == 1) {
                        int min = Math.min(dp[i-1][j], dp[i][j-1]);
                        min = Math.min(min, dp[i-1][j-1]);
                        dp[i][j] = min + 1;
                    } else {
                        dp[i][j] = 1;
                    }
                }
                answer = Math.max(answer, dp[i][j]);
            }
        }
    
        System.out.println(answer * answer);
    }
}
```
