# 문제
0부터 N까지의 정수 K개를 더해서 그 합이 N이 되는 경우의 수를 구하는 프로그램을 작성하시오.

덧셈의 순서가 바뀐 경우는 다른 경우로 센다(1+2와 2+1은 서로 다른 경우). 또한 한 개의 수를 여러 번 쓸 수도 있다.

# 입력
첫째 줄에 두 정수 N(1 ≤ N ≤ 200), K(1 ≤ K ≤ 200)가 주어진다.

# 출력
첫째 줄에 답을 1,000,000,000으로 나눈 나머지를 출력한다.
```
예제 입력 1
20 2
예제 출력 1
21
예제 입력 2
6 4
예제 출력 2
84
```

# 풀이
- 처음에 DFS로 중복순열 뽑는 것 말고는 안 떠올랐다. 근데 N = 200이면 DFS 중복순열은 시간 복잡도에서 걸렸을 것 같다.
- dp 문제니까 dp 스럽게 접근하려 했다.
  - 부분을 먼저 구해나가면서 전체를 구하거나 (bottom up)
  - 전체를 먼저 보고 점화식으로 recursive + memoization을 활용하거나 (top down)
  - dp[i] 또는 dp[i][j]를 맛깔나게 정의하거나 (예를 들어 LIS)
- k개를 선택해서 i를 만들어야 하는데, i를 만드는 점에서 동전 문제가 떠올랐다.
  - 예를 들어 1, 3, 5원을 활용해서 거스름돈 16원을 만들어주는데 필요한 최소한의 동전 갯수 구하기 
  - dp[i] : i원을 만드는데 필요한 최소 동전 갯수
  - 위와 같이 dp[i][j]를 i개를 선택해서 j를 만들기 위한 경우의 수로 생각하면 어떨까? 싶었다.
  - 2차원 배열을 활용해서 하나씩 적어보니까 규칙이 쉽게 보여서 풀 수 있었다.
- dp 문제인 걸 몰랐으면 못 풀었을 것 같기도 하다. 음... 풀이방법이 안 떠오르면 일단 dp 아닐까? 의심해봐야 할 것 같다.
```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int n = sc.nextInt();
        int k = sc.nextInt();

        int[][] dp = new int[k + 1][n + 1];
        Arrays.fill(dp[1], 1);
        for (int i = 1; i <= k; i++) {
            dp[i][0] = 1;
        }

        for (int i = 2; i <= k; i++) {
            for (int j = 1; j <= n; j++) {
                dp[i][j] = (dp[i][j - 1] + dp[i - 1][j]) % 1_000_000_000;
            }
        }

        System.out.println(dp[k][n]);
    }
}

```
