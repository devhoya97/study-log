# 동시성 제어
### 동시성 제어란
- DBMS가 다수의 사용자 사이에서 동시에 작용하는 다중 트랜잭션의 상호 간섭 작용에서 DB를 보호하는 것을 의미
- 일반적으로 동시성을 허용하면 일관성이 낮아진다.
- DBMS는 동시성 제어를 위해 Lock 기능과 SET TRANSACTION 명령어를 이용해 트랜잭션의 격리성 수준을 조정할 수 있는 기능 제공
- 동시성 제어의 목표는 동시에 실행되는 트랜잭션의 수를 최대화 하면서 입력, 수정, 삭제, 검색 시 데이터의 무결성을 유지하는 것
- 동시성을 제어하는 방법에는 낙관적 동시성 제어와 비관적 동시성 제어가 있다.

### 낙관적 동시성 제어
- 시용자들이 같은 데이터를 동시에 수정하지 않을 것이라고 가정
- 데이터를 읽는 시점에 Lock을 걸지 않는 대신 수정 시점에 값이 변경됐는지를 반드시 검사

### 비관적 동시성 제어
- 사용자들이 같은 데이터를 동시에 수정할 것이라고 가정
- 데이터를 읽는 시점에 Lock을 걸고, 트랜잭션이 완료될 때까지 이를 유지
- SELECT 시점에 Lock을 거는 비관적 동시성 제어는 시스템의 성능을 심각하게 떨어뜨릴 수 있어서 wait 또는 nowait 옵션과 함께 사용해야 함(?)
- 비관적 동시성 제어를 위한 대표적인 방법이 Lock이고, S-Lock과 X-Lock으로 나뉜다.
  - 획득한 락을 해제하는 방법은 결국 커밋과 롤백 밖에 없다.

### Locking 메커니즘의 문제점
- 읽기 작업과 쓰기 작업이 서로 방해를 일으키기 때문에 동시성 문제가 발생
- 데이터 일관성에 문제가 생기는 경우도 있어서 Lock을 더 오래 유지하거나 테이블 레벨의 Lock을 사용해야 하고, 동시성 저하가 발생

# MVCC
### MVCC (Multi-Version Concurrency Control)
- DB가 동시성을 제어하기 위해 사용하는 방법 중 하나
  - Locking 메커니즘의 문제점을 해결하기 위해 탄생
  - 락을 사용하지 않고 동시성을 제어
- 원본의 데이터와 변경 중인 데이터를 동시에 유지하는 방식으로, 원본 데이터에 대한 스냅샷을 백업하여 보관
  - 두 가지 버전의 데이터가 존재하는 상황에서 새로운 사용자가 데이터에 접근하면 DB의 스냅샷을 읽는다.
  - 변경이 취소되면 스냅샷을 바탕으로 데이터를 복구하고, 변경이 완료되면 최종적으로 디스크에 반영하는 식으로 동작
- 스냅샷을 통해 하나의 레코드에 대해 여러 버전이 관리되는 멀티 버전을 사용
  - 이를 통해 데이터에 대한 변경이 완료(commit)되기 전까지의 변경 사항은 다른 사용자가 볼 수 없도록 제어가 가능 
- 사용하지 않는 데이터가 계속 쌓이게 되므로 데이터를 정리하는 시스템이 필요
  - 하나의 데이터에 대한 여러 버전을 허용하기 때문에 데이터 버전이 충돌될 수 있으므로 애플리케이션 영역에서 이러한 문제를 해결해야 한다.(?)

### MySQL에서의 MVCC
- MySQL의 InnoDB는 레코드 수준의 트랜잭션을 지원하기 위해서 MVCC를 사용하며, 스냅샷으로 언두 로그를 활용한다.
- 디스크의 원본 데이터와 별개로 메모리에는 InnoDB 버퍼 풀, 언두 로그가 관리된다.
  - 수정 작업이 발생하면 COMMIT 실행 여부와 무관하게 InnoDB 버퍼 풀은 새로운 값으로 갱신되며 언두 로그에는 변경 전의 값들만 복사된다.
  - InnoDB 버퍼 풀의 내용은 백그라운드 스레드를 통해 디스크에 기록되는데, 디스크에 반영되었는지 여부는 시점에 따라 다를 수 있다. (바로 반영될 수도 있음)
- 트랜잭션 격리 수준이 READ_UNCOMMITED라면, 버퍼 풀의 데이터를 읽어서 반환하며, 이는 커밋 여부와 무관하게 변경된 데이터를 읽어 반환하는 것이다.
- READ_COMMITED나 그 이상의 격리 수준이라면, 변경되기 이전의 Undo 로그 영역의 데이터를 반환하게 된다.
- Undo 로그 영역의 데이터는 커밋 또는 롤백을 호출하여 InnoDB 버퍼 풀도 이전의 데이터로 복구되고, 더 이상 언두 영역을 필요로 하는 트랜잭션이 더는 없을 때 비로소 삭제된다.
- Undo 로그의 동작 방식 때문에 아래와 같은 상황들은 좋지 않다.
  - 대량의 데이터를 변경 또는 삭제하는 경우
  - 트랜잭션을 오래 유지하는 경우 (이를 위해 네트워크 요청과 관련된 부분은 가능하다면 반드시 트랜잭션 범위에서 제외시켜야 한다.)

### 리두 로그란?
- 리두 로그는 ACID 중 D에 가장 밀접하게 연관돼있다.
- MySQL은 언두 로그와 마찬가지로 데이터 변경 내용을 리두 로그로 기록하고, 이를 통해 MySQL 서버가 비정상적으로 종료됐을 때 일관된 데이터를 갖도록 돕는다.
  - MySQL이 비정상 종료되면, 커밋됐지만 데이터 파일에 기록되지 않은 데이터는 리두 로그의 내용을 복사하기만 하면 된다.
  - 롤백됐지만 데이터 파일에 이미 기록된 데이터는 리두 로그만으로 해결할 수 없고, 변경 전의 데이터를 갖는 언두 로그의 내용을 복사해야 한다.
    - 그럼에도 불구하고 리두 로그가 필요한 이유는, 해당 트랜잭션이 커밋됐는지 혹은 롤백됐는지, 아니면 실행 중인 상태였는지 확인하기 위함
- 리두 로그도 버퍼(메모리) 공간에 존재하며, 리두 로그의 내용을 반영하려면 랜덤 IO를 통해 데이터가 저장될 위치를 찾아야 한다.
  - 매번 디스크에 바로 기록하면 랜덤 IO 때문에 성능이 떨어지므로, 일정 주기로 버퍼의 내용을 디스크에 동기화한다.

### 버퍼풀이란?
- 스토리지 엔진의 핵심 부분으로, 디스크에 저장된 테이블과 인덱스 정보(엄밀히는 페이지)를 캐시해두는 공간이다.
- 버퍼 풀은 데이터를 임시 저장하기 위한 메모리 공간이므로, 
  - 읽기 작업 시 디스크 읽기 횟수를 줄여 성능을 높일 수 있다.
  - 쓰기 작업을 지연시켜 여러 건의 디스크 쓰기를 한 번에 처리해 매번 랜덤 IO가 아닌 일괄 처리로 디스크 IO를 줄여 성능을 높일 수 있다.
- MySQL은 5.6부터 서버가 셧다운 되기 직전에 버퍼풀을 백업하고, 자동으로 복구할 수 있는 기능을 제공해준다.
  - 이렇게 디스크의 데이터가 버퍼풀에 적재된 상태를 워밍업이라고 한다.
  - 그럼 쿼리 성능 측정을 위해 MySQL을 껐다 켜도 버퍼 풀은 남아있을 수 있다는 걸 유의해야겠다.

# 트랜잭션
### 트랜잭션 범위 설정 기준
- 네트워크 통신 작업은 트랜잭션 범위에 포함되지 않도록 제거하는 것이 좋다.
  - 만약 일시적으로 외부 서버와 통신할 수 없는 등의 상태가 된다면 커넥션을 계속 물고 있으면서 서버 뿐만 아니라 데이터베이스까지 위험해질 수 있다. 
  - 그러므로 오랜 시간 소요될 수 있는 메일 전송이나 FTP 파일 전송 등의 네트워크 통신 작업은 어떻게든 트랜잭션 범위에서 제거하는 것이 좋다.
  
### 트랜잭션 범위 안의 읽기와 트랜잭션 범위 밖의 읽기
- READ COMMITED 수준에서는 트랜잭션 내에서 실행되는 SELECT와 트랜잭션 밖에서 실행되는 SELECT는 차이가 별로 없다.
- 하지만 REPEATABLE READ 수준에서는 트랜잭션 범위 안의 읽기의 경우, 다른 트랜잭션에서 특정 데이터를 변경하고 COMMIT해도 동일한 쿼리는 동일한 결과를 반환한다.
  - 이런 문제로 데이터 정합성이 깨지고 애플리케이션 버그가 발생하면 찾기가 쉽지 않다.

# 참고
https://mangkyu.tistory.com/288
