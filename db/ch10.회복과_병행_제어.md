### 트랜잭션
- DB에서 논리적인 작업의 단위
- 트랜잭션의 모든 명령문이 완벽하게 처리되거나 하나도 처리되지 않아야 DB가 모순이 없는 일관된 상태를 유지할 수 있다.
- 트랜잭션은 DB에 장애가 발생했을 때 복구 작업을 수행하거나 다수의 사용자가 동시에 사용할 수 있도록 제어 작업을 하는데 중요한 단위로 사용된다.

### 트랜잭션의 특성(ACID)
- 원자성 
- 일관성 
  - 트랜잭션이 성공적으로 수행된 후에도 DB가 일관된 상태를 유지해야 한다.
  - 트랜잭션을 수행하는 과정에서는 DB가 일시적으로 일관된 상태가 아닐 수 있지만 트랜잭션의 수행이 성공적으로 완료된 후에는 DB가 일관된 상태를 유지해야 한다.
- 격리성
  - 현재 수행 중인 트랜잭션이 완료될 때까지 트랜잭션이 생성한 중간 연산 결과에 다른 트랜잭션들이 접근할 수 없어야 한다.
- 지속성
  - 트랜잭션이 성공적으로 완료된 후 DB에 반영한 수행 결과는 어떤 경우에도 손실되지 않고 영구적이어야 한다.
  - 시스템에 장애가 발생했을 때, 원래 상태로 복구하는 회복 기능을 통해 트랜잭션 작업 결과는 없어지지 않고 DB에 그대로 남아 있어야 한다.

### 트랜잭션의 상태
- 트랜잭션은 다섯 가지 상태 중 하나에 속하게 된다.
  - 활동
    - 트랜잭션이 수행되기 시작하여 현재 수행 중인 상태
    - 상황에 따라 부분 완료 상태나 실패 상태가 된다.
  - 부분 완료
    - 트랜잭션의 마지막 연산이 실행된 직후의 상태
    - 트랜잭션의 모든 연산 처리가 끝났지만, 트랜잭션이 수행된 최종 결과를 DB에 아직 반영하지 않은 상태
    - 상황에 따라 완료 상태나 실패 상태가 될 수 있다.
  - 완료
    - 트랜잭션이 성공적으로 완료되어 commit 연산을 실행한 상태
    - 트랜잭션이 수행한 최종 결과를 DB에 반영하고, DB가 새로운 일관된 상태가 되면서 트랜잭션이 종료된다.
  - 실패
    - 여러 이유로 장애가 발생하여 트랜잭션 수행이 중단된 상태
  - 철회
    - 트랜잭션을 수행하는 데 실패하여 rollback 연산을 실행한 상태
    - 지금까지 실행한 트랜잭션의 연산을 모두 취소하고 트랜잭션이 수행되기 전의 DB 상태로 되돌리면서 트랜잭션이 종료된다.
    - 철회 상태로 종료된 트랜잭션은 상황에 따라 다시 수행되거나 폐기된다.

### DB의 저장 연산
- input(X)
  - 디스크 블록에 저장되어 있는 데이터 X를 메인 메모리 버퍼 블록으로 이동시키는 연산
- output(X)
  - 메인 메모리 버퍼 블록에 있는 데이터 X를 디스크 블록으로 이동시키는 연산
- read(X)
  - 메인 메모리 버퍼 블록에 저장되어 있는 데이터 X를 프로그램의 변수로 읽어오는 연산
- write(X)
  - 프로그램의 변수 값을 메인 메모리 버퍼 블록에 있는 데이터 X에 기록하는 연산

### 회복을 위한 연산
- DB 회복의 핵심 원리는 데이터 중복이다.  
  - 데이터를 별도의 장소에 미리 복사해두고, 장애로 문제가 발생했을 때 복사본을 이용해 원래의 상태로 복원한다.
  - 덤프 또는 로그 방법을 사용해 데이터를 복사해두었다가 회복시킬 때 복사본을 사용한다.
- 덤프
  - DB 전체를 다른 저장 장치에 주기적으로 복사하는 방법
- 로그
  - DB에서 변경 연산이 실행될 때마다 데이터를 변경하기 이전 값과 변경한 이후의 값을 별도의 파일에 기록하는 방법
- 덤프나 로그 방법으로 중복 저장한 데이터를 이용해 DB를 복구하는 가장 기본적인 방법
  - redo
    - 가장 최근에 저장한 DB 복사본을 가져온 후, 로그를 이용해 복사본이 만들어진 이후에 실행된 모든 변경 연산을 재실행하여 장애가 발생하기 직전의 DB 상태로 복구
    - 전반적으로 손상된 경우에 주로 사용
  - undo
    - 로그를 이용해 지금까지 실행된 모든 변경 연산을 취소하여 DB를 원래의 상태로 복구
    - 변경 중이었거나 이미 변경된 내용만 신뢰성을 잃은 경우에 주로 사용

### 데이터베이스 회복 기법
- 로그 회복 기법
  - 즉시 갱신 회복 기법
  - 지연 갱신 회복 기법
- 검사 시점 회복 기법
- 미디어 회복 기법

### 로그
- 로그를 저장한 파일을 로그 파일이라고 하는데, 로그 파일은 레코드 단위로 기록된다.
  - DB에 대한 변경 연산은 트랜잭션 단위로 실행되므로 로그 레코드도 트랜잭션의 수행과 함께 기록된다.
- 로그 파일을 구성하는 레코드는 네 종류로 분류한다.
  - <T_i, start>
  - <T_i, X, old_value, new_value>
  - <T_i, commit>
  - <T_i, abort>

### 로그 회복 기법 (책에 예시 설명이 자세히 나와있음)
- 즉시 갱신 회복 기법 
  - 트랜잭션 수행 중에 데이터를 변경한 연산의 결과를 DB에 즉시 반영
  - 장애 발생에 대비하기 위해 데이터 변경에 대한 내용을 로그 파일에도 기록
    - DB 회복 시 로그를 정상적으로 사용하려면, 트랜잭션에서 데이터 변경 연산이 실행되었을 때 로그 파일에 로그 레코드를 먼저 기록한 후 DB에 변경 연산을 반영해야 한다.
  - 트랜잭션이 완료되기 전에 장애가 발생한 경우 undo 연산을 실행
    - 로그 파일에 <T_i, start> 로그 레코드는 존재하지만 <T_i, commit> 로그 레코드는 존재하지 않는 상태
  - 트랜잭션이 완료된 후에 장애가 발생한 경우 redo 연산을 실행
    - 로그 파일에 <T_i, start> 로그 레코드와 <T_i, commit> 로그 레코드가 모두 존재하는 상태
- 지연 갱신 회복 기법
  - 트랜잭션이 수행되는 동안에는 데이터 변경 연산의 결과를 DB에 즉시 반영하지 않고 로그 파일에만 기록해두었다가, 트랜잭션이 부분 완료된 후에 로그에 기록된 내용을 이용해 DB에 한 번에 반영
  - undo 연산은 필요 없고 redo 연산만 필요하므로 로그 레코드에 변경 이전 값을 기록할 필요가 없어서 <T_i, X, new_value> 형식으로 기록된다.
  - 트랜잭션이 완료되기 전에 장애가 발생할 경우 로그에 기록된 내용을 버리기만 하면 DB가 원래 상태를 그대로 유지하게 된다.
    - 로그 파일에 <T_i, start> 로그 레코드만 존재하고 <T_i, commit> 로그 레코드는 존재하지 않는 상태
  - 트랜잭션이 완료된 후에 장애가 발생한 경우 redo 연산 실행
    - 로그 파일에 <T_i, start> 로그 레코드와 <T_i, commit> 로그 레코드가 모두 존재하는 상태

### 검사 시점 회복 기법
