### B-Tree (Balanced Tree)
- 노드 : 트리 구조에서 데이터가 존재하는 공간
- 루트노드 : 가장 상위 노드
- 리프노드 : 제일 마지막에 존재하는 노드
- 노드는 개념적인 설명에서 주로 나오는 용어이며 MySQL이 B-Tree를 사용할 때는 노드에 해당되는 것이 페이지다.
  - 페이지는 16KB 크기의 최소한의 저장 단위
- B-Tree 구조는 데이터를 검색할 때 아주 뛰어난 성능을 발휘한다.

### 클러스터형 인덱스
- 영어 사전처럼 책의 내용 자체가 순서대로 정렬되어 있어서 인덱스 자체가 책의 내용과 같은 것
- 행 데이터를 클러스터형 인덱스로 지정한 열에 맞춰서 자동 정렬한다.
- 인덱스 페이지가 루트 페이지와 리프 페이지로 구성되어 있으며, 리프 페이지는 데이터 그 자체다.
  - 리프 페이지를 제외한 페이지들은 다음 페이지를 찾아가기 위한 페이지 번호를 저장하고 있다.
  - 모든 페이지의 크기가 16KB라면, 리프페이지의 행 갯수보다 리프페이지가 아닌 인덱스 페이지의 행 갯수가 훨씬 많다. (지피티 피셜) 
- 데이터의 검색 속도가 보조 인덱스보다 더 빠르다.
  - 어짜피 리프 페이지는 정렬되어 있고 리프 페이지가 곧 데이터 페이지이므로, 특히 범위로 검색 시에 아주 우수한 성능을 보인다.

### 보조 인덱스
- <찾아보기>가 별도로 있고, <찾아보기>를 찾은 후에 그 옆에 표시된 페이지로 가야 실제 찾는 내용이 있는 것
- unique 인덱스가 있고 non unique 인덱스가 있다.
  - 테이블에 PRIMARY KEY가 없으면서 UNIQUE NOT NULL 열이 있다면, 해당 열을 기준으로 클러스터형 인덱스가 생성된다.
- 인덱스 페이지가 루트 페이지와 리프 페이지로 구성되어 있으며, 데이터 페이지는 따로 존재한다.
  - 보조 인덱스는 데이터 페이지를 건드리지 않고, 별도의 장소에 인덱스 페이지를 생성한다.
  - 리프 페이지를 제외한 페이지들은 다음 페이지를 찾아가기 위한 페이지 번호를 저장하고 있다.
  - 리프 페이지에는 클러스터형 인덱스와 달리 주소값(데이터 페이지 번호 + #오프셋)이 기록되어 바로 데이터의 위치를 가리킨다.
    - 데이터 페이지의 데이터들은 클러스터형 인덱스를 기준으로 정렬되어 있으므로, 오프셋이 없다면 페이지를 full scan 해야되겠네
  - INSERT시 데이터 페이지는 정렬이 필요 없으므로 데이터가 뒤쪽 빈 부분에 삽입되고, 인덱스 페이지에는 보조 인덱스 컬럼을 기준으로 순서를 고려해서 삽입된다. 

### 페이지 분할
- 인덱스를 구성하면 데이터 변경 작업 시 성능이 나빠지는 단점이 있는데, 특히 INSERT 작업이 일어날 때 페이지 분할이 발생하면 성능이 급격히 느려질 수 있다.
- 특히 루트 페이지가 꽉 차서 루트 페이지를 분할하게 되면, 기존의 루트 페이지는 중간 페이지가 되고, 새로운 루트 페이지가 등장한다.
- 페이지 분할에 비해서 같은 페이지 내에서의 순서 변경은 시스템에 미치는 영향이 미미하다.
- 데이터 페이지가 아닌 인덱스 페이지의 페이지 분할에 비해 데이터 페이지의 페이지 분할은 부하가 큰 작업이다.
  - 데이터 페이지가 아닌 인덱스 페이지에 저장되는 정보 양보다 데이터 페이지의 정보 양이 하나의 행마다 훨씬 많으니까 옮기는데 오래걸리는게 아닐까?

### 클러스터형 인덱스와 보조 인덱스가 혼합되어 있을 경우
- 앞서 클러스터형 인덱스만 있거나 보조 인덱스만 있는 경우를 살펴봤지만, 현실적으로 하나의 테이블에 두 인덱스가 혼합되어 있는 경우가 더 많다.
- 보조 인덱스의 리프 페이지에 주목하자.
  - 클러스터형 인덱스 페이지가 없었다면, 아마도 '데이터 페이지의 주소값'으로 구성되어 있었을 것이다.
  - 하지만 지금은 클러스터형 인덱스의 키 값을 가지게 된다.
  - 따라서 보조 인덱스로 검색한 경우 클러스터형 인덱스의 루트 페이지부터 다시 검색해야 한다.
- 보조 인덱스의 리프 페이지에 기존처럼 '데이터페이지의 번호 + #오프셋'으로 구성하지 않은 이유
  - 검색은 빠르고 효율적이지만, 데이터 변경 시 매우 불리해진다.
  - 만약 데이터 페이지에서 페이지 분할이 발생해서 데이터마다 페이지 번호가 바뀌는 경우, 보조 인덱스의 리프 페이지에 '데이터페이지의 번호 + #오프셋'이 대폭 변경돼야 한다.
- 보조 인덱스의 리프 페이지에는 클러스터형 인덱스의 키 값이 저장되므로 주의해야 할 점
  - 클러스터형 인덱스로 설정한 열이 자릿수가 많은 데이터라면, 보조 인덱스가 차지하는 공간도 늘어나게 된다.
  - 따라서 보조 인덱스와 혼합되어 사용되는 경우에는 되도록이면 클러스터형 인덱스로 설정할 열은 적은 자릿수의 열을 선택하는 것이 바람직하다.

### 인덱스 생성/수정/삭제
- 클러스터형 인덱스는 CREATE INDEX 문으로 만들 수 없고, ALTER TABLE을 사용해야 한다.
  - PK에 설정된 인덱스는 DROP INDEX문으로 삭제되지 않고 ALTER TABLE문으로만 삭제할 수 있다.
  - CREATE INDEX를 사용하지 않고 ALTER TABLE문으로도 인덱스를 생성/수정/삭제할 수 있다.
- CREATE INDEX로 생성되는 인덱스는 보조 인덱스다.
  - 생성한 인덱스를 실제 적용시키려면 ANALYZE TABLE문으로 먼저 테이블을 분석/처리해줘야 한다.
- ASC, DESC와 같이 인덱스가 정렬되는 방식을 정할 수도 있다.
- index_type은 생략하면 기본 값은 B-TREE 형식을 사용한다.
- 인덱스를 모두 제거할 때는 되도록 보조 인덱스부터 삭제하도록 하자.
  - 클러스터형 인덱스를 먼저 삭제하면, 클러스터형 인덱스의 루트 페이지가 없어지므로 보조 인덱스의 리프 페이지는 '페이지 번호 + #오프셋'으로 재구성 되어야 한다.
  - 그런데 재구성 후에 보조 인덱스도 삭제한다면 고생해서 재구성한 것을 또 삭제하는 결과가 된다.
- 인덱스를 많이 생성해 놓은 테이블은 인덱스의 용도를 잘 확인한 후에, 인덱스의 활용도가 떨어진다면 과감히 삭제해 줄 필요가 있다.
  - 그렇지 않으면 전반적인 MySQL의 성능이 저하되는 문제를 야기한다.
  - 한 달에 한 번 또는 일년에 한 번 사용될 인덱스를 계속 유지할 필요는 없다.
- 인덱스의 크기 확인
  - SHOW TABLE STATUS LIKE 'usertbl';
  - 결과 중에서 Data_length는 데이터 페이지 또는 클러스터형 인덱스의 크기를 Byte 단위로 표기한 것.
    - 클러스터형 인덱스를 생성한 적이 없다면 데이터 페이지를 의미한다.
  - MySQL의 페이지 크기는 기본적으로 16KB이므로 클러스터형 인덱스에는 16384B = 1페이지가 할당되어 있다.
    - 루트페이지 + 리프페이지 합한 용량이라고 생각했는데, 각각 1페이지씩 필요한거면 Data_length = 32768이어야 하는 거 아닌가?
  - 실제로는 데이터의 내용이 16KB까지 필요 없어도 할당하는 값의 최소 단위가 1페이지 이므로 1페이지에 해당하는 16KB(변경가능)가 할당된다.
  - index_length는 보조 인덱스의 크기이다.
- name과 birthYear가 조합된 인덱스를 만들면, where 절에서 name만 사용할 때는 인덱스를 쓰고, birthYear만 사용할 때는 인덱스를 안 쓰려나?

### 인덱스의 성능 비교
- 보조 인덱스를 생성하면 index_length 값이 0에서 변하는데, 클러스터형 인덱스를 생성하면 왜 안 변할까?
  - 클러스터형 인덱스 생성으로 인한 루트 페이지나 중간 페이지가 생기는 것은 여기서 딱히 안 치는건가?
  - index_length에서는 인덱스 페이지의 리프 페이지에 할당된 용량만 보여준다고 치면, 말은 된다.
- 다음과 같이 명령을 실행해서 쿼리로 인해 읽은 페이지 수를 비교하는 방법도 있구나
  - SHOW GLOBAL STATUS LIKE 'Innodb_pages_read'; -- 쿼리를 실행 전의 읽은 페이지 수 (ex. 1032)
  - SELECT * FROM emp WHERE emp_no = 100000;
  - SHOW GLOBAL STATUS LIKE 'Innodb_pages_read'; -- 쿼리를 실행 후에 읽은 페이지 수 (ex. 2090)
  - 쿼리를 수행하면서 2090 - 1032 = 1058 페이지를 읽었다고 볼 수 있다.
- 쿼리 실행 계획을 보면 보조 인덱스에는 Key Lookup이라는 말이 있다.
  - 이는 인덱스에서 검색된 RID(Row ID, 각 행의 고유번호)를 가지고 실제 데이터 페이지의 데이터를 찾아가는 과정을 뜻한다.
  - 예르르 들어 BBK로 검색할 경우 인덱스 페이지에서 검색한 RID인 '1002+#2'의 데이터 페이지로 찾아가는 과정이라고 생각하면 쉽게 이해된다.
  - 클러스터형 인덱스에서는 인덱스 페이지의 리프 페이지가 곧 데이터 페이지이므로 Key Lookup이 필요 없다.
- 범위 검색
  - 인덱스가 없다면 하나를 조회하든 범위로 조회하든 전체 테이블 검색이 필요하므로 둘의 큰 차이가 없다.
  - 클러스터형 인덱스의 경우 데이터 페이지가 인덱스를 기준으로 정렬된 상태이기 때문에 범위에 해당하는 데이터들이 모여 있으므로 읽어야 하는 테이블의 갯수가 그리 많지 않다.
  - 보조 인덱스의 경우 데이터 페이지가 인덱스 기준으로 정렬되어 있지 않기 때문에, 최악의 경우 범위를 만족하는 행 수만큼의 페이지를 읽어야 할수도 있다.
    - 일반적으로 범위를 만족하는 행의 갯수가 많으면 full table scan이, 적으면 인덱스를 사용하는 것이 효율적이다.
    - 기존에 생성해 놓은 보조 인덱스 중에서 전체 데이터의 대략 15% 이상을 스캔하는 경우에는 MySQL이 인덱스를 사용하지 않고 테이블 검색을 실시한다.
    - 즉 응용 프로그램이 주로 전체 데이터의 15% 이상의 범위 검색을 하는 경우에는 차라리 인덱스를 만들지 않는 것이 시스템 성능에 도움이 된다.
- 인덱스가 생성된 열에 함수나 연산을 가하게 되면, 인덱스를 사용하지 못할 수가 있으니 조심해야 한다.
- 인덱스 힌트
  - USE INDEX(인덱스이름)
  - IGNORE INDEX(인덱스이름)

### LIKE 연산자
- %나 _가 검색할 문자열의 제일 앞에 들어가는 것은 MySQL 성능에 나쁜 영향을 끼칠 수 있다.
  - 인덱스를 사용하지 못하고 전체 데이터를 검색해야 되기 때문

### OLTP와 OLAP에 인덱스 생성
- OLTP (On-Line Transaction Processing)는 INSERT/UPDATE/DELETE가 실시간으로 자주 발생되므로, 꼭 필요한 인덱스만 최소로 생성하는 것이 바람직
- OLAP (On-Line Analytical Processing)는 INSERT/UPDATE/DELETE가 별로 사용될 일이 없으므로 되도록 인덱스를 많이 만들어도 별 문제가 되지 않음
- 하나의 DB가 OLAP/OLTP 겸용으로 사용된다면 두 개를 분리하는 방법을 고려하는 것이 전반적인 시스템의 성능에 도움이 될 것이다.
  - 실제 서비스를 운영할 때 하나의 테이블을 OLAP용, OLTP용으로 분리하는 경우가 있으려나? 
  - 예를 들어 최근 3개월 데이터는 OLTP용도로, 그 외 데이터는 OLAP 용도로 파티셔닝? 하루짜리 OLTP 테이블과 그 외의 OLAP 테이블로 분리해도 괜찮을 것 같은데

### 결론: 인덱스를 생성해야 하는 경우와 그렇지 않은 경우
- 인덱스를 만드는 절대 기준은 없다. 
  - 테이블의 데이터 구성과 어떠한 조회를 많이 사용하는지 등에 따라 인덱스를 생성해야 한다.
- WHERE 절에 사용되더라도 자주 사용해야 가치가 있다.
  - 인덱스를 생성해서 조회 성능이 높아지더라도, 해당 테이블에 주로 INSERT 작업만이 일어난다면 오히려 손해다.
  - 심지어 클러스터형 인덱스라면 데이터가 입력되는 과정에서 발생하는 페이지 분할이 꽤나 부담스럽다.
- 데이터의 중복도가 높은 열은 인덱스를 만들어도 별 효과가 없다.
- 외래 키를 지정한 열에는 자동의로 외래 키 인덱스가 생성된다.
- JOIN에 자주 사용되는 열에는 인덱스를 생성해 주는 것이 좋다.
- INSERT/UPDATE/DELETE가 얼마나 자주 일어나는지를 고려해야 한다.
- 클러스터형 인덱스가 테이블에 아예 없는 것이 좋은 경우도 있다.
  - 무작위 값을 가진 PK가 테이블에 계속 추가되면 데이터가 입력되는 즉시 정렬이 계속 수행되고 페이지 분할이 끊임 없이 일어날 수 있다.
  - PK를 IDENTITY id 값으로 설정하면 위와 같은 문제는 없을 듯? 그냥 리프 페이지의 가장 끝에 계속 추가하면 되니까
