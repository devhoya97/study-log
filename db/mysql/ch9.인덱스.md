### B-Tree (Balanced Tree)
- 노드 : 트리 구조에서 데이터가 존재하는 공간
- 루트노드 : 가장 상위 노드
- 리프노드 : 제일 마지막에 존재하는 노드
- 노드는 개념적인 설명에서 주로 나오는 용어이며 MySQL이 B-Tree를 사용할 때는 노드에 해당되는 것이 페이지다.
  - 페이지는 16KB 크기의 최소한의 저장 단위
- B-Tree 구조는 데이터를 검색할 때 아주 뛰어난 성능을 발휘한다.

### 클러스터형 인덱스
- 영어 사전처럼 책의 내용 자체가 순서대로 정렬되어 있어서 인덱스 자체가 책의 내용과 같은 것
- 행 데이터를 클러스터형 인덱스로 지정한 열에 맞춰서 자동 정렬한다.
- 인덱스 페이지가 루트 페이지와 리프 페이지로 구성되어 있으며, 리프 페이지는 데이터 그 자체다.
  - 리프 페이지를 제외한 페이지들은 다음 페이지를 찾아가기 위한 페이지 번호를 저장하고 있다.
  - 모든 페이지의 크기가 16KB라면, 리프페이지의 행 갯수보다 리프페이지가 아닌 인덱스 페이지의 행 갯수가 훨씬 많다. (지피티 피셜) 
- 데이터의 검색 속도가 보조 인덱스보다 더 빠르다.
  - 어짜피 리프 페이지는 정렬되어 있고 리프 페이지가 곧 데이터 페이지이므로, 특히 범위로 검색 시에 아주 우수한 성능을 보인다.

### 보조 인덱스
- <찾아보기>가 별도로 있고, <찾아보기>를 찾은 후에 그 옆에 표시된 페이지로 가야 실제 찾는 내용이 있는 것
- unique 인덱스가 있고 non unique 인덱스가 있다.
  - 테이블에 PRIMARY KEY가 없으면서 UNIQUE NOT NULL 열이 있다면, 해당 열을 기준으로 클러스터형 인덱스가 생성된다.
- 인덱스 페이지가 루트 페이지와 리프 페이지로 구성되어 있으며, 데이터 페이지는 따로 존재한다.
  - 보조 인덱스는 데이터 페이지를 건드리지 않고, 별도의 장소에 인덱스 페이지를 생성한다.
  - 리프 페이지를 제외한 페이지들은 다음 페이지를 찾아가기 위한 페이지 번호를 저장하고 있다.
  - 리프 페이지에는 클러스터형 인덱스와 달리 주소값(데이터 페이지 번호 + #오프셋)이 기록되어 바로 데이터의 위치를 가리킨다.
  - INSERT시 데이터 페이지는 정렬이 필요 없으므로 데이터가 뒤쪽 빈 부분에 삽입되고, 인덱스 페이지에는 보조 인덱스 컬럼을 기준으로 순서를 고려해서 삽입된다. 

### 페이지 분할
- 인덱스를 구성하면 데이터 변경 작업 시 성능이 나빠지는 단점이 있는데, 특히 INSERT 작업이 일어날 때 페이지 분할이 발생하면 성능이 급격히 느려질 수 있다.
- 특히 루트 페이지가 꽉 차서 루트 페이지를 분할하게 되면, 기존의 루트 페이지는 중간 페이지가 되고, 새로운 루트 페이지가 등장한다.
- 페이지 분할에 비해서 같은 페이지 내에서의 순서 변경은 시스템에 미치는 영향이 미미하다.
- 데이터 페이지가 아닌 인덱스 페이지의 페이지 분할에 비해 데이터 페이지의 페이지 분할은 부하가 큰 작업이다.
  - 데이터 페이지가 아닌 인덱스 페이지에 저장되는 정보 양보다 데이터 페이지의 정보 양이 하나의 행마다 훨씬 많으니까 옮기는데 오래걸리는게 아닐까?

### 클러스터형 인덱스와 보조 인덱스가 혼합되어 있을 경우
- 앞서 클러스터형 인덱스만 있거나 보조 인덱스만 있는 경우를 살펴봤지만, 현실적으로 하나의 테이블에 두 인덱스가 혼합되어 있는 경우가 더 많다.
- 보조 인덱스의 리프 페이지에 주목하자.
  - 클러스터형 인덱스 페이지가 없었다면, 아마도 '데이터 페이지의 주소값'으로 구성되어 있었을 것이다.
  - 하지만 지금은 클러스터형 인덱스의 키 값을 가지게 된다.
  - 따라서 보조 인덱스로 검색한 경우 클러스터형 인덱스의 루트 페이지부터 다시 검색해야 한다.
  - 




### OLTP와 OLAP에 인덱스 생성
- OLTP (On-Line Transaction Processing)는 INSERT/UPDATE/DELETE가 실시간으로 자주 발생되므로, 꼭 필요한 인덱스만 최소로 생성하는 것이 바람직
- OLAP (On-Line Analytical Processing)는 INSERT/UPDATE/DELETE가 별로 사용될 일이 없으므로 되도록 인덱스를 많이 만들어도 별 문제가 되지 않음
- 하나의 DB가 OLAP/OLTP 겸용으로 사용된다면 두 개를 분리하는 방법을 고려하는 것이 전반적인 시스템의 성능에 도움이 될 것이다.
  - 실제 서비스를 운영할 때 하나의 테이블을 OLAP용, OLTP용으로 분리하는 경우가 있으려나? 
  - 예를 들어 최근 3개월 데이터는 OLTP용도로, 그 외 데이터는 OLAP 용도로 파티셔닝? 하루짜리 OLTP 테이블과 그 외의 OLAP 테이블로 분리해도 괜찮을 것 같은데
