### 트랜잭션
- DB에서 논리적인 작업의 단위
- 트랜잭션의 모든 명령문이 완벽하게 처리되거나 하나도 처리되지 않아야 DB가 모순이 없는 일관된 상태를 유지할 수 있다.
- 트랜잭션은 DB에 장애가 발생했을 때 복구 작업을 수행하거나 다수의 사용자가 동시에 사용할 수 있도록 제어 작업을 하는데 중요한 단위로 사용된다.

### 트랜잭션의 특성(ACID)
- 원자성 
- 일관성 
  - 트랜잭션이 성공적으로 수행된 후에도 DB가 일관된 상태를 유지해야 한다.
  - 트랜잭션을 수행하는 과정에서는 DB가 일시적으로 일관된 상태가 아닐 수 있지만 트랜잭션의 수행이 성공적으로 완료된 후에는 DB가 일관된 상태를 유지해야 한다.
- 격리성
  - 현재 수행 중인 트랜잭션이 완료될 때까지 트랜잭션이 생성한 중간 연산 결과에 다른 트랜잭션들이 접근할 수 없어야 한다.
- 지속성
  - 트랜잭션이 성공적으로 완료된 후 DB에 반영한 수행 결과는 어떤 경우에도 손실되지 않고 영구적이어야 한다.
  - 시스템에 장애가 발생했을 때, 원래 상태로 복구하는 회복 기능을 통해 트랜잭션 작업 결과는 없어지지 않고 DB에 그대로 남아 있어야 한다.

### 트랜잭션의 상태
- 트랜잭션은 다섯 가지 상태 중 하나에 속하게 된다.
  - 활동
    - 트랜잭션이 수행되기 시작하여 현재 수행 중인 상태
    - 상황에 따라 부분 완료 상태나 실패 상태가 된다.
  - 부분 완료
    - 트랜잭션의 마지막 연산이 실행된 직후의 상태
    - 트랜잭션의 모든 연산 처리가 끝났지만, 트랜잭션이 수행된 최종 결과를 DB에 아직 반영하지 않은 상태
    - 상황에 따라 완료 상태나 실패 상태가 될 수 있다.
  - 완료
    - 트랜잭션이 성공적으로 완료되어 commit 연산을 실행한 상태
    - 트랜잭션이 수행한 최종 결과를 DB에 반영하고, DB가 새로운 일관된 상태가 되면서 트랜잭션이 종료된다.
  - 실패
    - 여러 이유로 장애가 발생하여 트랜잭션 수행이 중단된 상태
  - 철회
    - 트랜잭션을 수행하는 데 실패하여 rollback 연산을 실행한 상태
    - 지금까지 실행한 트랜잭션의 연산을 모두 취소하고 트랜잭션이 수행되기 전의 DB 상태로 되돌리면서 트랜잭션이 종료된다.
    - 철회 상태로 종료된 트랜잭션은 상황에 따라 다시 수행되거나 폐기된다.

### DB의 저장 연산
- input(X)
  - 디스크 블록에 저장되어 있는 데이터 X를 메인 메모리 버퍼 블록으로 이동시키는 연산
- output(X)
  - 메인 메모리 버퍼 블록에 있는 데이터 X를 디스크 블록으로 이동시키는 연산
- read(X)
  - 메인 메모리 버퍼 블록에 저장되어 있는 데이터 X를 프로그램의 변수로 읽어오는 연산
- write(X)
  - 프로그램의 변수 값을 메인 메모리 버퍼 블록에 있는 데이터 X에 기록하는 연산

### 회복을 위한 연산
- DB 회복의 핵심 원리는 데이터 중복이다.  
  - 데이터를 별도의 장소에 미리 복사해두고, 장애로 문제가 발생했을 때 복사본을 이용해 원래의 상태로 복원한다.
  - 덤프 또는 로그 방법을 사용해 데이터를 복사해두었다가 회복시킬 때 복사본을 사용한다.
- 덤프
  - DB 전체를 다른 저장 장치에 주기적으로 복사하는 방법
- 로그
  - DB에서 변경 연산이 실행될 때마다 데이터를 변경하기 이전 값과 변경한 이후의 값을 별도의 파일에 기록하는 방법
- 덤프나 로그 방법으로 중복 저장한 데이터를 이용해 DB를 복구하는 가장 기본적인 방법
  - redo
    - 가장 최근에 저장한 DB 복사본을 가져온 후, 로그를 이용해 복사본이 만들어진 이후에 실행된 모든 변경 연산을 재실행하여 장애가 발생하기 직전의 DB 상태로 복구
    - 전반적으로 손상된 경우에 주로 사용
  - undo
    - 로그를 이용해 지금까지 실행된 모든 변경 연산을 취소하여 DB를 원래의 상태로 복구
    - 변경 중이었거나 이미 변경된 내용만 신뢰성을 잃은 경우에 주로 사용

### 데이터베이스 회복 기법
- 로그 회복 기법
  - 즉시 갱신 회복 기법
  - 지연 갱신 회복 기법
- 검사 시점 회복 기법
- 미디어 회복 기법

### 로그
- 로그를 저장한 파일을 로그 파일이라고 하는데, 로그 파일은 레코드 단위로 기록된다.
  - DB에 대한 변경 연산은 트랜잭션 단위로 실행되므로 로그 레코드도 트랜잭션의 수행과 함께 기록된다.
- 로그 파일을 구성하는 레코드는 네 종류로 분류한다.
  - <T_i, start>
  - <T_i, X, old_value, new_value>
  - <T_i, commit>
  - <T_i, abort>

### 로그 회복 기법 (책에 예시 설명이 자세히 나와있음)
- 즉시 갱신 회복 기법 
  - 트랜잭션 수행 중에 데이터를 변경한 연산의 결과를 DB에 즉시 반영
  - 장애 발생에 대비하기 위해 데이터 변경에 대한 내용을 로그 파일에도 기록
    - DB 회복 시 로그를 정상적으로 사용하려면, 트랜잭션에서 데이터 변경 연산이 실행되었을 때 로그 파일에 로그 레코드를 먼저 기록한 후 DB에 변경 연산을 반영해야 한다.
  - 트랜잭션이 완료되기 전에 장애가 발생한 경우 undo 연산을 실행
    - 로그 파일에 <T_i, start> 로그 레코드는 존재하지만 <T_i, commit> 로그 레코드는 존재하지 않는 상태
  - 트랜잭션이 완료된 후에 장애가 발생한 경우 redo 연산을 실행
    - 로그 파일에 <T_i, start> 로그 레코드와 <T_i, commit> 로그 레코드가 모두 존재하는 상태
- 지연 갱신 회복 기법
  - 트랜잭션이 수행되는 동안에는 데이터 변경 연산의 결과를 DB에 즉시 반영하지 않고 로그 파일에만 기록해두었다가, 트랜잭션이 부분 완료된 후에 로그에 기록된 내용을 이용해 DB에 한 번에 반영
  - undo 연산은 필요 없고 redo 연산만 필요하므로 로그 레코드에 변경 이전 값을 기록할 필요가 없어서 <T_i, X, new_value> 형식으로 기록된다.
  - 트랜잭션이 완료되기 전에 장애가 발생할 경우 로그에 기록된 내용을 버리기만 하면 DB가 원래 상태를 그대로 유지하게 된다.
    - 로그 파일에 <T_i, start> 로그 레코드만 존재하고 <T_i, commit> 로그 레코드는 존재하지 않는 상태
  - 트랜잭션이 완료된 후에 장애가 발생한 경우 redo 연산 실행
    - 로그 파일에 <T_i, start> 로그 레코드와 <T_i, commit> 로그 레코드가 모두 존재하는 상태

### 검사 시점 회복 기법
- 로그 회복 기법과 같은 방법으로 로그 기록을 이용하되, 일정 시간 간격으로 검사 시점(checkpoint)을 만들어둔다.
  - 로그 회복 기법은 로그에 기록된 모든 트랜잭션을 대상으로 redo나 undo 중에서 적용할 회복 연산을 결정하여 수행되므로, 너무 많은 시간이 걸린다.
- 장애가 발생하면 가장 최근 checkpoint 이전의 트랜잭션에는 회복 작업을 수행하지 않고, 이후의 트랜잭션에만 회복 작업을 수행한다.
- 일정 시간 간격으로 검사 시점이 되면 메인 메모리에 있는 모든 로그 레코드를 안정 저장 장치에 있는 로그 파일에 기록하고, 트랜잭션의 데이터 변경 내용을 DB에 반영한다.
  - 검사 시점을 표시하는 <checkpoint L> 형식의 로그 레코드를 로그 파일에 기록한다.
  - L은 현재 실행되고 있는 트랜잭션의 리스트
- 장애가 발생하면 로그 파일에서 가장 최근의 <checkpoint L> 로그 레코드를 찾아 회복 작업의 범위를 결정한 뒤, 즉시 갱신 회복 기법이나 지연 갱신 회복 기법을 이용해 회복 작업을 수행한다.

### 미디어 회복 기법
- 디스크에 발생할 수 있는 장애에 대비한 회복 기법
- 전체 DB의 내용을 일정 주기마다 다른 안전한 저장 장치에 복사해두는 덤프를 이용
- 전체 DB를 다른 저장 장치에 복사하는 것은 비용이 많이 들고 복사하는 동안에 트랜잭션 수행을 중단해야 하므로 미디어 회복 기법은 CPU가 낭비된다는 단점이 있다.

### 병행 제어 (concurrency control)
- DBMS는 여러 사용자가 동시에 공유할 수 있도록 여러 개의 트랜잭션이 동시에 수행되는 병행 수행(concurrency)을 지원한다.
  - 병행 수행은 실제로 여러 트랜잭션이 차례로 번갈아 수행되는 인터리빙 방식으로 진행된다.
  - 병행 수행을 하더라도 각 트랜잭션이 다른 트랜잭션의 방해를 받지 않고 정확한 수행 결과를 얻을 수 있도록 제어가 필요
  - 두 트랜잭션을 동시에 수행하더라도 순차적으로 수행한 것과 같은 결과를 얻을 수 있어야 정확한 병행 수행이라 할 수 있다.
- 병행 수행을 특별한 제어 없이 진행했을 때 발생하는 문제
  - 갱신 분실(lost update)
    - 하나의 트랜잭션이 수행한 데이터 변경 연산의 결과를 다른 트랜잭션이 덮어써 변경 연산이 무효화되는 것
  - 모순성(inconsistency)
    - 하나의 트랜잭션이 여러 개의 데이터 변경 연산을 실행할 때 일관성 없는 상태의 DB에서 데이터를 가져와 연산을 실행함으로써 모순된 결과가 발생하는 현상
    - 예를 들어 T1에서 X, Y로 연산을 수행해야 하는데 X에 대한 연산을 수행하고 Y를 읽기 전에 T2가 Y를 변경하면 T1이 읽는 Y는 T2가 변경한 Y값이 된다.
  - 연쇄 복귀(cascading rollback)
    - T1이 변경한 데이터를 T2가 가져가 사용하는데 T1이 롤백하면 T2도 롤백해야 되는 현상
    - 만약 T1이 롤백을 수행하기 전에 T2가 커밋해버리면 T1도 롤백할 수 없는 문제가 발생함

### 트랜잭션 스케줄
- 병행 수행에서 여러 트랜잭션이 인터리빙 방식으로 진행될 때, 그 순서에 따라 트랜잭션들의 수행 결과가 달라지거나 문제가 발생할 수 있다.
  - 따라서 여러 트랜잭션을 병행 수행할 때는 트랜잭션들의 연산을 실행하는 순서가 중요하다.
- 트랜잭션 스케줄 = 트랜잭션에 포함되어 있는 연산들을 수행하는 순서
  - 일반적으로 하나의 트랜잭션에는 많은 연산들이 포함되어 있어 여러 트랜잭션을 병행 수행하는 경우 트랜잭션 스케줄도 여러 가지가 있을 수 있다.
- 트랜잭션 스케줄의 유형
  - 직렬 스케줄
  - 비직렬 스케줄
  - 직렬 가능 스케줄

### 직렬 스케줄
- 인터링빙 방식을 이용하지 않고 트랜잭션별로 연산들을 순차적으로 실행
- 모든 트랜잭션이 완료될 때까지 다른 트랜잭션의 방해를 받지 않고 독립적으로 수행
- 직렬 스케줄에 따라 트랜잭션이 수행되고 나면 항상 모순이 없는 정확한 결과를 얻는다.
- 같은 트랜잭션들을 대상으로 하더라도 트랜잭션의 수행 순서에 따라 다양한 직렬 스케줄이 만들어질 수 있다.
  - 직렬 스케줄마다 DB에 반영되는 최종 결과가 달라질 수 있지만, 모두 정확한 결과라고 볼 수 있다.
- 각 트랜잭션을 독립적으로 수행하기 때문에 트랜잭션들이 동시에 수행되는 병행 수행이라고 할 수 없고, 일반적으로 잘 사용하지 않는다.

### 비직렬 스케줄
- 인터리빙 방식을 이용해 트랜잭션들을 병행해서 수행
- 트랜잭션이 돌아가면서 연산들을 실행하기 때문에 하나의 트랜잭션이 완료되기 전에 다른 트랜잭션의 연산이 실행될 수 있다.
- 갱신 분실, 모순성, 연쇄 복귀 등의 문제가 발생할 수 있어 최종 수행 결과의 정확성을 보장할 수 없다.
- 트랜잭션들의 연산들을 실행하는 순서에 따라 다양한 비직렬 스케줄이 만들어질 수 있다.
  - 이 중에서 모순이 없는 정확한 결과를 생성하는 비직렬 스케줄이 있고, 잘못된 결과를 생성하는 비직렬 스케줄도 있다.
  - 따라서 모순이 없는 비직렬 스케줄을 선택하는 방법이 중요해진다. -> 직렬 가능 스케줄

### 직렬 가능 스케줄
- 직렬 스케줄과 같이 정확한 결과를 생성하는 비직렬 스케줄
- 비직렬 스케줄 중에서 수행 결과가 동일한 직렬 스케줄이 없는 것들은 결과의 정확성을 보장할 수 없으므로 직렬 가능 스케줄이 아니다.
- 직렬 가능 스케줄을 이용해 트랜잭션을 병행 수행해야 하지만 직렬 가능 스케줄인지 여부를 판단하는 일은 쉽지 않다.
  - 따라서 대부분의 DBMS에서는 직렬 가능 스케줄인지를 검사하기보다는 직렬 가능성을 보장하는 병행 제어 기법을 사용한다.

### 병행 제어 기법
- 여러 트랜잭션을 병행 수행하면서도 정확한 결과를 얻을 수 있는 직렬 가능성을 보장받기 위해 사용
- 모든 트랜잭션이 따르면 직렬 가능성이 보장되는 규약을 정의하고, 트랜잭션들이 이 규약을 따르게 한다.
  - 스케줄 내의 모든 트랜잭션이 병행 제어 기법에서 정의한 규약을 따르면 해당 스케줄은 직렬 가능성을 보장할 수 있다.
- 로킹 기법이 가장 많이 사용되는 병행 제어 기법

### 로킹 기법 (locking)
- 병행 수행되는 트랜잭션들이 동일한 데이터에 동시에 접근하지 못하도록 lock과 unlock이라는 2개의 연산을 이용해 제어
- 한 트랜잭션이 먼저 접근한 데이터에 대한 연산을 모두 마칠 때까지, 해당 데이터에 다른 트랜잭션이 접근하지 못하도록 상호 배제하여 직렬 가능성을 보장
- lock 연산의 종류
  - shared lock
    - T1이 데이터에 대해 shared lock 연산을 실행하면,
      - T2는 해당 데이터에 read는 할 수 있어도 write는 할 수 없다.
      - T2도 해당 데이터의 shared lock 연산을 동시에 실행할 수 있다.
  - exclusive lock
    - T1이 데이터에 대해 exclusive lock 연산을 실행하면,  
      - T2는 해당 데이터에 read와 write 모두 실행할 수 없다.
      - T2는 해당 데이터의 shared lock 연산이든 exclusive lock 연산이든 동시에 실행할 수 없다. 
- 기본 로킹 규약만으로는 트랜잭션 스케줄의 직렬 가능성을 완벽하게 보장할 수 없다.
  - lock과 unlock 연산을 실행하는 시점에 대한 새로운 규약이 추가로 필요하다. -> 2단계 로킹 규약

### 2단계 로킹 규약
- 트랜잭션 스케줄의 모든 트랜잭션이 2단계 로킹 규약을 준수하면 해당 스케줄은 직렬 가능성이 보장된다.
- 모든 트랜잭션이 lock과 unlock 연산을 다음과 같이 2단계로 나누어 실행해야 한다.
  1. 확장 단계 : 트랜잭션이 lock 연산만 실행할 수 있고, unlock 연산은 실행할 수 없는 단계
     - 트랜잭션은 첫 번째 unlock 연산을 실행하기 전에 필요한 모든 lock 연산을 실행해야 한다.
  2. 축소 단계 : 트랜잭션이 unlock 연산만 실행할 수 있고, lock 연산은 실행할 수 없는 단계 
- 2단계 로킹 규약을 적용하면 트랜잭션 스케줄의 직렬 가능성을 보장할 수 있지만, 교착 상태가 발생할 수 있어 이에 대한 해결책이 필요하다.

### 교착 상태 (deadlock)
- 트랜잭션들이 상대가 독점하고 있는 데이터에 unlock 연산이 실행되기를 서로 기다리면서 수행을 중단하고 있는 상태
- 예를 들어 T1과 T2가 데이터 X, Y에 접근하는 상황
  - T1 : lock(X) ... lock(Y)를 위해 T2의 unlock(Y)를 기다리는 상황
  - T2 : lock(Y) ... lock(X)를 위해 T1의 unlock(X)를 기다리는 상황
- 처음부터 발생하지 않도록 예방하거나, 발생했을 때 빨리 탐지하여 필요한 조치를 취하는 방법으로 해결한다.
