# 데이터베이스
### 키 종류
### JOIN에 대해서 설명해 주세요.
### 내부 조인, 외부 조인, 셀프 조인
### SQL Injection이란
### 파티셔닝과 샤딩에 대해서 설명해 주세요.
### ORM이란 무엇인가요?
### NoSQL이란 무엇인가요?
### 스키마란 무엇인가요?
### View란 무엇인가요?

# 정규화
### 이상 현상에 대해서 설명해 주세요.
### 정규화에 대해서 설명해 주세요.
### 반정규화란?
### 정규화의 종류에 대해서 말해보세요.
### 함수적 종속성이란 무엇인가요?

# 인덱스
### 인덱스란 무엇인가요? 어떻게 동작 하나요?
인덱스는 데이터베이스에서 검색 속도를 향상시키기 위해 사용되는 자료구조 입니다.
값이 정렬되어 있지 않으면 특정 값을 찾기 위해 완전탐색이 필요한데, 값이 정렬되어 있으면 이분탐색이 가능한 것처럼 
DB 컬럼에 인덱스가 걸려있으면 정렬된 정보를 바탕으로 원하는 값을 빠르게 찾을 수 있습니다.
B Tree 클러스터형 인덱스 기준으로 만약 데이터 페이지가 10개 있다면, 각 데이터 페이지는 PK 기준으로 정렬되어 있고,
루트 페이지에는 각 데이터 페이지의 첫 번째 PK 값과 데이터 페이지의 주소 값이 저장됩니다.
만약 루트 페이지의 엔트리 갯수보다 데이터 페이지의 갯수가 많다면, 중간 테이블이 생기게 되고,
PK를 기준으로 데이터 검색이 필요하면 루트페이지부터 시작해 중간 페이지를 거쳐 데이터 페이지까지 도달하는 과정을 통해 데이터 검색이 가능합니다.

### 인덱스의 알고리즘에는 어떤 것들이 있나요?
MySQL의 InnoDB와 같이 B Tree를 활용한 인덱스 알고리즘은 루트 페이지부터 리프페이지까지 따라가면서 데이터를 검색합니다.
반면 Redis는 Hash Index를 사용해서 키를 해시함수로 변환해 데이터를 곧바로 검색합니다.
B Tree의 경우 특히 클러스터형 인덱스일 때 범위 검색에 큰 강점이 있고, Hash Index의 경우엔 범위 검색이 불가능하다는 단점이 있습니다.

### Table Full Scan과 Index Range Scan 을 설명해주세요.
Index가 걸린 컬럼의 값을 기준으로 범위 검색을 하면 Index Range Scan이 발동되며 조건을 만족하는 행들이 포함된
데이터 페이지에만 접근하므로 Table Full Scan보다 일반적으로 속도가 빠릅니다.
하지만 범위의 대상이 전체 데이터의 일정비율 이상 넘어가면, 오히려 모든 데이터 페이지를 검색하는 것이 빠를 수 있습니다.
따라서 DBMS는 경우에 따라 인덱스를 사용 가능하더라도 Table Full Scan을 선택하기도 합니다.

### 클러스터드 인덱스와 비클러스터드 인덱스란 무엇인가?
클러스터드 인덱스는 리프 페이지가 곧 데이터 페이지 입니다. 따라서 실제 데이터가 클러스터형 인덱스를 기준으로 정렬되어 있습니다.
반면 비클러스터드 인덱스는 실제 데이터에 전혀 영향을 끼치지 않고, 데이터 페이지를 찾아가기 위한 별도의 저장공간을 활용합니다.
특히 클러스터드 인덱스와 비클러스터드 인덱스가 함께 사용될 경우, 비클러스터드 인덱스의 리프페이지에는 클러스터드 인덱스 값이 저장되며
따라서 비클러스터드 인덱스를 사용해 데이터를 검색하려면, 결국 클러스터드 인덱스를 활용해야 최종 데이터를 찾아갈 수 있다는 특징이 있습니다.

### 꼬리질문: 클러스터드 인덱스와 비클러스터드 인덱스가 함께 쓰일 때, 비클러스터드 인덱스로 검색해도 클러스터드 인덱스를 사용해야 하는 이유?
비클러스터드 인덱스의 리프페이지에 데이터의 주소가 아닌 클러스터드 인덱스의 값이 저장되기 때문입니다.
그 이유는, 비클러스터드 인덱스의 리프페이지가 데이터의 주소를 가리키고 있다면, 데이터 페이지에서 페이지 분할이 발생했을 때
비클러스터드 인덱스의 리프페이지 값에 너무나 많은 수정이 필요해지기 때문입니다.

### 인덱스를 추가했을 때 오버헤드는 무엇인가?
인덱스도 결국 하나의 자료구조이기 때문에 데이터와 별개로 저장공간이 할당되어야 합니다.
또한 데이터 삽입, 수정, 삭제시 인덱스도 함께 고려해줘야 하므로, 테이블에 인덱스가 너무 많이 설정되어 있으면 성능이 크게 나빠질 수 있습니다.
특히 데이터 삽입 시 페이지 분할이 일어나는 경우, 일반적인 데이터 삽입에 비해 성능이 크게 나빠집니다.


# 트랜잭션
### 트랜잭션이란 무엇인가요? 4가지 원칙을 포함해서 설명해 주세요.
DB의 논리적인 작업 단위로, 트랜잭션이라면 보장해야 하는 ACID라는 4가지 원칙을 가지고 있습니다. 
원자성은 트랜잭션 내의 모든 작업은 원자적으로 커밋되거나 롤백되어야 함을 의미합니다.
일관성은 트랜잭션을 수행하기 전에 DB의 상태가 유효했다면, 트랜잭션을 수행한 후에도 DB의 상태는 이전과 같이 유효해야 합니다.
격리성은 실행 중인 트랜잭션의 중간 결과를 다른 트랜잭션이 접근할 수 없어야 합니다. 격리수준은 사용자가 선택할 수 있습니다.
지속성은 성공적으로 수행된 트랜잭션의 경우 DB가 시스템적으로 장애가 발생하더라도 데이터가 영구히 보존되어야 합니다. 

### 트랜잭션의 격리 수준과 각 수준에서 발생할 수 있는 문제들에 대해 말해보세요.
read uncommitted는 아직 커밋되지 않은 트랜잭션이 변경한 데이터 변경사항을 다른 트랜잭션이 읽을 수 있는 dirty read 문제가 발생할 수 있습니다.
read committed는 repeatable read가 불가능합니다. 즉 하나의 트랜잭션에서 같은 데이터를 여러 번 읽었을 때, 중간에 다른 트랜잭션이 커밋되면 다른 결과가 나올 수 있습니다.
repeatable read는 MVCC를 이용해 한 트랜잭션 내에서 동일한 결과를 보장하지만, 새로운 레코드가 추가되는 경우에 부정합이 생길 수 있습니다. 이를 팬텀리드 현상이라고 부릅니다.
serializable은 여러 트랜잭션이 동일한 레코드에 동시 접근하지 못하게 만들어 어떠한 데이터 부정합 문제도 발생하지 않지만, 동시 처리 성능이 매우 떨어집니다.

### 꼬리질문1. MVCC에 대해 설명해주세요.
동시성 문제를 해결하기 위해 여러 버전의 언두로그를 관리하는 방법입니다.  
MVCC를 통해 트랜잭션이 롤백된 경우에 데이터를 복원할 수 있을 뿐만 아니라, 서로 다른 트랜잭션 간에 접근할 수 있는 데이터를 세밀하게 제어할 수 있습니다.
repeatable read는 MVCC를 이용해 한 트랜잭션 내에서 동일한 결과를 보장하지만, 새로운 레코드가 추가되는 경우 부정합이 생길 수 있습니다.
락을 동반하지 않은 조회의 경우 MVCC를 이용해 re

### 꼬리질문2. 팬텀리드가 발생하는 상황에 대해 설명해주세요.
잠금이 사용되는 경우(select for update, share 마찬가지). 잠금있는 읽기는 데이터 조회가 언두 로그가 아닌 테이블에서 수행되기 때문에 MVCC로 막을 수 없다.
언두 로그는 append only 형태이므로 잠금 장치가 없기 때문에 잠글 수가 없다.
select for update, share로 레코드를 조회하는 경우에는 언두 영역의 데이터가 아니라 테이블의 레코드를 가져오게 되므로 팬텀리드가 발생한다.
하지만 mysql에는 갭락이 존재하기 때문에 위 상황에서 문제가 발생하지 않는다?
select where id >= 50 for update를 수행하면 mysql은 id가 50인 레코드에는 레코드 락, id가 50보다 큰 범위에는 갭 락으로 넥스트 키 락을 건다.
따라서 다른 트랜잭션이 id가 51인 insert 를 시도한다면 기다려야 한다.
mysql에서 팬텀리드가 발생하는 거의 유일한 케이스 -> tx1에서 잠금없는 selec생 문으로 조회 -> tx2에서 insert -> tx1에서 select for update로 조회하면
언두 로그가 아닌 테이블로부터 레코드를 조회하므로 팬텀리드가 발생. 하지만 이런 케이스는 거의 존재하지 않는다.

### 공유 락과 배타 락의 차이는 무엇인가요?
### 데드락이란 무엇이며, 어떻게 발생할까요?
### Commit과 Rollback이란 무엇인가요?
### 데이터베이스 회복 기법에 대해 설명해주세요.

### 로그회복기법에 대해 설명해주세요.
### 검사시점회복기법에 대해 설명해주세요.
