### 메모리 주소
- 컴퓨터에서는 byte 단위로 메모리 주소를 부여하기 때문에 32비트 주소체계를 사용하면 2^32 바이트만큼의 메모리 공간에 서로 다른 주소를 할당할 수 있다.
- 전국 모든 주소지를 행정구역으로 묶어서 표현하는 것처럼, 메모리를 4KB 단위로 묶어서 페이지라는 하나의 행정구역을 만든다.
  - 페이지 하나의 크기가 2^12 바이트이므로 페이지 내에서 바이트별 위치 구분을 위해서는 12비트가 필요하다.
  - 따라서 총 32비트의 주소 중 하위 12비트는 페이지 내에서의 주소를 나타내게 된다.

### 주소 바인딩
- 프로그램이 실행을 위해 메모리에 적재되면 그 프로세스를 위한 독자적인 주소 공간이 생성된다.
  - 이 주소를 논리적 주소 혹은 가상 주소라고 부른다.
  - CPU는 이와 같이 프로세스마다 독립적으로 갖는 논리적 주소에 근거해 명령을 실행한다.
  - 논리적 주소는 각 프로세스마다 독립적으로 할당되며 0번지부터 시작된다.
- 물리적 주소는 물리적 메모리에 실제로 올라가는 위치를 말한다.
  - 보통 물리적 메모리의 낮은 주소 영역에는 운영체제가 올라가고, 높은 주소 영역에는 사용자 프로세스들이 올라간다.
- 프로세스의 논리적 주소를 물리적 메모리 주소로 연결시켜주는 작업을 주소 바인딩이라고 한다.
  - 컴파일 타임 바인딩
    - 프로그램을 컴파일 할 때 결정되는 주소 바인딩 방식
    - 컴파일 시점에 해당 프로그램이 물리적 메모리의 몇 번지에 위치할 것인지를 결정
    - 이와 같은 주소 바인딩 방식에서 프로그램이 올라가 있는 물리적 메모리의 위치를 변경하고 싶다면, 컴파일을 다시 해야 한다. -> 잘 안쓴다.
  - 로드 타임 바인딩
    - 프로그램의 실행이 시작될 때에 물리적 메모리 주소가 결정되는 주소 바인딩 방식
    - 로더의 책임 하에 물리적 메모리 주소가 부여되며 프로그램이 종료될 때까지 물리적 메모리상의 위치가 고정됨
    - 로더란 사용자 프로그램을 메모리에 적재시키는 프로그램(커널 중 일부인가?)
    - 컴파일러가 재배치 가능 코드(relocatable code)를 생성한 경우에 가능한 주소 바인딩 방식
  - 실행시간 바인딩(execution time binding 또는 run time binding)
    - 프로그램이 실행을 시작한 후에도 그 프로그램이 위치한 물리적 메모리상의 주소가 변경될 수 있는 바인딩 방식
    - CPU가 주소를 참조할 때마다 해당 데이터가 물리적 메모리의 어느 위치에 존재하는지 주소 매핑 테이블(address mapping table)을 이용해 바인딩을 점검해야 한다.
    - 기준 레지스터(base register)와 한계 레지스터(limit register)를 포함해 MMU(Memory Management Unit)라는 하드웨어적인 지원이 뒷받침 되어야 한다.

### MMU
- 논리적 주소를 물리적 주소로 매핑해주는 하드웨어 장치이다.
- CPU가 특정 프로세스의 논리적 주소를 참조하려고 할 때, MMU 기법은 그 주소값에 기준 레지스터의 값을 더해 물리적 주소값을 얻어낸다.
  - 이 때 기준 레지스터는 재배치 레지스터(relocation register)라고도 부르며 그 프로세스의 물리적 메모리 시작 주소를 가지고 있다.
  - 따라서 문맥교환으로 CPU에서 수행 중인 프로세스가 바뀔 때마다 재배치 레지스터의 값을 그 프로세스에 해당되는 값으로 재설정해야 한다.
- MMU 기법에서는 프로그램의 주소 공간이 물리적 메모리의 한 장소에 연속적으로 적재되는 것으로 가정한다.
  - 따라서 그 프로그램이 적재되는 물리적 메모리상의 시작 주소만 알면 주소 변환을 쉽게 할 수 있다.
  - 논리적 주소는 일종의 오프셋 개념으로 생각할 수 있다.
- 한계 레지스터는 현재 CPU에서 수행 중인 프로세스의 논리적 주소의 최댓값, 즉 그 프로세스의 크기를 담고 있다.
  - 프로세스가 자신의 주소 공간을 넘어서는 메모리 참조를 하려고 하는지 체크하는 용도로 사용된다.
  - 이를 통해 메모리 보안을 달성
  - 논리적 주소 값이 한계 레지스터의 값보다 크다면, 다른 프로세스의 주소 영역에 접근하려는 시도이므로 트랩을 발생시켜 해당 프로세스를 강제종료 시킨다.
  - 스왑 메모리를 쓰고 있으면 어떻게 되는거지?

### 동적 로딩
- 여러 프로그램이 동시에 메모리에 올라가서 수행되는 다중 프로그래밍 환경에서 메모리 사용의 효율성을 높이기 위해 사용하는 기법 중 하나
- 프로세스가 시작될 때 그 프로세스의 주소 공간 전체를 메모리에 다 올려놓는 것이 아니라, 실행에 필요한 부분만을 메모리에 적재하는 방식
  - 실제로 프로그램의 코드 중 상당 부분은 오류 처리루틴과 같이 아주 특별한 경우에만 가끔씩 사용되는 방어용 코드이므로 메모리 낭비를 방지해야 한다.
- 동적 로딩은 운영체제의 특별한 지원 없이 프로그램 자체에서 구현 가능하며, 운영체제가 라이브러리를 통해 지원할 수도 있다.
  - 프로그램 자체에서 어떻게 구현하지?

### 동적 연결
- 연결(linking)이란 프로그래머가 작성한 소스 코드를 컴파일하여 생성된 목적 파일(object file)과, 이미 컴파일된 라이브러리 파일들을 묶어 하나의 실행파일을 생성하는 과정
- 동적연결은 컴파일을 통해 생성된 목적 파일과 라이브러리 파일 사이의 연결을 라이브러리 실행 시점까지 지연시키는 기법
  - 실행파일의 라이브러리 호출 부분에는 해당 라이브러리의 위치를 찾기 위한 스텁(stub)이라는 작은 코드를 둔다.
  - 라이브러리 호출 시 스텁을 통해 해당 라이브러리가 메모리에 이미 존재하는지 살펴본다.
    - 존재할 경우 그 주소의 메모리 위치에서 직접 참조
    - 존재하지 않을 경우 디스크에서 동적 라이브러리 파일을 찾아 메모리로 적재한 후 수행
  - 다수의 프로그램이 공통으로 사용하는 라이브러리를 메모리에 한 번만 적재하므로 메모리 사용의 효율성을 높일 수 있다.
- 동적연결 기법은 운영체제의 지원을 필요로 한다.
  - 스텁 코드에서 시스템 콜이 필요할 듯?

### 중첩(overlays)
- 프로세스의 주소 공간을 분할해 실제 필요한 부분만을 메모리에 적재하는 기법
- 동적로딩과 개념적으로 유사하지만 사용하는 이유가 다르다.
  - 중첩은 물리적 메모리의 크기 제약으로 인해 하나의 프로세스 조차도 메모리에 한꺼번에 올릴 수 없을 때, 프로세스의 주소 공간을 분할해서 당장 필요한 일부분을 메모리에 올려 실행하고 해당 부분에 대한 실행이 끝난 후에 나머지 부분을 올려 실행하는 기법
  - 메모리 용량보다 큰 프로세스를 실행하기 위한 어쩔 수 없는 선택
- 운영체제의 지원 없이 프로그래머에 의해 구현되어야 함

### 스와핑
- 메모리에 올라온 프로세스의 주소 공간 전체를 디스크의 스왑 영역에 일시적으로 내려놓는 것
  - 스왑 영역은 백킹스토어라고도 부르며, 디스크 내에 파일 시스템과는 별도로 존재하는 일정 영역
  - 프로세스가 수행 중인 동안에만 디스크에 일시적으로 저장하는 공간이므로 저장 기간이 상대적으로 짧은 저장공간
- 일반적으로 스와핑은 스와퍼라고 불리는 중기 스케줄러에 의해 스왑 아웃시킬 프로세스를 선정한다.
  - 스와핑의 가장 중요한 역할은 메모리에 존재하는 프로세스의 수를 조절하는 것
  - 스왑 아웃 대상으로 선정된 프로세스에 대해서는 현재 메모리에 올라가 있는 주소 공간의 내용을 통째로 디스크 스왑 영역에 스왑 아웃시킨다.
- 컴파일 타임 바인딩 방식과 로드 타임 바인딩 방식에서는 스왑 아웃된 프로세스가 다시 스왑 인 될때에는 원래 존재하던 메모리 위치로 다시 올라가야 한다.
- 실행시간 바인딩 기법에서는 추후 빈 메모리 영역 아무 곳에나 프로세스를 올릴 수 있다.
- 스와핑에서는 보통 디스크 내의 스왑 영역에 프로세스의 주소 공간이 순차적으로 저장되기 때문에, 스와핑에 소요되는 시간은 디스크의 탐색 시간이나 회전지연시간보다는 디스크 섹터에서 실제 데이터를 읽고 쓰는 전송시간이 대부분을 차지한다.

### 물리적 메모리의 할당 방식
- 물리적 메모리는 운영체제 상주 영역과 사용자 프로세스 영역으로 나뉘어 사용된다.
- 사용자 프로세스 영역의 관리 방법
  - 연속할당
    - 각각의 프로세스를 물리적 메모리의 연속적인 공간에 올리는 방식
    - 고정분할 방식
      - 내부조각, 외부조각 모두 발생 가능 
    - 가변분할 방식
      - 외부조각만 발생 가능
      - 물리적 메모리 내 가용 공간 중 어떤 위치에 올릴 것인지 결정해야 하는 동적 메모리 할당 문제 존재
      - 주소 공간의 크기가 n인 프로세스를 동적메모리 할당하기 위한 방법
        - 최초적합
          - 크기가 n이상인 가용 공간 중 먼저 찾아지는 곳에 프로세스 할당
          - 가용 공간을 모두 탐색하는 방법이 아니므로 시간적인 측면에서 효율적
        - 최적적합
          - 크기가 n 이상인 가장 작은 가용 공간을 찾아 그곳에 새로운 프로그램을 할당
          - 가용 공간들의 리스트가 크기순으로 정렬되어 있지 않은 경우에 모든 가용 공간 리스트를 탐색해야 하므로 시간적 오버헤드 발생
          - 다수의 매우 작은 가용 공간들이 생성될 수 있다는 단점이 있지만, 공간적인 측면에서 효율적
        - 최악적합 (제일 구림)
          - 가용 공간 중에서 가장 크기가 큰 곳에 새로운 프로그램을 할당
          - 모든 가용 공간 리스트를 탐색해야 하는 오버헤드 발생
          - 상대적으로 더 큰 프로그램을 담을 수 있는 가용 공간을 빨리 소진한다는 문제점 존재
      - 외부조각 문제를 해결하기 위한 방법으로 컴팩션이라는 것이 있다.
        - 물리적 메모리 중에서 프로세스에 의해 사용 중인 메모리 영역을 한 쪽으로 몰고, 가용 공간들을 다른 한 쪽으로 모아서 하나의 큰 가용 공간을 만드는 방법
        - 현재 수행 중인 프로세스의 메모리상의 위치를 상당 부분 이동시켜야 하므로 비용이 매우 많이 드는 작업
        - 중간에 일부 가용 공간이 발생하더라도 가급적 적은 수의 메모리 이동으로 효율적인 컴팩션을 수행하는 방법 필요 (어려움)
        - 수행 중인 프로세스의 물리적 메모리 위치를 옮겨야 하므로 프로그램의 실행 도중에 프로세스의 주소가 동적으로 바뀔 수 있는 실행시간 바인딩 방식이 지원되는 환경에서만 수행 가능
  - 불연속할당
    - 하나의 프로세스를 물리적 메모리의 여러 영역에 분산해 적재하는 방식
    - 페이징 기법
    - 세그먼테이션 기법
  
### 페이징 기법 
- 각 프로세스의 주소 공간을 동일한 크기의 페이지로 잘라서 메모리에 페이지 단위로 적재
- 물리적 메모리를 페이지와 동일한 크기의 프레임으로 미리 나누어두고, 빈 프레임이 있으면 어떤 위치이든 사용될 수 있다.
- 어디에 넣을지 고민할 필요가 없으므로 동적 메모리 할당 문제가 발생하지 않는다.
- 하나의 프로세스라 하더라도 논리적 주소를 물리적 주소로 변환하는 작업이 페이지 단위로 이루어져야 하기 때문에 다소 복잡
- 모든 프로세스가 각각의 주소 변환을 위한 페이지 테이블을 가진다.
  - 페이지 테이블은 프로세스가 가질 수 있는 페이지의 개수만큼 주소 변환 엔트리를 가진다.
- 외부조각은 발생하지 않는다.
- 프로그램의 크기가 항상 페이지 크기의 배수가 된다는 보장이 없기 때문에 프로세스의 주소 공간 중 제일 마지막에 위치한 페이지에서는 내부조각이 발생할 수 있다.
- CPU가 사용하는 논리적 주소를 페이지 번호와 페이지 오프셋으로 나누어 주소 변환에 사용한다.
  - 페이지 번호는 페이지 테이블 접근 시 인덱스로 사용하며, 페이지 테이블의 엔트리에는 그 페이지의 물리적 메모리상의 기준 주소가 적혀있다.
  - 페이지 오프셋은 하나의 페이지 내에서의 변위를 알려준다.
- 페이지 테이블은 주소 변환을 하기 위한 자료구조로, 물리적 메모리에 위치한다.
  - 운영체제는 현재 CPU에서 실행 중인 프로세스의 페이지 테이블에 접근하기 위해 페이지 테이블 기준 레지스터(PTBR)와 페이지 테이블 길이 레지스터(PTLR)를 참고한다.
- 페이징 기법에서는 주소 변환을 위해 페이지 테이블에 접근하고, 변환된 주소에서 실제 데이터에 접근해야 하므로 두 번의 메모리 접근을 필요로 한다.
  - 페이지 테이블 접근 오버헤드를 줄이기 위해 TLB라는 고속의 주소 변환용 하드웨어 캐시를 활용한다.
  - TLB는 비싸기 때문에 페이지 테이블의 모든 정보를 담을 수는 없으며, 빈번히 참조되는 페이지에 대한 주소 변환 정보만을 담게 된다.
  - 주소 변환 정보는 프로세스별로 다 다르기 때문에 문맥교환 시 이전 프로세스의 주소 변환 정보를 담고 있던 TLB 내용은 모두 지워버려야 한다.
- 페이지 테이블에는 하나의 프로세스를 구성하는 모든 페이지에 대한 주소 변환 정보가 페이지 번호에 따라 순차적으로 들어있다.
  - 따라서 페이지 번호가 주어지면 테이블의 시작 위치에서 페이지 번호만큼 떨어진 항목에 곧바로 접근해 해당 페이지에 대응되는 프레임 번호를 얻을 수 있다.
  - 반면 TLB는 일부 페이지에 대한 주소 변환 정보만 갖기 때문에 페이지 번호와 이에 대응하는 프레임 번호가 쌍으로 저장되어야 한다.
    - TLB의 모든 엔트리를 다 찾아봐야 하는 오버헤드 발생
    - 한 번에 병렬탐색이 가능하도록 연관 레지스터(associative register)를 사용한다. 
      - 연관 레지스터가 TLB와 별도로 존재하는게 아니고, TLB에 들어갈 정보를 연관 레지스터에 저장하는 구조인 듯?
- 계층적 페이징
  - 32비트 주소 체계 -> 프로그램마다 4GB 주소 공간 지원 -> 4GB/4KB = 1M 개의 페이지 테이블 엔트리 필요
  - 각 페이지 테이블 엔트리가 4B를 필요로 한다면, 한 프로세스당 페이지 테이블을 위해 1M * 4B = 4MB 크기의 메모리 공간 필요
  - 대부분의 프로그램은 4GB 주소 공간 중 지극히 일부분만을 사용하므로, 페이지 테이블에서 사용되는 메모리 공간 낭비를 줄이기 위해 2단계 페이징 기법 사용
  - 다만 주소 변환을 위해 접근해야 하는 페이지 테이블의 수가 증가하므로 시간적인 손해가 뒤따른다.
  - 외부 페이지 테이블
    - 사용되지 않는 주소 공간에 대해서 외부 페이지 테이블의 엔트리를 NULL로 설정하며, 여기에 대응하는 내부 페이지 테이블은 생성하지 않는다.
    - 논리적 주소는 P1(외부 페이지 테이블 인덱스) + P2(내부 페이지 테이블 인덱스) + d(오프셋)로 나뉜다.
  - 내부 페이지 테이블
    - 내부 페이지 테이블 자체도 하나의 프레임에 보관하려면 4KB 크기를 가져야 한다.
    - 페이지 테이블 엔트리의 크기가 4B이므로 내부 페이지 테이블은 1K개의 페이지 테이블 엔트리를 갖는다.
    - 따라서 P2는 10bit이다. d는 4KB를 구분하기 위해 12bit를 할당하므로 자연스럽게 P1은 10bit가 된다.
    - 즉 외부 페이지 테이블의 크기도 4KB이므로, 하나의 프로세스를 위한 모든 페이지 테이블의 크기는 (4KB + (4KB * 내부페이지테이블갯수)) 이다.
    - 내부 페이지 테이블 갯수 == 외부 페이지 테이블의 엔트리 중 NULL 값이 아닌 엔트리의 갯수 -> 최대 1K개 존재 가능
  - 프로세스의 주소 공간이 커질수록 3단계, 4단계에 이르는 다단계 페이지 테이블이 필요하게 된다.
    - TLB를 활용하면 페이지 테이블을 4단계로 구성해서 발생하는 시간 오버헤드는 그다지 크지 않으면서 메모리 공간을 매우 효율적으로 사용할 수 있다.
- 역페이지 테이블
  - 물리적 메모리의 페이지 프레임 하나당 페이지 테이블에 하나씩의 엔트리를 두는 방식
  - 각 프로세스마다 페이지 테이블을 두지 않고 시스템 전체에 페이지 테이블을 하나만 두게 된다.
  - 페이지 테이블의 각 항목은 어느 프로세스의 어느 페이지가 이 프레임에 저장되었는지의 정보를 보관하고 있다.
    - pid + p 값을 가진 엔트리가 존재하는지 확인 후, 해당 엔트리의 인덱스 번호를 가지고 물리적 메모리의 프레임 번호를 찾아갈 수 있다.
    - 서로 다른 프로세스는 같은 논리적 주소를 가질 수 있는데, 논리적 주소(p + d) 중 페이지 번호만 페이지 테이블에 저장하게 된다면, 이를 구별할 수 없으므로 pid까지 같이 저장해야 한다.
    - 페이징 테이블 전체를 다 탐색해야 한다. -> TLB와 같이 연관 레지스터에 저장해서 병렬적으로 탐색하자.
- 공유 페이지
  - 공유 코드를 담고 있는 페이지
  - 공유 코드란 메모리 공간의 효율적인 사용을 위해 여러 프로세스에 의해 공통으로 사용될 수 있도록 작성된 코드이며 읽기 전용의 특성을 가진다.
  - 공유 페이지를 공유하는 모든 프로세스의 논리적 주소 공간에서 동일한 위치에 존재하여 동일한 페이지 번호를 가져야 한다.
    - 각 프로세스마다 페이지 테이블이 따로 있지만, 코드에서 사용하는 논리적 주소는 모두 동일하기 때문에 코드 영역의 페이지들은 순서가 유지돼야 한다.
- 메모리 보호
  - 페이지 테이블 엔트리에는 주소 변환 정보뿐 아니라 메모리 보호를 위한 보호비트(protection bit)와 유효-무효 비트(valid-invalid bit)를 두고 있다.
  - 보호비트
    - 한 프로세스의 주소 공간은 다른 프로세스에 의해 접근될 수 없으므로 '누구'에 해당하는 접근 권한은 설정할 필요가 없다.
    - 각 페이지에 대해 read only인지 아닌지에 대한 내용을 판단하는데 사용된다.
  - 유효-무효 비트
    - 유효로 설정되어 있으면 해당 메모리 프레임에 그 페이지가 존재함을 뜻하며, 따라서 접근이 허용된다.
    - 무효로 세팅되어 있는 경우 프로세스가 그 주소 부분을 사용하지 않거나, 해당 페이지가 물리적 메모리에 올라와 있지 않고 백킹스토어에 존재해 해당 메모리 프레임에 유효한 접근 권한이 없다는 의미를 지닌다.

### 세그먼테이션
- 프로그램의 주소 공간을 코드, 데이터, 스택 등 의미 있는 단위인 세그먼트로 나누어 세그먼트 단위로 적재
  - 의미를 가질 수 있는 논리적인 단위로 나눈 것이기 때문에 세그먼트는 그 크기가 균일하지 않다.
    - 물리적 메모리 관리에서 외부 조각이 발생한다.
    - 세그먼트를 어떤 가용 공간에 할당할 것인지 결정하는 로직 필요 (최초적합, 최적적합)
  - 세그먼트 테이블의 각 엔트리는 물리적 메모리에서 세그먼트의 시작 주소를 나타내는 기준점(base)과, 세그먼트의 길이를 나타내는 한계점(limit)을 가지고 있다.
  - 운영체제는 현재 CPU에서 실행 중인 프로세스의 세그먼트 테이블에 접근하기 위해 세그먼트 테이블 기준 레지스터(STBR)와 세그먼트 테이블 길이 레지스터(STLR)를 참고한다.
  - STLR는 현재 CPU에서 실행 중인 프로세스의 주소 공간이 총 몇 개의 세그먼트로 구성되는지를 나타낸다. (그럼 세그먼트 테이블의 크기가 프로세스마다 다른가?)
- 세그먼테이션 기법에서는 논리적 주소를 물리적 주소로 변환하기 전에 두 가지 사항을 먼저 확인한다.
  1. 요청된 세그먼트 번호가 STLR에 저장된 값보다 작은 값인가
  2. 논리적 주소의 오프셋 값이 그 세그먼트의 길이보다 작은 값인가.
     - 세그먼트 테이블의 엔트리에 있는 limit과 요청된 논리적 주소의 오프셋 값을 비교
- 페이징 기법과 마찬가지로 세그먼테이션 기법에서도 각 엔트리마다 보호비트와 유효비트를 둔다.
- 여러 프로세스가 특정 세그먼트를 공유해 사용하는 공유 세그먼트 개념도 지원
  - 이 세그먼트를 공유하는 모든 프로세스의 주소 공간에서 동일한 논리적 주소에 위치해야 한다.
- 세그먼트는 의미 단위로 나누어져 있기 때문에 공유와 보안 측면에서 페이징 기법에 비해 훨씬 효과적
  - 주소 공간의 일부를 공유하거나 특정 주소 공간에 읽기전용 등의 접근 권한 제어를 하고자 할 경우, 이는 어떤 의미 단위로 이루어지지 단순히 크기 단위로 수행되지 않기 때문
- 페이지드 세그먼테이션 기법
  - 세그먼트 하나를 다수의 페이지로 구성 
  - 세그먼테이션 기법에서 발생하는 외부조각 문제를 해결 가능
  - 세그먼트 단위로 프로세스 간의 공유나 프로세스 내의 접근 권한 보호가 이루어지도록 함으로써 페이징 기법의 약점을 해소
  - 주소 변환을 위해 두 단계의 테이블을 이용
    - 외부의 세그먼트 테이블
      - 하나의 세그먼트가 여러 개의 페이지로 구성되므로 각 세그먼트마다 페이지 테이블을 가짐
      - 엔트리에는 세그먼트 길이와 그 세그먼트의 페이지 테이블 시작 주소가 들어 있다.
      - 먼저 세그먼트 길이 값과 논리적 주소의 오프셋 값을 비교하여 유효한 접근인지 검증한다.
      - 검증에 통과하면, 오프셋을 상위 하위 비트로 나누어, 상위 비트는 그 세그먼트 내에서의 페이지 번호로 사용하고 하위 비트는 페이지 내에서의 변위로 사용한다.
    - 내부의 페이지 테이블
