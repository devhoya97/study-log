# 질답 형식으로 요약

<details>
<summary>2회독 때 작성 예정</summary>

...
</details>

<hr style="height: 3px; background-color: black; border: none;">

# 이론 정리

### 메모리 주소
- 컴퓨터에서는 byte 단위로 메모리 주소를 부여하기 때문에 32비트 주소체계를 사용하면 2^32 바이트만큼의 메모리 공간에 서로 다른 주소를 할당할 수 있다.
- 전국 모든 주소지를 행정구역으로 묶어서 표현하는 것처럼, 메모리를 4KB 단위로 묶어서 페이지라는 하나의 행정구역을 만든다.
  - 페이지 하나의 크기가 2^12 바이트이므로 페이지 내에서 바이트별 위치 구분을 위해서는 12비트가 필요하다.
  - 따라서 총 32비트의 주소 중 하위 12비트는 페이지 내에서의 주소를 나타내게 된다.

### 주소 바인딩
- 프로그램이 실행을 위해 메모리에 적재되면 그 프로세스를 위한 독자적인 주소 공간이 생성된다.
  - 이 주소를 논리적 주소 혹은 가상 주소라고 부른다.
  - CPU는 이와 같이 프로세스마다 독립적으로 갖는 논리적 주소에 근거해 명령을 실행한다.
  - 논리적 주소는 각 프로세스마다 독립적으로 할당되며 0번지부터 시작된다.
- 물리적 주소는 물리적 메모리에 실제로 올라가는 위치를 말한다.
  - 보통 물리적 메모리의 낮은 주소 영역에는 운영체제가 올라가고, 높은 주소 영역에는 사용자 프로세스들이 올라간다.
- 프로세스의 논리적 주소를 물리적 메모리 주소로 연결시켜주는 작업을 주소 바인딩이라고 한다.
  - 컴파일 타임 바인딩
    - 프로그램을 컴파일 할 때 결정되는 주소 바인딩 방식
    - 컴파일 시점에 해당 프로그램이 물리적 메모리의 몇 번지에 위치할 것인지를 결정
    - 이와 같은 주소 바인딩 방식에서 프로그램이 올라가 있는 물리적 메모리의 위치를 변경하고 싶다면, 컴파일을 다시 해야 한다. -> 잘 안쓴다.
  - 로드 타임 바인딩
    - 프로그램의 실행이 시작될 때에 물리적 메모리 주소가 결정되는 주소 바인딩 방식
    - 로더의 책임 하에 물리적 메모리 주소가 부여되며 프로그램이 종료될 때까지 물리적 메모리상의 위치가 고정됨
    - 로더란 사용자 프로그램을 메모리에 적재시키는 프로그램(커널 중 일부인가?)
    - 컴파일러가 재배치 가능 코드(relocatable code)를 생성한 경우에 가능한 주소 바인딩 방식
  - 실행시간 바인딩(execution time binding 또는 run time binding)
    - 프로그램이 실행을 시작한 후에도 그 프로그램이 위치한 물리적 메모리상의 주소가 변경될 수 있는 바인딩 방식
    - CPU가 주소를 참조할 때마다 해당 데이터가 물리적 메모리의 어느 위치에 존재하는지 주소 매핑 테이블(address mapping table)을 이용해 바인딩을 점검해야 한다.
    - 기준 레지스터(base register)와 한계 레지스터(limit register)를 포함해 MMU(Memory Management Unit)라는 하드웨어적인 지원이 뒷받침 되어야 한다.

### MMU
- 논리적 주소를 물리적 주소로 매핑해주는 하드웨어 장치이다.
- CPU가 특정 프로세스의 논리적 주소를 참조하려고 할 때, MMU 기법은 그 주소값에 기준 레지스터의 값을 더해 물리적 주소값을 얻어낸다.
  - 이 때 기준 레지스터는 재배치 레지스터(relocation register)라고도 부르며 그 프로세스의 물리적 메모리 시작 주소를 가지고 있다.
  - 따라서 문맥교환으로 CPU에서 수행 중인 프로세스가 바뀔 때마다 재배치 레지스터의 값을 그 프로세스에 해당되는 값으로 재설정해야 한다.
- MMU 기법에서는 프로그램의 주소 공간이 물리적 메모리의 한 장소에 연속적으로 적재되는 것으로 가정한다.
  - 따라서 그 프로그램이 적재되는 물리적 메모리상의 시작 주소만 알면 주소 변환을 쉽게 할 수 있다.
  - 논리적 주소는 일종의 오프셋 개념으로 생각할 수 있다.
- 한계 레지스터는 현재 CPU에서 수행 중인 프로세스의 논리적 주소의 최댓값, 즉 그 프로세스의 크기를 담고 있다.
  - 프로세스가 자신의 주소 공간을 넘어서는 메모리 참조를 하려고 하는지 체크하는 용도로 사용된다.
  - 이를 통해 메모리 보안을 달성
  - 논리적 주소 값이 한계 레지스터의 값보다 크다면, 다른 프로세스의 주소 영역에 접근하려는 시도이므로 트랩을 발생시켜 해당 프로세스를 강제종료 시킨다.
  - 스왑 메모리를 쓰고 있으면 어떻게 되는거지?

### 동적 로딩
- 여러 프로그램이 동시에 메모리에 올라가서 수행되는 다중 프로그래밍 환경에서 메모리 사용의 효율성을 높이기 위해 사용하는 기법 중 하나
- 프로세스가 시작될 때 그 프로세스의 주소 공간 전체를 메모리에 다 올려놓는 것이 아니라, 실행에 필요한 부분만을 메모리에 적재하는 방식
  - 실제로 프로그램의 코드 중 상당 부분은 오류 처리루틴과 같이 아주 특별한 경우에만 가끔씩 사용되는 방어용 코드이므로 메모리 낭비를 방지해야 한다.
- 동적 로딩은 운영체제의 특별한 지원 없이 프로그램 자체에서 구현 가능하며, 운영체제가 라이브러리를 통해 지원할 수도 있다.
  - 프로그램 자체에서 어떻게 구현하지?

### 동적 연결
- 연결(linking)이란 프로그래머가 작성한 소스 코드를 컴파일하여 생성된 목적 파일(object file)과, 이미 컴파일된 라이브러리 파일들을 묶어 하나의 실행파일을 생성하는 과정
- 동적연결은 컴파일을 통해 생성된 목적 파일과 라이브러리 파일 사이의 연결을 라이브러리 실행 시점까지 지연시키는 기법
  - 실행파일의 라이브러리 호출 부분에는 해당 라이브러리의 위치를 찾기 위한 스텁(stub)이라는 작은 코드를 둔다.
  - 라이브러리 호출 시 스텁을 통해 해당 라이브러리가 메모리에 이미 존재하는지 살펴본다.
    - 존재할 경우 그 주소의 메모리 위치에서 직접 참조
    - 존재하지 않을 경우 디스크에서 동적 라이브러리 파일을 찾아 메모리로 적재한 후 수행
  - 다수의 프로그램이 공통으로 사용하는 라이브러리를 메모리에 한 번만 적재하므로 메모리 사용의 효율성을 높일 수 있따.
- 동적연결 기법은 운영체제의 지원을 필요로 한다.
  - 스텁 코드에서 시스템 콜이 필요할 듯?

### 중첩(overlays)
- 프로세스의 주소 공간을 분할해 실제 필요한 부분만을 메모리에 적재하는 기법
- 동적로딩과 개념적으로 유사하지만 사용하는 이유가 다르다.
  - 중첩은 물리적 메모리의 크기 제약으로 인해 하나의 프로세스 조차도 메모리에 한꺼번에 올릴 수 없을 때, 프로세스의 주소 공간을 분할해서 당장 필요한 일부분을 메모리에 올려 실행하고 해당 부분에 대한 실행이 끝난 후에 나머지 부분을 올려 실행하는 기법
  - 메모리 용량보다 큰 프로세스를 실행하기 위한 어쩔 수 없는 선택
- 운영체제의 지원 없이 프로그래머에 의해 구현되어야 함

### 스와핑
- 메모리에 올라온 프로세스의 주소 공간 전체를 디스크의 스왑 영역에 일시적으로 내려놓는 것
  - 스왑 영역은 백킹스토어라고도 부르며, 디스크 내에 파일 시스템과는 별도로 존재하는 일정 영역
  - 프로세스가 수행 중인 동안에만 디스크에 일시적으로 저장하는 공간이므로 저장 기간이 상대적으로 짧은 저장공간
- 일반적으로 스와핑은 스와퍼라고 불리는 중기 스케줄러에 의해 스왑 아웃시킬 프로세스를 선정한다.
  - 스와핑의 가장 중요한 역할은 메모리에 존재하는 프로세스의 수를 조절하는 것
  - 스왑 아웃 대상으로 선정된 프로세스에 대해서는 현재 메모리에 올라가 있는 주소 공간의 내용을 통째로 디스크 스왑 영역에 스왑 아웃시킨다.
- 컴파일 타임 바인딩 방식과 로드 타임 바인딩 방식에서는 스왑 아웃된 프로세스가 다시 스왑 인 될때에는 원래 존재하던 메모리 위치로 다시 올라가야 한다.
- 실행시간 바인딩 기법에서는 추후 빈 메모리 영역 아무 곳에나 프로세스를 올릴 수 있다.
- 스와핑에서는 보통 디스크 내의 스왑 영역에 프로세스의 주소 공간이 순차적으로 저장되기 때문에, 스와핑에 소요되는 시간은 디스크의 탐색 시간이나 회전지연시간보다는 디스크 섹터에서 실제 데이터를 읽고 쓰는 전송시간이 대부분을 차지한다.
- 
