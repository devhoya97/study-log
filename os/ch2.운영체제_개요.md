# 질답 형식으로 요약

<details>
<summary>운영체제는 무엇이고 왜 필요한가요?</summary>

운영체제 외 소프트웨어와 하드웨어 사이에서 3가지 기능을 수행합니다.   
1. 하드웨어 제어를 추상화한 인터페이스를 제공해 다른 소프트웨어가 하드웨어의 동작방식을 몰라도 활용할 수 있도록 돕습니다.
2. 하드웨어 자원과 소프트웨어 자원을 관리합니다. 특히 CPU 스케줄링시 전체적인 성능 향상에 초점을 맞추되 형평성까지 함께 고려합니다.
3. 가상메모리를 활용해 프로세스간 메모리를 격리하여 보안을 유지합니다. 가상메모리와 물리메모리 주소 맵핑은 운영체제가 담당합니다.
</details>

<details>
<summary>TODO: 운영체제가 하드웨어 자원을 관리하는 방법에 대해 자세히 설명해주세요.</summary>

진도 더 나간 후 추후 서술
</details>

<details>
<summary>TODO: 운영체제가 소프트웨어 자원을 관리하는 방법에 대해 자세히 설명해주세요.</summary>

진도 더 나간 후 추후 서술
</details>

<details>
<summary>CPU 스케줄링에 대해 설명해주세요.</summary>

CPU의 개수보다 스레드의 개수가 더 많은 경우 CPU자원을 효율적으로 사용하기 위해 스케줄링이 필요합니다.   
대표적으로 FCFS, Round Robin, 우선순위 스케줄링 방식이 있습니다.   
FCFS는 CPU를 오래 사용해야 하는 프로세스가 CPU를 점유하고 있다면, 이후에 실행되는 모든 프로세스는 CPU를 짧게 필요로 하더라도 오래 기다려야 한다는 문제가 존재합니다.   
Round Robin은 time limit을 정해놓고 여러 프로세스에게 CPU 점유권을 순차적으로 부여하기 때문에 응답시간이 짧고 공평합니다. time limit이 짧을수록 이상적이지만, context switching 비용을 고려해야 합니다.   
우선순위 스케줄링 방식은 시스템적으로 더 중요한 프로세스에게 CPU 점유권을 먼저 부여합니다. starvation을 방지하기 위해 오래 기다릴수록 우선순위를 점차 높여주는 방식을 사용합니다.
</details>

<details>
<summary>운영체제가 메모리를 관리하는 방식에 대해 설명해주세요.</summary>

한정된 메모리 자원을 여러 프로세스가 동시에 사용하기 위해선 메모리 할당시 규칙이 필요합니다.   
대표적으로 고정분할 방식, 가변분할 방식, 가상메모리 방식이 있습니다.

그중 가상메모리 방식이 가장 널리 사용되고 있는데, 이는 프로세스마다 0번지부터 시작하는 메모리 주소를 할당받습니다.   
덕분에 자연스럽게 프로세스간 메모리 격리가 보장되며 물리메모리와 가상메모리 주소간 맵핑은 운영체제가 담당합니다.   
또한 가상메모리 방식은 현재 실행하는데 필요한 페이지만 실제 메모리에 올리고, 그 외는 스왑 메모리에 올림으로써 물리 메모리보다 더 큰 용량의 프로그램도 실행시킬 수 있습니다.   

만약 고정분할 방식과 가변분할 방식에 대해 추가질문이 들어온다면...  
고정분할 방식은 미리 메모리를 분할해두기 때문에 동시에 실행 가능한 프로세스의 수가 정해지고, 분할된 메모리보다 더 큰 용량의 프로세스를 실행할 수 없는 문제가 있습니다. 또한 내부조각이 발생할 수 있습니다.
가변분할 방식은 동시에 실행 가능한 프로세스의 수는 고정되지 않지만, 물리메모리보다 더 큰 용량의 프로그램은 실행시킬 수 없습니다. 또한 외부조각이 발생할 수 있습니다.
</details>

<details>
<summary>인터럽트에 대해 설명해주세요.</summary>

인터럽트란 CPU의 정상흐름을 끊고 특정 작업을 요청합니다.   
특정 프로세스가 디스크로부터 데이터를 읽어야 하는 상황을 예시로 하드웨어 인터럽트와 소프트웨어 인터럽트를 함께 설명드릴 수 있는데요. 
프로세스는 디스크에 직접 접근할 수 없고 운영체제의 도움이 필요하므로 system call을 통해 인터럽트 라인을 세팅합니다.
CPU는 인터럽트 라인을 확인하고 인터럽트 벡터를 참고해 인터럽트 라인에 맞는 인터럽트 처리 루틴을 실행합니다.
디스크 컨트롤러는 CPU의 요청에 따라 디스크로부터 데이터를 읽어오고 로컬버퍼에 데이터를 준비합니다.
데이터가 준비되면 디스크 컨트롤러는 하드웨어 인터럽트를 통해 인터럽트 라인을 세팅합니다.
CPU는 정상동작 중에 인터럽트 라인을 확인하고, 디스크의 로컬버퍼로부터 메모리로 데이터를 읽어온 뒤, 
이를 요청한 프로세스에게 해당 작업이 완료됐음을 표시합니다.
</details>

<hr style="height: 3px; background-color: black; border: none;">

# 이론 정리

### 운영체제 정의
컴퓨터 하드웨어 바로 윗단에 설치되는 소프트웨어로서, 사용자 및 다른 모든 소프트웨어와   
하드웨어를 연결하는 소프트웨어 계층이다.
- 각종 소프트웨어는 하드웨어와 운영체제가 한 몸으로 존재하는 컴퓨터 시스템 위에서 수행된다.

### 운영체제도 하나의 소프트웨어다.
소프트웨어가 컴퓨터 시스템에서 실행되기 위해서는 메모리에 그 프로그램이 올라가 있어야 하는 것처럼   
운영체제도 하나의 소프트웨어로서 전원이 켜짐과 동시에 메모리에 올라간다.
- 운영체제는 규모가 큰 프로그램이므로 한정된 메모리 공간에 모두 올릴 수 없다.
- 이 때 메모리에 상주하는 운영체제의 부분을 커널이라고 부른다.
- 파일 복사와 같은 유틸리티 프로그램은 항상 메모리에 올라가 있는 것이 아닌 별도의 프로그램이지만,   
시스템을 위한 유틸리티로 운영체제에 함께 설치되기 때문에 넓은 의미로는 운영체제에 포함시킨다.

### 운영체제의 기능
- 컴퓨터 시스템 내의 자원을 효율적으로 관리
  - CPU, 메모리, 하드디스크 등 하드웨어 자원 관리
  - 소프트웨어 자원 관리
  - 전체적인 성능 향상에 초점을 맞추되, 사용자 및 프로그램들 간에 자원이 형평성 있게 분배되도록 관리
- 사용자 및 프로그램이 복잡한 하드웨어를 쉽게 다룰 수 있도록 인터페이스 제공 (추상화)
- 프로세스간 격리를 통해 보안 기능
- 시스템 콜 및 인터럽트를 처리

### 운영체제의 분류
기준1. 동시에 여러 프로그램을 실행할 수 있는가?
- 단일작업용 운영체제
  - 현재 실행중인 프로그램이 끝나야만 다른 프로그램 실행이 가능   
- 다중작업용 운영체제
  - 여러 프로그램이 CPU와 메모리를 공유
  - 싱글코어의 경우 매 순간 하나의 프로그램만 CPU에서 실행되지만, 시분할로 실행하면 마치 동시 실행처럼 느껴진다.
  - cf) 서버애플리케이션의 경우 컴퓨터에 하나의 프로그램만 실행되지만, 여러 스레드가 CPU를 시분할로 점유하는 방식으로 IO 대기시간을 최소화

기준2. 동시에 여러 사용자를 수용할 수 있는가?
- 단일 사용자용 운영체제
  - 과거 MS 윈도우는 다중작업이 가능하지만 단일 사용자용 운영체제였음
- 다중 사용자용 운영체제
  - 웹서버와 같이 여러 사용자가 동시에 접속해 사용할 수 있는 컴퓨터를 관리하는 운영체제

기준3. 작업을 처리하는 방식
- 일괄처리 방식 (ex. 초창기 펀치 카드 처리 시스템)
- 시분할 방식
- 실시간(real time)
  - 정해진 시간 안에 어떠한 일이 반드시 처리됨을 보장해야 하는 시스템에서 사용 (ex.미사일 제어)

### 운영체제의 자원 관리 기능(CPU 스케줄링)
- 매 시점 어떠한 프로세스에 CPU를 할당해 작업을 처리할 것인지 결정 (ex. FCFS, Round Robin, 우선순위)
- FCFS
  - CPU를 먼저 얻은 프로세스가 원하는 작업을 완료할 때까지 다른 프로세스들이 CPU를 사용하지 못한다.
  - 장시간 CPU를 사용해야 하는 프로세스가 먼저 도착한 경우, 짧은 수행시간을 가진 프로세스가 이후에 도착하더라도 장시간 기다려야 한다.
  - FCFS의 단점을 보완하고자 Round Robin 기법이 고안되었다.
- Round Robin
  - CPU를 한 번 할당받아 사용할 수 있는 기간을 일정하게 고정된 시간으로 제한
  - 긴 작업을 요하는 프로세스가 CPU를 할당받더라도 정해진 시간이 지나면 CPU를 내어놓고 CPU 대기열의 맨 뒤에 가서 줄을 서야 한다.
  - 긴 작업을 수행하는 프로세스 때문에 짧은 작업을 가진 프로세스들이 무작정 오래 기다려야 하는 상황을 막을 수 있다.
- 우선순위 스케줄링
  - CPU 사용을 위해 대기 중인 프로세스들에 우선순위를 부여하고, 우선순위가 높은 프로세스에 CPU를 먼저 할당
  - 시스템 내의 프로세스 중 상대적으로 더 중요한 프로세스의 우선순위를 높게 하여 CPU를 먼저 획득하게 한다.
  - 기다린 시간이 늘어날수록 우선순위를 점차 높여줌으로써, 지나치게 오래 기다리는 프로세스가 발생하지 않게 한다.
  - 프로세스가 CPU를 한 번 점유하면, 프로세스가 직접 CPU를 반납하기 전까지 계속 사용하는지 여부는 선점형인지 비선점형인지에 따라 다르다.

### 운영체제의 자원 관리 기능(메모리)
- 메모리는 CPU가 직접 접근할 수 있는 기억장치로서 프로그램이 CPU에서 실행되려면 해당 부분이 메모리에 올라가 있어야 한다.
- 한정된 메모리 공간에 여러 프로그램을 수용하려면 메모리에 대한 효율적인 관리 메커니즘이 필요하다.
- 각 프로세스가 자신의 메모리 영역에만 접근할 수 있도록 관리함으로써 보안을 유지한다.
- 물리적 메모리를 관리하는 방식
  - 고정 분할(fixed partition)
    - 물리적 메모리를 몇 개의 분할로 미리 나누어 관리하고, 나뉜 각각의 분할에 하나의 프로그램을 적재한
    - 메모리에 동시 적재되는 최대 프로그램의 수가 분할 개수로 한정되고, 분할의 크기보다 큰 프로그램 적재가 불가능 (융통성 떨어짐)
    - 분할의 크기보다 작은 프로그램이 적재되는 경우 해당 분할 내에 남는 영역(내부조각)이 발생
  - 가변 분할(variable partition)
    - 매 시점 프로그램의 크기에 맞게 메모리를 분할해서 사용
    - 분할의 크기와 개수가 동적으로 변하므로 관리 기법 필요
    - 내부조각은 발생하지 않지만 특정 시나리오에서 외부조각 발생 가능
      - 크기 100짜리 A 실행
      - 크기 50짜리 B 실행
      - A 완료
      - 기존 A의 영역에 크기 80짜리 C 실행 -> 20의 외부조각 발생
    - 물리적 메모리의 크기보다 더 큰 프로그램의 실행은 여전히 불가능
  - 가상메모리(virtual memory)
    - 프로그램의 전체 크기가 2GB일지라도 전체가 항상 동시에 사용되는 것은 아님
      - 현재 사용되고 있는 부분만 메모리에 올리고 나머지는 보조기억장치의 스왑 영역에 저장해두었다가 필요할 때 적재하는 방식을 활용
    - 실행될 수 있는 프로그램의 크기는 가상메모리의 크기에 의해 결정되므로, 물리적 메모리보다 더 큰 프로그램 실행 가능
    - 0번지부터 독립적으로 시작하는 가상메모리의 주소를 물리적 메모리 주소로 매핑하는 역할을 운영체제가 수행
    - 가상메모리 주소 공간은 페이지라는 동일한 크기의 작은 단위로 나뉘어 물리적 메모리와 스왑 영역에 일부분씩 저장

### 인터럽트
- 주변장치들이 CPU의 서비스가 필요한 경우 발생시키는 신호.   
- CPU는 평소에 CPU 스케줄링에 따라 자기에게 주어진 작업을 수행하다가 인터럽트가 발생하면 하던 일을 잠시 멈추고 인터럽트에 의한 요청 서비스를 수행
  - 운영체제는 인터럽트를 처리한후 원래 수행하던 작업으로 돌아오기 위해, 인터럽트 처리 직전에 수행 중이던 작업의 상태를 저장
  - 운영체제는 인터럽트의 종류마다 서로 다른 인터럽트 처리 루틴을 가지고 있음
  - 인터럽트 처리 루틴이란 인터럽트가 발생했을 때 해주어야 할 작업을 정의한 프로그램 코드
- 주변 장치들은 각 장치마다 일어나는 업무를 관리하기 위한 일종의 작은 CPU인 컨트롤러를 가진다.
  - 컨트롤러는 해당 장치에 대한 업무를 처리하고, 메인 CPU에 인터럽트를 발생시켜 보고함
- 프로세스가 주변장치를 이용하고 싶을 때에도 인터럽트(system call) 발생
