# 질답 형식으로 요약

<details>
<summary>2회독 때 작성 예정</summary>

...
</details>

<hr style="height: 3px; background-color: black; border: none;">

# 이론 정리

### 프로그램의 주소 영역
- 프로그램이 CPU에서 명령을 수행하려면 해당 명령을 담은 프로그램의 주소 영역이 메모리에 올라가 있어야 한다.
  - 프로세스가 할당받은 메모리 영역을 프로그램의 주소 영역이라고 이해하면 될 듯
- 프로그램마다 독자적으로 존재하는 주소공간을 가상 메모리 또는 논리적 메모리라고 부른다.
- 프로그램 주소 영역 분류
  - 코드 영역
    - 우리가 작성한 프로그램 함수들의 코드가 CPU에서 수행할 수 있는 기계어 명령 형태로 변환되어 저장되는 부분
  - 데이터 영역
    - 전역 변수 등 프로그램이 사용하는 데이터를 저장하는 부분
  - 스택 영역
    - 함수가 호출될 때 호출된 함수의 수행을 마치고 복귀할 주소 및 데이터를 임시로 저장하는 데에 사용되는 공간
    - 함수 호출과 인터럽트는 CPU가 수행하는 명령의 주소가 점프한다는 점에서 유사한 측면이 있지만, 함수 호출은 복귀 주소가 스택에, 인터럽트는 복귀 주소가 PCB에 저장된다는 차이점 존재
- 운영체제도 하나의 프로그램이므로 운영체제 커널 역시 코드, 데이터, 스택의 주소 공간 구성을 가지고 있다.
  - 커널도 가상메모리를 사용하나?
  - 커널의 데이터 영역에는 하드웨어와 소프트웨어를 포함하는 시스템 내의 모든 자원을 관리하기 위한 자료구조를 각각 유지하고 있다.
    - CPU, 메모리와 같은 하드웨어 자원을 관리하기 위한 자료구조
      - 스케줄링 큐, 페이지 테이블과 같은 자료구조를 말하는 듯
    - 프로세스를 관리하기 위한 자료구조(PCB)
      - PCB에는 프로세스의 상태, CPU 사용 정보, 메모리 사용 정보 등이 저장되어 있다.
  - 커널의 스택 영역은 일반 사용자 프로그램의 스택과 달리 프로세스마다 별도의 스택을 두어 관리한다.
    - 멀티스레드 환경에서 하나의 프로세스 주소 영역에 여러 스레드를 위한 스택이 별도로 존재하는 구조랑 유사한건가?
    - 커널이 시스템 콜을 처리하던 중 시스템 콜 내부에서 다른 함수를 호출하는 경우 그 복귀 주소는 커널 내의 주소가 된다.
    - 따라서 커널의 스택 영역에 프로세스마다 별도의 스택을 두고, 거기에서 복귀 주소를 관리한다.
    - 주의! 시스템 콜이나 인터럽트 발생으로 CPU의 수행 주체가 운영체제로 바뀌는 순간에는 직전에 수행되던 프로그램의 복귀 정보가 스택이 아닌 PCB에 저장된다!


### 컴퓨터 시스템의 작동 개요
- CPU는 어떠한 작업을 수행해야 하는지 스스로 결정하는 능력이 없다.
  - 그저 매 시점 메모리의 특정 주소에 존재하는 명령을 하나씩 읽어와 그대로 실행할 뿐이다.
  - 이 때 CPU가 수행해야 할 명령의 메모리 주소를 담고 있는 레지스터를 PC라고 부른다.
  - 조건문, 반복문, 함수호출을 제외하고 일반적인 경우에 PC는 항상 바로 다음 명령을 가리키게 되어 코드의 순차적인 수행이 이뤄진다.
  - 이렇듯 CPU는 PC가 가리키는 메모리 위치의 명령만 계속 수행하기 때문에 주변장치의 상태를 지속적으로 파악할 수 없다.
    - CPU는 매번 명령을 수행한 직후 인터럽트 라인을 체크해 서브시 요청이 들어왔는지 확인한다.
    - 인터럽트의 종류는 다양하기 때문에 각각의 인터럽트 발생 원인마다 라인을 다르게 해서 구분한다.

### 사용자 프로그램이 사용하는 함수
- 사용자 프로그램이 사용하는 함수 구분
  - 사용자 정의 함수
  - 라이브러리 함수
  - 커널 함수
- 사용자 정의 함수와 라이브러리 함수의 경우 그 프로그램의 코드 영역에 기계어 명령 형태로 존재한다.
  - 따라서 두 함수는 프로그램이 실행될 때에 해당 프로세스의 주소 공간에 포함되며 함수호출 시에도 자신의 주소 공간에 있는 스택을 사용하게 된다.
- 커널 함수의 종류
  - 시스템 콜 함수
  - 각종 하드웨어 및 소프트웨어가 CPU의 서비스를 이용하기 위해 발생시키는 인터럽트 처리 함수
  - 예를 들어 printf()는 라이브러리 함수지만 궁극적으로 특권명령인 입출력을 수반하므로 내부에서 커널함수를 호출하는 시스템 콜을 동반한다.
  - 시스템 콜도 인터럽트와 동일하게 CPU의 인터럽트 라인을 세팅하는 방법을 사용한다.
  - 사실 사용자 프로그램 입장에서 커널은 자신과 다른 하나의 프로그램이다!

### 인터럽트 중 인터럽트?
- 원칙적으로는 인터럽트 처리 중에 또 다른 인터럽트가 발생하는 것을 허용하지 않는다.
  - 인터럽트 처리 중에 다른 인터럽트를 처리하면 데이터의 일관성이 유지되지 않는 문제가 발생할 수 있기 때문이다.
  - ex. 인터럽트 처리 중 커널에 정의된 데이터를 변경하고 있는데, 다른 인터럽트가 발생해 변경 중이던 데이터를 또다시 변경하면 원래 의도하지 않았던 결괏값이 나올 수 있다.
  - 이건 공유 데이터에 대한 락으로 처리할 수 있는거 아닌가?
- 경우에 따라 인터럽트 처리 중에 더 시급하거나 CPU를 당장 사용해야 하는 일이 발생하면, 또다른 인터럽트를 허용하기도 한다.
  - 즉 인터럽트 마다 우선순위가 존재한다.

### 프로세스의 두 가지 실행 상태
- 프로세스 A가 시스템 콜을 요청하여 커널의 코드가 실행중이더라도, 커널이 실행 상태에 있다고 하지 않고 프로세스 A가 실행 상태에 있다고 말한다.
  - 다만 프로세스 A 자신의 코드를 실행하는 것과 구분 지어, 프로세스 A가 커널모드에서 실행 중이라고 이야기 한다.
- 정리하자면 프로그램이 시작되어 종료될 때까지 다양한 함수호출을 하며 실행되는데, 이를 사용자모드와 커널모드의 실행 상태로 구분 지을 수 있다.
