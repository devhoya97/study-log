### Race Condition
- 여러 프로세스들이 동시에 공유 데이터를 접근하는 상황
  - 데이터의 최종 연산 결과는 마지막에 그 데이터를 다룬 프로세스에 따라 달라진다.
- S-box를 공유하는 E-box가 여럿 있는 경우 발생 가능
  - 예를 들어 count++은 instruction level로 분리되면, Load, Inc, Store 세 가지 단계로 분리된다.
  - 프로세스1이 Load를 수행한 뒤 컨텍스트 스위치가 일어나 프로세스2가 같은 데이터에 대해 count++을 하고 프로세스1로 CPU가 돌아오면, race condition 발생
  - 
- 프로세스들은 일반적으로 독립적인 주소공간을 사용하므로 Race Condition이 자주 발생하지는 않는다.
- Race Condition이 발생하는 경우
  - 하나의 프로세스가 커널모드에서 동작 중, 컨텍스트 스위치가 일어나 다른 프로세스에게 CPU를 빼앗기고, 그 프로세스가 또 커널모드에 진입한 경우
    - 커널모드 수행중에는 인터럽트를 disable 함으로써 쉽게 해결 가능
    - 그럼 프로세스에게 할당된 시간이 끝나더라도 CPU를 빼앗지 못하게 되어 모든 프로세스에게 CPU 할당 시간이 완벽히 똑같지 않게 되지만, 이는 큰 문제가 되지 않음  
  - 여러 프로세스가 공유 메모리를 사용하는 경우
    - Single processor 환경일 경우, 공유 메모리에 접근하는 경우에도 인터럽트를 disable하면 쉽게 해결 가능
  - 하지만 멀티프로세서 환경이라면?
    - 위 두 가지 상황에서 인터럽트 disable만으로 해결 불가능
    - 한 번에 하나의 CPU만이 커널에 진입하게 하고, 하나의 CPU만이 공유 메모리에 접근하게 하면, 문제는 해결되지만 굉장히 비효율적이다.
    - 커널 내부에 있는 각 공유 데이터 또는 공유 메모리의 각 데이터마다 lock/unlock을 걸어 해결한다.

### Critical section
- 각 프로세스의 code segment에는 공유 데이터를 접근하는 코드인 critical section이 존재한다.
  - 하나의 프로세스가 critical section에 있을 때 다른 모든 프로세스는 critical section에 들어갈 수 없어야 한다.
  - critical section에 진입하기 전 entry section에서 lock을 건다.
  - critical section에서 나온 직후 exit section에서 공유 데이터에 unlock을 수행한다.
  - 이와 같은 동작은 SW적으로 구현할 수도 있고, HW의 도움을 받을 수도 있다.

### SW적 해결법에서 critical section을 다루기 위해 필요한 조건
1. Mutual Exclusion
    - 프로세스1이 critical section을 수행 중이면, 다른 모든 프로세스들은 그 critical section에 들어가면 안 된다. 
2. Progress
   - 아무도 critical section에 있지 않은 상태에서 critical section에 들어가고자 하는 프로세스가 있으면, 허락해줘야 한다.
   - 뒤에 설명할 알고리즘1,2는 Progress 조건을 충족시키지 못한다.
3. Bounded Waiting
   - 프로세스1이 critical section에 들어가려고 요청한 후부터 그 요청이 허용될 때까지 다른 프로세스들이 critical section에 들어가는 횟수에 한계가 있어야 한다.
   - 즉 critical section에 들어가고자 하는 프로세스가 3개 있는데, 둘이서 독점하고 하나는 무한정 기다리게 되는 상황이 발생하면 안 된다.

### 알고리즘1
- 구현
  - entry section : while (turn != i);
  - critical section
  - exit section : turn = j;
- mutual exclusion은 만족하지만 prgress를 만족하지 못한다.
- Pi는 critical section에 빈번히 들어가고 싶은데 Pj는 한 번만 들어가고 싶은 경우, P0는 어느 순간 영원히 critical section에 들어가지 못하는 문제 발생
  - 반드시 한 번씩 교대로 들어가야 하기 때문에 발생하는 문제임. 즉 과잉양보

### 알고리즘2
- 구현
  - entry section 
    - flag[i] = true;
    - while(flag[j]);
  - critical section
  - exit section : flag[i] = false;
- 알고리즘1보다는 낫지만, progress를 완벽히 해결하지 못한다.
- 서로 flag = true 까지만 수행하고 CPU를 빼앗기는 경우, 아무도 critical section에 들어가지 못했는데 둘 다 무한정 진입하지 못하는 상황 발생

### Peterson의 알고리즘
- 구현
  - entry section
    - flag[i] = true;
    - turn = j;
    - while (flag[j] && turn == j);
  - critical section
  - flag[i] = false;
- 상대방이 critical section에 관심이 없거나, 상대방의 턴이 아니면 내가 진입할 수 있다!
- critical section을 다루기 위해 필요한 세 가지 조건을 모두 만족
- 하지만 Busy Waiting(spin lock) 문제가 존재한다.
  - 즉 본인의 CPU 할당시간동안 while문을 계속 스핀하면서 기다린다.
  - 상대방이 CPU를 잡아야 조건을 만족할 가능성이 생기기 때문에 몇 번을 확인하든 조건을 만족할 수 없으므로 발생하는 문제

### Synchronization HW(HW의 도움을 받는 방법)
- 하드웨어적으로 Test & modify를 원자적으로 수행할 수 있도록 지원하는 경우, 간단하게 문제를 해결할 수 있다.
  - instruction 하나를 수행하는 도중에 인터럽트가 들어와서 CPU를 빼앗길 일이 없기 때문이다.
- 구현
  - entry section : while(Test_and_Set(lock))
  - critical section
  - exit section : lock = false
- Test_and_Set(lock)은 lock 변수의 값을 읽고, 값을 1로 변경하는 작업을 원자적인 instruction으로 수행한다.
- 아무도 락을 안 걸고 있으면, 내가 락을 걸면서 critical section에 진입!
- 하지만 이 방법도 Busy Waiting 문제를 해결하지는 못하는 듯
