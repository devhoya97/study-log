# 질답 형식으로 요약

<details>
<summary>2회독 때 작성 예정</summary>

...
</details>

<hr style="height: 3px; background-color: black; border: none;">

# 이론 정리

### 프로세스의 문맥
- 특정 프로세스가 타이머 인터럽트로 인해 CPU를 빼앗겼다가 다시 재개하는 경우, 정확한 재현을 위해 필요한 정보가 프로세스의 문맥이다.
- 프로세스의 문맥의 구성
  - 하드웨어 문맥
    - PC 값, 각종 레지스터 값
  - 프로세스의 주소 공간
    - 문맥 교환이 일어나더라도, 메모리에 그대로 존재 
  - 커널상의 문맥
    - PCB와 커널스택

### 프로세스의 상태
- 프로세스의 상태 구분 
  - 실행
    - 프로세스가 CPU를 보유하고 기계어 명령을 실행하고 있는 상태
    - 일반적인 컴퓨터 시스템 내에 CPU는 하나뿐이므로 컴퓨터 내에서 여러 프로세스가 동시에 수행된다고 해도 실제로 실행 상태에 있는 프로세스는 매 시점 하나 뿐
  - 준비
    - 프로세스가 CPU만 보유하면 당장 명령을 실행할 수 있지만 CPU를 할당받지 못한 상태
  - 봉쇄(blocked, wait, sleep)
    - CPU를 할당받더라도 당장 명령을 실행할 수 없는 프로세스의 상태
  - 시작
    - 프로세스가 시작되어 그 프로세스를 위한 각종 자료구조는 생성되었지만 아직 메모리 획득을 승인받지 못한 상태
  - 완료
    - 프로세스가 종료되었으나 운영체제가 그 프로세스와 관련된 자료구조를 완전히 정리하지 못한 상태

### 문맥 교환
- 하나의 사용자 프로세스로부터 다른 사용자 프로세스로 CPU의 제어권이 이양되는 과정
  - 인터럽트에 의해 CPU의 제어권이 운영체제로 이양될 때도 CPU의 실행 위치 등 프로세스의 문맥 중 일부를 PCB에 저장하게 되지만 문맥교환이라고 하지는 않는다.
    - 단순한 시스템 콜에서는 PCB에 레지스터 상태를 저장하지 않고, 커널 스택에만 임시로 저장합니다.
    - 문맥 교환이 필요할 경우에는 CPU의 모든 레지스터 상태를 PCB에 저장한 뒤, 새로운 프로세스의 PCB 정보를 로드하여 전환합니다.
  - 이와 같은 모드 변경에 비해 문맥 교환에는 훨씬 많은 오버헤드가 뒤따르게 된다. (캐시 플러시?)
- 문맥 교환이 일어나는 경우
  - 타이머 인터럽트
  - 실행 상태에 있던 프로세스가 입출력 요청으로 봉쇄 상태로 바뀌는 경우
- 준비 상태에 있던 프로세스들 중에서 CPU를 할당받을 프로세스를 선택한 후 실제로 CPU의 제어권을 넘겨받는 과정을 CPU 디스패치라고 한다.

### 디스크 입출력 예시
- 프로세스 A가 시스템 콜로 디스크 입출력을 요청하면, 디스크 입출력을 기다리는 큐에 줄 서 있다가 자기 차례가 되어 디스크 컨트롤러로부터 서비스를 받는다.
- 그 와중에 프로세스 A는 봉쇄 상태가 되므로 준비상태에 있던 프로세스 B에게 CPU가 넘어간다.
- 프로세스 B가 실행 중에 디스크 컨트롤러가 프로세스 A의 요청을 마무리하여 로컬 버퍼에 데이터를 읽어왔다면, 디스크 컨트롤러는 CPU에게 인터럽트를 발생시킨다.
- CPU는 프로세스 B를 실행 중에 인터럽트를 확인하고 운영체제가 프로세스 A로부터 CPU를 뺏어와 인터럽트 처리 루틴을 수행한다.
  - 비록 인터럽트 처리루틴이 프로세스 B와는 무관한 업무를 담고 있지만, 인터럽트 처리를 우리는 편의상 프로세스 B의 문맥에서 실행된 것으로 간주한다.
  - 인터럽트는 프로세스 A의 상태를 봉쇄 상태에서 준비 상태로 바꾼 후, 디스크 로컬버퍼에 있는 내용을 메모리로 이동시키는 일련의 업무를 수행한다.
- 인터럽트 처리가 끝나면 프로세스 B에게 CPU를 다시 할당해 인터럽트 직전에 수행하던 명령 다음부터 명령을 실행한다.
  - 스케줄링 방법에 따라서 프로세스 A의 우선순위가 더 높을 경우 인터럽트가 끝났을 때 문맥교환이 일어나면서 프로세스 A를 실행시킬 수도 있다. (일반적x)
  
### PCB
- 운영체제가 시스템 내의 프로세스들을 관리하기 위해 프로세스마다 유지하는 정보들을 담는 커널 내의 자료구조
- PCB는 다음과 같은 요소들로 구성되어 있다.
  - 프로세스의 상태
  - PC 값
  - CPU register 값
  - CPU 스케줄링 정보
  - 메모리 관리 정보
    - 코드, 데이터, 스택의 위치 정보
  - 자원 사용 정보
    - 사용자에게 자원 사용 요금을 계산해 청구하는 등의 용도로 사용?
  - 입출력 상태 정보
    - 프로세스가 오픈한 파일 정보

### 프로세스를 스케줄링하기 위한 큐
- 운영체제는 준비 상태에 있는 프로세스들을 줄 세우기 위해 준비 큐를 두고 준비 큐의 제일 앞에 줄 서 있는 프로세스에 제일 먼저 CPU를 할당한다.
  - 준비 큐에 프로세스를 줄 세우는 방법은 CPU 스케줄링 방법에 따라 달라진다.
- CPU를 기다리는 프로세스를 줄 세우는 준비 큐 외에도 운영체제는 특정 자원을 기다리는 프로세스들을 줄 세우기 위해 자원별로 장치 큐를 둔다.
  - 장치 컨트롤러는 장치 큐에 있는 순서대로 프로세스들의 요청 작업을 진행한다.
  - 입출력 작업이 완료되고 인터럽트 처리루틴까지 완료된 프로세스는 장치 큐에서 빠져나와 CPU를 기다리는 준비 큐에 줄 서게 된다.
- 위와 같이 하드웨어 자원을 기다리는 큐 말고도 공유 데이터 접근 권한과 같이 소프트웨어 자원을 기다리는 큐도 필요하다.
  - 공유 데이터는 매 시점 하나의 프로세스만이 접근할 수 있도록 해야 한다.
    - 이 때 접근한다는 것이 반드시 CPU가 그 데이터를 사용하고 있음을 의미하는 것은 아니다.
    - 공유 데이터에 접근 중인 프로세스가 준비 상태나 봉쇄 상태로 변경된 경우에도 새롭게 CPU를 할당받은 프로세스가 동일한 데이터에 접근하게 되면 데이터의 일관성이 깨질 수 있으므로 접근을 허락해서는 안 된다.
    - 따라서 여러 프로세스가 공유 데이터에 동시에 접근하려고 할 경우 공유 데이터를 기다리는 큐에 줄 서게 한다.
- 커널은 주소 영역 중 데이터 영역에 다양한 큐를 두어 위와 같이 프로세스의 상태를 관리한다.
  - 예를 들어 타이머 인터럽트가 발생하면 커널은 자신의 데이터 영역에 있는 준비 큐의 정보를 참조해 다음에 어느 프로세스에게 CPU를 할당할 지 결정하고, 현재 실행 중인 프로세스는 준비 큐의 제일 뒤로 보낸다.
- 운영체제는 준비 큐와 장치 큐 외에 작업 큐를 추가로 유지한다.
  - 작업 큐는 시스템 내의 모든 프로세스를 관리하기 위한 큐다.
  - 프로세스의 상태와 무관하게 현재 시스템 내에 있는 모든 프로세스가 작업 큐에 속한다.
  - 그러므로 작업 큐에 있다고 해서 반드시 메모리를 가지고 있는 것은 아니다. (new 상태 외에는 모든 프로세스가 메모리를 가지고 있지 않나? 스왑 아웃?)
  - 작업 큐가 가장 넓은 개념이고 준비 큐와 장치 큐에 있는 프로세스들은 모두 작업 큐에 속한다.
- 큐는 각 프로세스의 PCB를 연결 리스트 형태로 관리하며 포인터를 사용해 순서를 정한다.
  - 큐마다 다음 차례를 찾기 위한 head 포인터, 새로운 대기 프로세스를 추가하기 위한 tail 포인터를 갖는다.

### 스케줄러
- 어떤 프로세스에게 자원을 할당할지를 결정하는 운영체제 커널의 코드를 지칭
- 스케줄러 종류
  - 장기 스케줄러(= 작업 스케줄러)
    - 어떤 프로세스를 준비 큐에 진입시킬지 결정
    - 준비 큐는 CPU만 얻으면 당장 실행될 수 있는 프로세스의 집합이고, CPU에서 실행되기 위해서는 프로세스가 메모리를 보유해야 한다.
    - 따라서 장기 스케줄러는 프로세스에게 메모리를 할당하는 문제에 관여하게 된다.
    - 처음 프로세스가 생성되면 시작 상태를 거쳐 준비 상태에 이르게 되는데 장기 스케줄러는 이 때 시작 상태의 프로세스 들 중 어떠한 프로세스를 준비 큐에 삽입할 것인지 결정하는 역할
    - 메모리에 동시에 올라가 있는 프로세스의 수를 조절하는 역할
    - 장기 스케줄러는 수십 초 내지 수 분 단위로 가끔 호출되기 떄문에 상대적으로 속도가 느린 것이 허용된다.
  - 단기 스케줄러(= CPU 스케줄러)
    - 준비 상태의 프로세스 중 어떤 프로세스를 다음 번에 실행 상태로 만들 것인지 결정
    - 시분할 시스템에서는 타이머 인터럽트가 발생하면 단기 스케줄러가 호출된다.
    - 단기 스케줄러는 밀리초 정도의 시간 단위로 매우 빈번하게 호출되기 때문에 수행 속도가 충분히 빨라야 한다.
- 현대의 시분할 시스템에서 사용되는 운영체제에는 일반적으로 장기 스케줄러를 두지 않는다.
  - 장기 스케줄러는 과거에 자원이 매우 빈약하던 시절에 주로 사용됨
  - 과거에는 적은 양의 메모리를 많은 프로세스들에게 할당하면 프로세스당 메모리 보유량이 지나치게 적어져 시스템의 효율이 매우 떨어졌기 떄문에 장기 스케줄러가 이를 조절함
  - 현대의 시분할 시스템용 운영체제에서는 프로세스가 시작 상태가 되면 장기 스케줄러 없이 곧바로 프로세스에 메모리를 할당해 준비 큐에 넣어줌
  - 현대의 시분할 시스템용 운영체제에서는 장기 스케줄러 대신 중기 스케줄러를 두는 경우가 많다.
    - 중기 스케줄러는 너무 많은 프로세스에게 메모리를 할당해 시스템의 성능이 저하되는 경우, 메모리에 적재된 프로세스의 수를 동적으로 조절
    - 즉 일부 프로세스를 메모리에서 디스크로 스왑 아웃시키는 역할을 수행
    - 스왑아웃 0순위 => 봉쇄 프로세스
    - 0순위 다 내쫓아도 메모리 부족하면, 타이머 인터럽트가 발생해 준비 큐로 이동하는 프로세스를 추가적으로 스왑 아웃
    - 이와 같이 외부적인 이유로 프로세스의 수행이 정지된 상태를 중지 상태라 부른다.
      - 중지 상태는 중지준비 상태와 중지봉쇄 상태로 세분화된다.
      - 중지봉쇄 상태이던 프로세스가 봉쇄되었던 조건을 만족하게 되면 중지준비 상태로 바뀐다.

### 프로세스의 생성
- 시스템이 부팅된 후 최초의 프로세스는 운영체제가 직접 생성하지만, 그 다음부터는 이미 존재하는 프로세스가 다른 프로세스를 복제 생성하게 된다.
  - 부모 프로세스와 자식 프로세스
- 프로세스의 세계에서는 자식이 먼저 죽고, 이에 대한 처리는 자식을 생성했던 부모 프로세스가 담당하는 방식으로 진행
- 자원을 획득하는 방법
  - 운영체제로부터 직접 자원을 할당
  - 부모 프로세스와 자원을 공유해서 사용
- 프로세스가 수행되는 모델
  - 부모와 자식이 공존하며 수행되는 모델 -> 자식과 부모가 같이 CPU를 획득하기 위해 경쟁하는 관계가 됨
  - 자식이 종료될 때까지 부모는 봉쇄 상태에 머무르며 기다리는 모델
    - 부모 프로세스가 fork() 이후 wait() 시스템 콜을 호출하는 경우
    - 이 방식으로 부모 프로세스와 자식 프로세스간의 동기화가 가능해진다. 
- 부모 프로세스가 자식 프로세스를 생성하면 자식 프로세스는 부모 프로세스와는 별도의 주소 공간을 가지게 된다.
  - 처음 주소 공간을 생성할 때에는 부모 프로세스의 주소 공간 내용을 그대로 복사해서 생성한다.
- 프로세스 생성 절차 유닉스 예
  - 유닉스에서는 fork() 시스템 콜을 통해 새로운 프로세스를 생성
  - 이 때 프로세스 ID를 제외한 모든 정보(운영체제 커널 내의 정보와 주소 공간의 정보)를 그대로 복사
    - 복제된 자식 프로세스는 부모 프로세스와 완전히 동일하고, 자신이 원본이라고 생각한다.
    - 다만 fork() 함수의 결괏값으로 원본에게는 양수를 주고 복제본에는 0을 주기 때문에 조건문으로 원본 프로세스와 복제본 프로세스가 다른 작업을 하도록 프로그램을 작성할 수 있다.
    - 이는 조건문에 의한 분기일 뿐 사실상 두 프로세스 모두 동일한 코드의 내용을 가질 수밖에 없다.
    - 자식 프로세스에게 부모와는 다른 독자적인 프로그램을 수행ㅇ시킬 수 있는 메커니즘이 필요하다. -> exec()!
  - 자식 프로세스는 exec() 시스템 콜을 통해 프로세스가 지금까지 수행했던 상태를 잊어버리고 새로운 프로그램으로 주소 공간을 덮어씌운 후 새로운 프로그램의 첫 부분부터 다시 실행
- 프로세스의 종료
  - 자발적 종료
    - 프로세스가 마지막 명령을 수행한 후 exit() 시스템 콜로 자신이 종료됨을 운영체제에게 알림
  - 비자발적 종료
    - 부모 프로세스가 abort() 함수를 사용해 자식 프로세스의 수행을 강제로 종료
      - 자식 프로세스가 할당 자원의 한계치를 넘어서는 많은 양의 자원을 요구할 때
      - 자식 프로세스에게 할당된 작업이 더 이상 필요하지 않을 때
      - 부모 프로세스가 종료되는 경우
  - 부모 프로세스가 종료될 때 자식 프로세스를 계속 실행ㅇ시키기 위해서 종료되지 않을 다른 프로세스의 양자로 자식 프로세스를 보내는 방식도 있다.

### 프로세스 간의 협력
- 원칙적으로 하나의 프로세스는 다른 프로세스의 수행에 영향을 미칠 수 없다.
  - 경우에 따라서 독립적인 프로세스들이 협력할 때 업무의 효율성이 증진될 수 있으므로, 운영체제는 프로세스 간의 협력 메커니즘을 제공한다. 대표적으로 IPC
- IPC(Inter-Process Communication)
  - 하나의 컴퓨터 안에서 실행 중인 서로 다른 프로세스 간에 발생하는 통신
  - 의사소통 기능과 함께 동기화를 보장한다.
    - 하나의 프로세스가 공유 데이터의 값을 변경하는 동안 다른 프로세스는 그 데이터에 접근할 수 없게 해야 한다.
- IPC의 대표적인 방법
  - 메시지 전달 방식
    - 프로세스 사이에 공유데이터 사용 X
    - 두 프로세스의 주소 공간이 다르므로 메시지 전달을 직접 할 수는 없으며 커널이 그 역할을 하게 된다.
      - 커널에 의해 send(message), receive(message) 연산을 제공받음
      - 메시지를 프로세스끼리 직접 주고받을 수 있다면 원하는 않는 메시지를 전달해 다른 프로세스에 악영향을 미칠 수 있으므로 시스템 콜을 통하도록 한다.
    - 통신하기를 원하는 두 프로세스는 커뮤니케이션 링크를 생성한 후 send()와 receive()를 이용해서 메시지를 주고 받는다.
    - 메시지 전송 대상에 따른 분류
      - 직접통신
        - 전송 대상이 다른 프로세스
        - 커무니케이션 링크는 자동으로 생성되고, 하나의 링크는 정확히 한 쌍의 프로세스에게 할당된다.
        - 각 쌍의 프로세스에게는 오직 하나의 링크만이 존재하고, 링크는 단방향성일 수 있으나, 대부분의 경우 양방향성이다.
      - 간접통신
        - 전송 대상이 메일박스라는 일종의 저장공간
        - 메시지를 메일박스 또는 포트로부터 전달받는다.
        - 각 메일박스에는 고유의 ID가 있으며 메일박스를 공유하는 프로세스들만 서로 통신을 할 수 있다.
        - 커뮤니케이션 링크는 프로세스 간에 메일박스를 공유하는 경우에만 생성된다.
  - 공유 메모리 방식
    - 프로세스 사이에 공유데이터 사용 O
    - 운영체제는 공유메모리를 사용하는 시스템 콜을 지원해, 서로 다른 프로세스들이 그들의 주소 공간 중 일부를 공유할 수 있도록 한다.
    - 공유 메모리 영역은 각자의 주소 공간에 공통적으로 포함되는 영역이므로 시스템 콜 없이 일반 메모리처럼 사용 가능
    - 데이터 일관성 문제가 발생할 수 있는데, 커널이 책임지지 않기 때문에 ㅍ로세스들끼리 직접 공유메모리 접근에 대한 동기화 문제를 책임져야 한다.
